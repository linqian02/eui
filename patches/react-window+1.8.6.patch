diff --git a/node_modules/react-window/dist/index-dev.umd.js b/node_modules/react-window/dist/index-dev.umd.js
index 8611055..47613f0 100644
--- a/node_modules/react-window/dist/index-dev.umd.js
+++ b/node_modules/react-window/dist/index-dev.umd.js
@@ -1,2 +1,2 @@
-!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("react")):"function"==typeof define&&define.amd?define(["exports","react"],t):t((e=e||self).ReactWindow={},e.React)}(this,function(e,t){"use strict";function r(){return(r=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var o in r)Object.prototype.hasOwnProperty.call(r,o)&&(e[o]=r[o])}return e}).apply(this,arguments)}function o(e,t){e.prototype=Object.create(t.prototype),e.prototype.constructor=e,e.__proto__=t}function n(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}var i=function(e,t){return e.length===t.length&&e.every(function(e,r){return o=e,n=t[r],o===n;var o,n})};function a(e,t){var r;void 0===t&&(t=i);var o,n=[],a=!1;return function(){for(var i=arguments.length,l=new Array(i),s=0;s<i;s++)l[s]=arguments[s];return a&&r===this&&t(l,n)?o:(o=e.apply(this,l),a=!0,r=this,n=l,o)}}var l="object"==typeof performance&&"function"==typeof performance.now?function(){return performance.now()}:function(){return Date.now()};function s(e){cancelAnimationFrame(e.id)}function c(e,t){var r=l();var o={id:requestAnimationFrame(function n(){l()-r>=t?e.call(null):o.id=requestAnimationFrame(n)})};return o}var u=-1;var d=null;function f(e){if(void 0===e&&(e=!1),null===d||e){var t=document.createElement("div"),r=t.style;r.width="50px",r.height="50px",r.overflow="scroll",r.direction="rtl";var o=document.createElement("div"),n=o.style;return n.width="100px",n.height="100px",t.appendChild(o),document.body.appendChild(t),t.scrollLeft>0?d="positive-descending":(t.scrollLeft=1,d=0===t.scrollLeft?"negative":"positive-ascending"),document.body.removeChild(t),d}return d}var h=150,p=function(e){var t=e.columnIndex;e.data;return e.rowIndex+":"+t},m=null,v=null,g=null;function w(e){var i,l,d=e.getColumnOffset,m=e.getColumnStartIndexForOffset,v=e.getColumnStopIndexForStartIndex,g=e.getColumnWidth,w=e.getEstimatedTotalHeight,I=e.getEstimatedTotalWidth,M=e.getOffsetForColumnAndAlignment,y=e.getOffsetForRowAndAlignment,x=e.getRowHeight,C=e.getRowOffset,_=e.getRowStartIndexForOffset,b=e.getRowStopIndexForStartIndex,R=e.initInstanceProps,T=e.shouldResetStyleCacheOnItemSizeChange,z=e.validateProps;return l=i=function(e){function i(t){var r;return(r=e.call(this,t)||this)._instanceProps=R(r.props,n(n(r))),r._resetIsScrollingTimeoutId=null,r._outerRef=void 0,r.state={instance:n(n(r)),isScrolling:!1,horizontalScrollDirection:"forward",scrollLeft:"number"==typeof r.props.initialScrollLeft?r.props.initialScrollLeft:0,scrollTop:"number"==typeof r.props.initialScrollTop?r.props.initialScrollTop:0,scrollUpdateWasRequested:!1,verticalScrollDirection:"forward"},r._callOnItemsRendered=void 0,r._callOnItemsRendered=a(function(e,t,o,n,i,a,l,s){return r.props.onItemsRendered({overscanColumnStartIndex:e,overscanColumnStopIndex:t,overscanRowStartIndex:o,overscanRowStopIndex:n,visibleColumnStartIndex:i,visibleColumnStopIndex:a,visibleRowStartIndex:l,visibleRowStopIndex:s})}),r._callOnScroll=void 0,r._callOnScroll=a(function(e,t,o,n,i){return r.props.onScroll({horizontalScrollDirection:o,scrollLeft:e,scrollTop:t,verticalScrollDirection:n,scrollUpdateWasRequested:i})}),r._getItemStyle=void 0,r._getItemStyle=function(e,t){var o,n=r.props,i=n.columnWidth,a=n.direction,l=n.rowHeight,s=r._getItemStyleCache(T&&i,T&&a,T&&l),c=e+":"+t;if(s.hasOwnProperty(c))o=s[c];else{var u=d(r.props,t,r._instanceProps),f="rtl"===a;s[c]=o={position:"absolute",left:f?void 0:u,right:f?u:void 0,top:C(r.props,e,r._instanceProps),height:x(r.props,e,r._instanceProps),width:g(r.props,t,r._instanceProps)}}return o},r._getItemStyleCache=void 0,r._getItemStyleCache=a(function(e,t,r){return{}}),r._onScroll=function(e){var t=e.currentTarget,o=t.clientHeight,n=t.clientWidth,i=t.scrollLeft,a=t.scrollTop,l=t.scrollHeight,s=t.scrollWidth;r.setState(function(e){if(e.scrollLeft===i&&e.scrollTop===a)return null;var t=r.props.direction,c=i;if("rtl"===t)switch(f()){case"negative":c=-i;break;case"positive-descending":c=s-n-i}c=Math.max(0,Math.min(c,s-n));var u=Math.max(0,Math.min(a,l-o));return{isScrolling:!0,horizontalScrollDirection:e.scrollLeft<i?"forward":"backward",scrollLeft:c,scrollTop:u,verticalScrollDirection:e.scrollTop<a?"forward":"backward",scrollUpdateWasRequested:!1}},r._resetIsScrollingDebounced)},r._outerRefSetter=function(e){var t=r.props.outerRef;r._outerRef=e,"function"==typeof t?t(e):null!=t&&"object"==typeof t&&t.hasOwnProperty("current")&&(t.current=e)},r._resetIsScrollingDebounced=function(){null!==r._resetIsScrollingTimeoutId&&s(r._resetIsScrollingTimeoutId),r._resetIsScrollingTimeoutId=c(r._resetIsScrolling,h)},r._resetIsScrolling=function(){r._resetIsScrollingTimeoutId=null,r.setState({isScrolling:!1},function(){r._getItemStyleCache(-1)})},r}o(i,e),i.getDerivedStateFromProps=function(e,t){return S(e,t),z(e),null};var l=i.prototype;return l.scrollTo=function(e){var t=e.scrollLeft,r=e.scrollTop;void 0!==t&&(t=Math.max(0,t)),void 0!==r&&(r=Math.max(0,r)),this.setState(function(e){return void 0===t&&(t=e.scrollLeft),void 0===r&&(r=e.scrollTop),e.scrollLeft===t&&e.scrollTop===r?null:{horizontalScrollDirection:e.scrollLeft<t?"forward":"backward",scrollLeft:t,scrollTop:r,scrollUpdateWasRequested:!0,verticalScrollDirection:e.scrollTop<r?"forward":"backward"}},this._resetIsScrollingDebounced)},l.scrollToItem=function(e){var t=e.align,r=void 0===t?"auto":t,o=e.columnIndex,n=e.rowIndex,i=this.props,a=i.columnCount,l=i.height,s=i.rowCount,c=i.width,d=this.state,f=d.scrollLeft,h=d.scrollTop,p=function(e){if(void 0===e&&(e=!1),-1===u||e){var t=document.createElement("div"),r=t.style;r.width="50px",r.height="50px",r.overflow="scroll",document.body.appendChild(t),u=t.offsetWidth-t.clientWidth,document.body.removeChild(t)}return u}();void 0!==o&&(o=Math.max(0,Math.min(o,a-1))),void 0!==n&&(n=Math.max(0,Math.min(n,s-1)));var m=w(this.props,this._instanceProps),v=I(this.props,this._instanceProps)>c?p:0,g=m>l?p:0;this.scrollTo({scrollLeft:void 0!==o?M(this.props,o,r,f,this._instanceProps,g):f,scrollTop:void 0!==n?y(this.props,n,r,h,this._instanceProps,v):h})},l.componentDidMount=function(){var e=this.props,t=e.initialScrollLeft,r=e.initialScrollTop;if(null!=this._outerRef){var o=this._outerRef;"number"==typeof t&&(o.scrollLeft=t),"number"==typeof r&&(o.scrollTop=r)}this._callPropsCallbacks()},l.componentDidUpdate=function(){var e=this.props.direction,t=this.state,r=t.scrollLeft,o=t.scrollTop;if(t.scrollUpdateWasRequested&&null!=this._outerRef){var n=this._outerRef;if("rtl"===e)switch(f()){case"negative":n.scrollLeft=-r;break;case"positive-ascending":n.scrollLeft=r;break;default:var i=n.clientWidth,a=n.scrollWidth;n.scrollLeft=a-i-r}else n.scrollLeft=Math.max(0,r);n.scrollTop=Math.max(0,o)}this._callPropsCallbacks()},l.componentWillUnmount=function(){null!==this._resetIsScrollingTimeoutId&&s(this._resetIsScrollingTimeoutId)},l.render=function(){var e=this.props,o=e.children,n=e.className,i=e.columnCount,a=e.direction,l=e.height,s=e.innerRef,c=e.innerElementType,u=e.innerTagName,d=e.itemData,f=e.itemKey,h=void 0===f?p:f,m=e.outerElementType,v=e.outerTagName,g=e.rowCount,S=e.style,M=e.useIsScrolling,y=e.width,x=this.state.isScrolling,C=this._getHorizontalRangeToRender(),_=C[0],b=C[1],R=this._getVerticalRangeToRender(),T=R[0],z=R[1],O=[];if(i>0&&g)for(var P=T;P<=z;P++)for(var W=_;W<=b;W++)O.push(t.createElement(o,{columnIndex:W,data:d,isScrolling:M?x:void 0,key:h({columnIndex:W,data:d,rowIndex:P}),rowIndex:P,style:this._getItemStyle(P,W)}));var E=w(this.props,this._instanceProps),A=I(this.props,this._instanceProps);return t.createElement(m||v||"div",{className:n,onScroll:this._onScroll,ref:this._outerRefSetter,style:r({position:"relative",height:l,width:y,overflow:"auto",WebkitOverflowScrolling:"touch",willChange:"transform",direction:a},S)},t.createElement(c||u||"div",{children:O,ref:s,style:{height:E,pointerEvents:x?"none":void 0,width:A}}))},l._callPropsCallbacks=function(){var e=this.props,t=e.columnCount,r=e.onItemsRendered,o=e.onScroll,n=e.rowCount;if("function"==typeof r&&t>0&&n>0){var i=this._getHorizontalRangeToRender(),a=i[0],l=i[1],s=i[2],c=i[3],u=this._getVerticalRangeToRender(),d=u[0],f=u[1],h=u[2],p=u[3];this._callOnItemsRendered(a,l,d,f,s,c,h,p)}if("function"==typeof o){var m=this.state,v=m.horizontalScrollDirection,g=m.scrollLeft,w=m.scrollTop,S=m.scrollUpdateWasRequested,I=m.verticalScrollDirection;this._callOnScroll(g,w,v,I,S)}},l._getHorizontalRangeToRender=function(){var e=this.props,t=e.columnCount,r=e.overscanColumnCount,o=e.overscanColumnsCount,n=e.overscanCount,i=e.rowCount,a=this.state,l=a.horizontalScrollDirection,s=a.isScrolling,c=a.scrollLeft,u=r||o||n||1;if(0===t||0===i)return[0,0,0,0];var d=m(this.props,c,this._instanceProps),f=v(this.props,d,c,this._instanceProps),h=s&&"backward"!==l?1:Math.max(1,u),p=s&&"forward"!==l?1:Math.max(1,u);return[Math.max(0,d-h),Math.max(0,Math.min(t-1,f+p)),d,f]},l._getVerticalRangeToRender=function(){var e=this.props,t=e.columnCount,r=e.overscanCount,o=e.overscanRowCount,n=e.overscanRowsCount,i=e.rowCount,a=this.state,l=a.isScrolling,s=a.verticalScrollDirection,c=a.scrollTop,u=o||n||r||1;if(0===t||0===i)return[0,0,0,0];var d=_(this.props,c,this._instanceProps),f=b(this.props,d,c,this._instanceProps),h=l&&"backward"!==s?1:Math.max(1,u),p=l&&"forward"!==s?1:Math.max(1,u);return[Math.max(0,d-h),Math.max(0,Math.min(i-1,f+p)),d,f]},i}(t.PureComponent),i.defaultProps={direction:"ltr",itemData:void 0,useIsScrolling:!1},l}"undefined"!=typeof window&&void 0!==window.WeakSet&&(m=new WeakSet,v=new WeakSet,g=new WeakSet);var S=function(e,t){var r=e.children,o=e.direction,n=e.height,i=e.innerTagName,a=e.outerTagName,l=e.overscanColumnsCount,s=e.overscanCount,c=e.overscanRowsCount,u=e.width,d=t.instance;if("number"==typeof s&&m&&!m.has(d)&&(m.add(d),console.warn("The overscanCount prop has been deprecated. Please use the overscanColumnCount and overscanRowCount props instead.")),"number"!=typeof l&&"number"!=typeof c||v&&!v.has(d)&&(v.add(d),console.warn("The overscanColumnsCount and overscanRowsCount props have been deprecated. Please use the overscanColumnCount and overscanRowCount props instead.")),null==i&&null==a||g&&!g.has(d)&&(g.add(d),console.warn("The innerTagName and outerTagName props have been deprecated. Please use the innerElementType and outerElementType props instead.")),null==r)throw Error('An invalid "children" prop has been specified. Value should be a React component. "'+(null===r?"null":typeof r)+'" was specified.');switch(o){case"ltr":case"rtl":break;default:throw Error('An invalid "direction" prop has been specified. Value should be either "ltr" or "rtl". "'+o+'" was specified.')}if("number"!=typeof u)throw Error('An invalid "width" prop has been specified. Grids must specify a number for width. "'+(null===u?"null":typeof u)+'" was specified.');if("number"!=typeof n)throw Error('An invalid "height" prop has been specified. Grids must specify a number for height. "'+(null===n?"null":typeof n)+'" was specified.')},I=function(e,t){var r=e.rowCount,o=t.rowMetadataMap,n=t.estimatedRowHeight,i=t.lastMeasuredRowIndex,a=0;if(i>=r&&(i=r-1),i>=0){var l=o[i];a=l.offset+l.size}return a+(r-i-1)*n},M=function(e,t){var r=e.columnCount,o=t.columnMetadataMap,n=t.estimatedColumnWidth,i=t.lastMeasuredColumnIndex,a=0;if(i>=r&&(i=r-1),i>=0){var l=o[i];a=l.offset+l.size}return a+(r-i-1)*n},y=function(e,t,r,o){var n,i,a;if("column"===e?(n=o.columnMetadataMap,i=t.columnWidth,a=o.lastMeasuredColumnIndex):(n=o.rowMetadataMap,i=t.rowHeight,a=o.lastMeasuredRowIndex),r>a){var l=0;if(a>=0){var s=n[a];l=s.offset+s.size}for(var c=a+1;c<=r;c++){var u=i(c);n[c]={offset:l,size:u},l+=u}"column"===e?o.lastMeasuredColumnIndex=r:o.lastMeasuredRowIndex=r}return n[r]},x=function(e,t,r,o){var n,i;return"column"===e?(n=r.columnMetadataMap,i=r.lastMeasuredColumnIndex):(n=r.rowMetadataMap,i=r.lastMeasuredRowIndex),(i>0?n[i].offset:0)>=o?C(e,t,r,i,0,o):_(e,t,r,Math.max(0,i),o)},C=function(e,t,r,o,n,i){for(;n<=o;){var a=n+Math.floor((o-n)/2),l=y(e,t,a,r).offset;if(l===i)return a;l<i?n=a+1:l>i&&(o=a-1)}return n>0?n-1:0},_=function(e,t,r,o,n){for(var i="column"===e?t.columnCount:t.rowCount,a=1;o<i&&y(e,t,o,r).offset<n;)o+=a,a*=2;return C(e,t,r,Math.min(o,i-1),Math.floor(o/2),n)},b=function(e,t,r,o,n,i,a){var l="column"===e?t.width:t.height,s=y(e,t,r,i),c="column"===e?M(t,i):I(t,i),u=Math.max(0,Math.min(c-l,s.offset)),d=Math.max(0,s.offset-l+a+s.size);switch("smart"===o&&(o=n>=d-l&&n<=u+l?"auto":"center"),o){case"start":return u;case"end":return d;case"center":return Math.round(d+(u-d)/2);case"auto":default:return n>=d&&n<=u?n:d>u?d:n<d?d:u}},R=w({getColumnOffset:function(e,t,r){return y("column",e,t,r).offset},getColumnStartIndexForOffset:function(e,t,r){return x("column",e,r,t)},getColumnStopIndexForStartIndex:function(e,t,r,o){for(var n=e.columnCount,i=e.width,a=y("column",e,t,o),l=r+i,s=a.offset+a.size,c=t;c<n-1&&s<l;)s+=y("column",e,++c,o).size;return c},getColumnWidth:function(e,t,r){return r.columnMetadataMap[t].size},getEstimatedTotalHeight:I,getEstimatedTotalWidth:M,getOffsetForColumnAndAlignment:function(e,t,r,o,n,i){return b("column",e,t,r,o,n,i)},getOffsetForRowAndAlignment:function(e,t,r,o,n,i){return b("row",e,t,r,o,n,i)},getRowOffset:function(e,t,r){return y("row",e,t,r).offset},getRowHeight:function(e,t,r){return r.rowMetadataMap[t].size},getRowStartIndexForOffset:function(e,t,r){return x("row",e,r,t)},getRowStopIndexForStartIndex:function(e,t,r,o){for(var n=e.rowCount,i=e.height,a=y("row",e,t,o),l=r+i,s=a.offset+a.size,c=t;c<n-1&&s<l;)s+=y("row",e,++c,o).size;return c},initInstanceProps:function(e,t){var r=e,o={columnMetadataMap:{},estimatedColumnWidth:r.estimatedColumnWidth||50,estimatedRowHeight:r.estimatedRowHeight||50,lastMeasuredColumnIndex:-1,lastMeasuredRowIndex:-1,rowMetadataMap:{}};return t.resetAfterColumnIndex=function(e,r){void 0===r&&(r=!0),t.resetAfterIndices({columnIndex:e,shouldForceUpdate:r})},t.resetAfterRowIndex=function(e,r){void 0===r&&(r=!0),t.resetAfterIndices({rowIndex:e,shouldForceUpdate:r})},t.resetAfterIndices=function(e){var r=e.columnIndex,n=e.rowIndex,i=e.shouldForceUpdate,a=void 0===i||i;"number"==typeof r&&(o.lastMeasuredColumnIndex=Math.min(o.lastMeasuredColumnIndex,r-1)),"number"==typeof n&&(o.lastMeasuredRowIndex=Math.min(o.lastMeasuredRowIndex,n-1)),t._getItemStyleCache(-1),a&&t.forceUpdate()},o},shouldResetStyleCacheOnItemSizeChange:!1,validateProps:function(e){var t=e.columnWidth,r=e.rowHeight;if("function"!=typeof t)throw Error('An invalid "columnWidth" prop has been specified. Value should be a function. "'+(null===t?"null":typeof t)+'" was specified.');if("function"!=typeof r)throw Error('An invalid "rowHeight" prop has been specified. Value should be a function. "'+(null===r?"null":typeof r)+'" was specified.')}}),T=150,z=function(e,t){return e},O=null,P=null;function W(e){var i,l,u=e.getItemOffset,d=e.getEstimatedTotalSize,h=e.getItemSize,p=e.getOffsetForIndexAndAlignment,m=e.getStartIndexForOffset,v=e.getStopIndexForStartIndex,g=e.initInstanceProps,w=e.shouldResetStyleCacheOnItemSizeChange,S=e.validateProps;return l=i=function(e){function i(t){var r;return(r=e.call(this,t)||this)._instanceProps=g(r.props,n(n(r))),r._outerRef=void 0,r._resetIsScrollingTimeoutId=null,r.state={instance:n(n(r)),isScrolling:!1,scrollDirection:"forward",scrollOffset:"number"==typeof r.props.initialScrollOffset?r.props.initialScrollOffset:0,scrollUpdateWasRequested:!1},r._callOnItemsRendered=void 0,r._callOnItemsRendered=a(function(e,t,o,n){return r.props.onItemsRendered({overscanStartIndex:e,overscanStopIndex:t,visibleStartIndex:o,visibleStopIndex:n})}),r._callOnScroll=void 0,r._callOnScroll=a(function(e,t,o){return r.props.onScroll({scrollDirection:e,scrollOffset:t,scrollUpdateWasRequested:o})}),r._getItemStyle=void 0,r._getItemStyle=function(e){var t,o=r.props,n=o.direction,i=o.itemSize,a=o.layout,l=r._getItemStyleCache(w&&i,w&&a,w&&n);if(l.hasOwnProperty(e))t=l[e];else{var s=u(r.props,e,r._instanceProps),c=h(r.props,e,r._instanceProps),d="horizontal"===n||"horizontal"===a,f="rtl"===n,p=d?s:0;l[e]=t={position:"absolute",left:f?void 0:p,right:f?p:void 0,top:d?0:s,height:d?"100%":c,width:d?c:"100%"}}return t},r._getItemStyleCache=void 0,r._getItemStyleCache=a(function(e,t,r){return{}}),r._onScrollHorizontal=function(e){var t=e.currentTarget,o=t.clientWidth,n=t.scrollLeft,i=t.scrollWidth;r.setState(function(e){if(e.scrollOffset===n)return null;var t=r.props.direction,a=n;if("rtl"===t)switch(f()){case"negative":a=-n;break;case"positive-descending":a=i-o-n}return a=Math.max(0,Math.min(a,i-o)),{isScrolling:!0,scrollDirection:e.scrollOffset<n?"forward":"backward",scrollOffset:a,scrollUpdateWasRequested:!1}},r._resetIsScrollingDebounced)},r._onScrollVertical=function(e){var t=e.currentTarget,o=t.clientHeight,n=t.scrollHeight,i=t.scrollTop;r.setState(function(e){if(e.scrollOffset===i)return null;var t=Math.max(0,Math.min(i,n-o));return{isScrolling:!0,scrollDirection:e.scrollOffset<t?"forward":"backward",scrollOffset:t,scrollUpdateWasRequested:!1}},r._resetIsScrollingDebounced)},r._outerRefSetter=function(e){var t=r.props.outerRef;r._outerRef=e,"function"==typeof t?t(e):null!=t&&"object"==typeof t&&t.hasOwnProperty("current")&&(t.current=e)},r._resetIsScrollingDebounced=function(){null!==r._resetIsScrollingTimeoutId&&s(r._resetIsScrollingTimeoutId),r._resetIsScrollingTimeoutId=c(r._resetIsScrolling,T)},r._resetIsScrolling=function(){r._resetIsScrollingTimeoutId=null,r.setState({isScrolling:!1},function(){r._getItemStyleCache(-1,null)})},r}o(i,e),i.getDerivedStateFromProps=function(e,t){return E(e,t),S(e),null};var l=i.prototype;return l.scrollTo=function(e){e=Math.max(0,e),this.setState(function(t){return t.scrollOffset===e?null:{scrollDirection:t.scrollOffset<e?"forward":"backward",scrollOffset:e,scrollUpdateWasRequested:!0}},this._resetIsScrollingDebounced)},l.scrollToItem=function(e,t){void 0===t&&(t="auto");var r=this.props.itemCount,o=this.state.scrollOffset;e=Math.max(0,Math.min(e,r-1)),this.scrollTo(p(this.props,e,t,o,this._instanceProps))},l.componentDidMount=function(){var e=this.props,t=e.direction,r=e.initialScrollOffset,o=e.layout;if("number"==typeof r&&null!=this._outerRef){var n=this._outerRef;"horizontal"===t||"horizontal"===o?n.scrollLeft=r:n.scrollTop=r}this._callPropsCallbacks()},l.componentDidUpdate=function(){var e=this.props,t=e.direction,r=e.layout,o=this.state,n=o.scrollOffset;if(o.scrollUpdateWasRequested&&null!=this._outerRef){var i=this._outerRef;if("horizontal"===t||"horizontal"===r)if("rtl"===t)switch(f()){case"negative":i.scrollLeft=-n;break;case"positive-ascending":i.scrollLeft=n;break;default:var a=i.clientWidth,l=i.scrollWidth;i.scrollLeft=l-a-n}else i.scrollLeft=n;else i.scrollTop=n}this._callPropsCallbacks()},l.componentWillUnmount=function(){null!==this._resetIsScrollingTimeoutId&&s(this._resetIsScrollingTimeoutId)},l.render=function(){var e=this.props,o=e.children,n=e.className,i=e.direction,a=e.height,l=e.innerRef,s=e.innerElementType,c=e.innerTagName,u=e.itemCount,f=e.itemData,h=e.itemKey,p=void 0===h?z:h,m=e.layout,v=e.outerElementType,g=e.outerTagName,w=e.style,S=e.useIsScrolling,I=e.width,M=this.state.isScrolling,y="horizontal"===i||"horizontal"===m,x=y?this._onScrollHorizontal:this._onScrollVertical,C=this._getRangeToRender(),_=C[0],b=C[1],R=[];if(u>0)for(var T=_;T<=b;T++)R.push(t.createElement(o,{data:f,key:p(T,f),index:T,isScrolling:S?M:void 0,style:this._getItemStyle(T)}));var O=d(this.props,this._instanceProps);return t.createElement(v||g||"div",{className:n,onScroll:x,ref:this._outerRefSetter,style:r({position:"relative",height:a,width:I,overflow:"auto",WebkitOverflowScrolling:"touch",willChange:"transform",direction:i},w)},t.createElement(s||c||"div",{children:R,ref:l,style:{height:y?"100%":O,pointerEvents:M?"none":void 0,width:y?O:"100%"}}))},l._callPropsCallbacks=function(){if("function"==typeof this.props.onItemsRendered&&this.props.itemCount>0){var e=this._getRangeToRender(),t=e[0],r=e[1],o=e[2],n=e[3];this._callOnItemsRendered(t,r,o,n)}if("function"==typeof this.props.onScroll){var i=this.state,a=i.scrollDirection,l=i.scrollOffset,s=i.scrollUpdateWasRequested;this._callOnScroll(a,l,s)}},l._getRangeToRender=function(){var e=this.props,t=e.itemCount,r=e.overscanCount,o=this.state,n=o.isScrolling,i=o.scrollDirection,a=o.scrollOffset;if(0===t)return[0,0,0,0];var l=m(this.props,a,this._instanceProps),s=v(this.props,l,a,this._instanceProps),c=n&&"backward"!==i?1:Math.max(1,r),u=n&&"forward"!==i?1:Math.max(1,r);return[Math.max(0,l-c),Math.max(0,Math.min(t-1,s+u)),l,s]},i}(t.PureComponent),i.defaultProps={direction:"ltr",itemData:void 0,layout:"vertical",overscanCount:2,useIsScrolling:!1},l}"undefined"!=typeof window&&void 0!==window.WeakSet&&(O=new WeakSet,P=new WeakSet);var E=function(e,t){var r=e.children,o=e.direction,n=e.height,i=e.layout,a=e.innerTagName,l=e.outerTagName,s=e.width,c=t.instance;null==a&&null==l||P&&!P.has(c)&&(P.add(c),console.warn("The innerTagName and outerTagName props have been deprecated. Please use the innerElementType and outerElementType props instead."));var u="horizontal"===o||"horizontal"===i;switch(o){case"horizontal":case"vertical":O&&!O.has(c)&&(O.add(c),console.warn('The direction prop should be either "ltr" (default) or "rtl". Please use the layout prop to specify "vertical" (default) or "horizontal" orientation.'));break;case"ltr":case"rtl":break;default:throw Error('An invalid "direction" prop has been specified. Value should be either "ltr" or "rtl". "'+o+'" was specified.')}switch(i){case"horizontal":case"vertical":break;default:throw Error('An invalid "layout" prop has been specified. Value should be either "horizontal" or "vertical". "'+i+'" was specified.')}if(null==r)throw Error('An invalid "children" prop has been specified. Value should be a React component. "'+(null===r?"null":typeof r)+'" was specified.');if(u&&"number"!=typeof s)throw Error('An invalid "width" prop has been specified. Horizontal lists must specify a number for width. "'+(null===s?"null":typeof s)+'" was specified.');if(!u&&"number"!=typeof n)throw Error('An invalid "height" prop has been specified. Vertical lists must specify a number for height. "'+(null===n?"null":typeof n)+'" was specified.')},A=function(e,t,r){var o=e.itemSize,n=r.itemMetadataMap,i=r.lastMeasuredIndex;if(t>i){var a=0;if(i>=0){var l=n[i];a=l.offset+l.size}for(var s=i+1;s<=t;s++){var c=o(s);n[s]={offset:a,size:c},a+=c}r.lastMeasuredIndex=t}return n[t]},k=function(e,t,r,o,n){for(;o<=r;){var i=o+Math.floor((r-o)/2),a=A(e,i,t).offset;if(a===n)return i;a<n?o=i+1:a>n&&(r=i-1)}return o>0?o-1:0},D=function(e,t,r,o){for(var n=e.itemCount,i=1;r<n&&A(e,r,t).offset<o;)r+=i,i*=2;return k(e,t,Math.min(r,n-1),Math.floor(r/2),o)},F=function(e,t){var r=e.itemCount,o=t.itemMetadataMap,n=t.estimatedItemSize,i=t.lastMeasuredIndex,a=0;if(i>=r&&(i=r-1),i>=0){var l=o[i];a=l.offset+l.size}return a+(r-i-1)*n},L=W({getItemOffset:function(e,t,r){return A(e,t,r).offset},getItemSize:function(e,t,r){return r.itemMetadataMap[t].size},getEstimatedTotalSize:F,getOffsetForIndexAndAlignment:function(e,t,r,o,n){var i=e.direction,a=e.height,l=e.layout,s=e.width,c="horizontal"===i||"horizontal"===l?s:a,u=A(e,t,n),d=F(e,n),f=Math.max(0,Math.min(d-c,u.offset)),h=Math.max(0,u.offset-c+u.size);switch("smart"===r&&(r=o>=h-c&&o<=f+c?"auto":"center"),r){case"start":return f;case"end":return h;case"center":return Math.round(h+(f-h)/2);case"auto":default:return o>=h&&o<=f?o:o<h?h:f}},getStartIndexForOffset:function(e,t,r){return function(e,t,r){var o=t.itemMetadataMap,n=t.lastMeasuredIndex;return(n>0?o[n].offset:0)>=r?k(e,t,n,0,r):D(e,t,Math.max(0,n),r)}(e,r,t)},getStopIndexForStartIndex:function(e,t,r,o){for(var n=e.direction,i=e.height,a=e.itemCount,l=e.layout,s=e.width,c="horizontal"===n||"horizontal"===l?s:i,u=A(e,t,o),d=r+c,f=u.offset+u.size,h=t;h<a-1&&f<d;)f+=A(e,++h,o).size;return h},initInstanceProps:function(e,t){var r={itemMetadataMap:{},estimatedItemSize:e.estimatedItemSize||50,lastMeasuredIndex:-1};return t.resetAfterIndex=function(e,o){void 0===o&&(o=!0),r.lastMeasuredIndex=Math.min(r.lastMeasuredIndex,e-1),t._getItemStyleCache(-1),o&&t.forceUpdate()},r},shouldResetStyleCacheOnItemSizeChange:!1,validateProps:function(e){var t=e.itemSize;if("function"!=typeof t)throw Error('An invalid "itemSize" prop has been specified. Value should be a function. "'+(null===t?"null":typeof t)+'" was specified.')}}),H=w({getColumnOffset:function(e,t){return t*e.columnWidth},getColumnWidth:function(e,t){return e.columnWidth},getRowOffset:function(e,t){return t*e.rowHeight},getRowHeight:function(e,t){return e.rowHeight},getEstimatedTotalHeight:function(e){var t=e.rowCount;return e.rowHeight*t},getEstimatedTotalWidth:function(e){var t=e.columnCount;return e.columnWidth*t},getOffsetForColumnAndAlignment:function(e,t,r,o,n,i){var a=e.columnCount,l=e.columnWidth,s=e.width,c=Math.max(0,a*l-s),u=Math.min(c,t*l),d=Math.max(0,t*l-s+i+l);switch("smart"===r&&(r=o>=d-s&&o<=u+s?"auto":"center"),r){case"start":return u;case"end":return d;case"center":var f=Math.round(d+(u-d)/2);return f<Math.ceil(s/2)?0:f>c+Math.floor(s/2)?c:f;case"auto":default:return o>=d&&o<=u?o:d>u?d:o<d?d:u}},getOffsetForRowAndAlignment:function(e,t,r,o,n,i){var a=e.rowHeight,l=e.height,s=e.rowCount,c=Math.max(0,s*a-l),u=Math.min(c,t*a),d=Math.max(0,t*a-l+i+a);switch("smart"===r&&(r=o>=d-l&&o<=u+l?"auto":"center"),r){case"start":return u;case"end":return d;case"center":var f=Math.round(d+(u-d)/2);return f<Math.ceil(l/2)?0:f>c+Math.floor(l/2)?c:f;case"auto":default:return o>=d&&o<=u?o:d>u?d:o<d?d:u}},getColumnStartIndexForOffset:function(e,t){var r=e.columnWidth,o=e.columnCount;return Math.max(0,Math.min(o-1,Math.floor(t/r)))},getColumnStopIndexForStartIndex:function(e,t,r){var o=e.columnWidth,n=e.columnCount,i=e.width,a=t*o,l=Math.ceil((i+r-a)/o);return Math.max(0,Math.min(n-1,t+l-1))},getRowStartIndexForOffset:function(e,t){var r=e.rowHeight,o=e.rowCount;return Math.max(0,Math.min(o-1,Math.floor(t/r)))},getRowStopIndexForStartIndex:function(e,t,r){var o=e.rowHeight,n=e.rowCount,i=e.height,a=t*o,l=Math.ceil((i+r-a)/o);return Math.max(0,Math.min(n-1,t+l-1))},initInstanceProps:function(e){},shouldResetStyleCacheOnItemSizeChange:!0,validateProps:function(e){var t=e.columnWidth,r=e.rowHeight;if("number"!=typeof t)throw Error('An invalid "columnWidth" prop has been specified. Value should be a number. "'+(null===t?"null":typeof t)+'" was specified.');if("number"!=typeof r)throw Error('An invalid "rowHeight" prop has been specified. Value should be a number. "'+(null===r?"null":typeof r)+'" was specified.')}}),U=W({getItemOffset:function(e,t){return t*e.itemSize},getItemSize:function(e,t){return e.itemSize},getEstimatedTotalSize:function(e){var t=e.itemCount;return e.itemSize*t},getOffsetForIndexAndAlignment:function(e,t,r,o){var n=e.direction,i=e.height,a=e.itemCount,l=e.itemSize,s=e.layout,c=e.width,u="horizontal"===n||"horizontal"===s?c:i,d=Math.max(0,a*l-u),f=Math.min(d,t*l),h=Math.max(0,t*l-u+l);switch("smart"===r&&(r=o>=h-u&&o<=f+u?"auto":"center"),r){case"start":return f;case"end":return h;case"center":var p=Math.round(h+(f-h)/2);return p<Math.ceil(u/2)?0:p>d+Math.floor(u/2)?d:p;case"auto":default:return o>=h&&o<=f?o:o<h?h:f}},getStartIndexForOffset:function(e,t){var r=e.itemCount,o=e.itemSize;return Math.max(0,Math.min(r-1,Math.floor(t/o)))},getStopIndexForStartIndex:function(e,t,r){var o=e.direction,n=e.height,i=e.itemCount,a=e.itemSize,l=e.layout,s=e.width,c=t*a,u="horizontal"===o||"horizontal"===l?s:n,d=Math.ceil((u+r-c)/a);return Math.max(0,Math.min(i-1,t+d-1))},initInstanceProps:function(e){},shouldResetStyleCacheOnItemSizeChange:!0,validateProps:function(e){var t=e.itemSize;if("number"!=typeof t)throw Error('An invalid "itemSize" prop has been specified. Value should be a number. "'+(null===t?"null":typeof t)+'" was specified.')}});function V(e,t){if(null==e)return{};var r,o,n={},i=Object.keys(e);for(o=0;o<i.length;o++)r=i[o],t.indexOf(r)>=0||(n[r]=e[r]);return n}function q(e,t){for(var r in e)if(!(r in t))return!0;for(var o in t)if(e[o]!==t[o])return!0;return!1}function N(e,t){var r=e.style,o=V(e,["style"]),n=t.style,i=V(t,["style"]);return!q(r,n)&&!q(o,i)}e.VariableSizeGrid=R,e.VariableSizeList=L,e.FixedSizeGrid=H,e.FixedSizeList=U,e.areEqual=N,e.shouldComponentUpdate=function(e,t){return!N(this.props,e)||q(this.state,t)},Object.defineProperty(e,"__esModule",{value:!0})});
+!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("react")):"function"==typeof define&&define.amd?define(["exports","react"],t):t((e=e||self).ReactWindow={},e.React)}(this,(function(e,t){"use strict";function r(){return(r=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var o in r)Object.prototype.hasOwnProperty.call(r,o)&&(e[o]=r[o])}return e}).apply(this,arguments)}function o(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function n(e,t){return(n=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function i(e,t){e.prototype=Object.create(t.prototype),e.prototype.constructor=e,n(e,t)}var a=Number.isNaN||function(e){return"number"==typeof e&&e!=e};function l(e,t){if(e.length!==t.length)return!1;for(var r=0;r<e.length;r++)if(o=e[r],n=t[r],!(o===n||a(o)&&a(n)))return!1;var o,n;return!0}function s(e,t){var r;void 0===t&&(t=l);var o,n=[],i=!1;return function(){for(var a=[],l=0;l<arguments.length;l++)a[l]=arguments[l];return i&&r===this&&t(a,n)||(o=e.apply(this,a),i=!0,r=this,n=a),o}}var c="object"==typeof performance&&"function"==typeof performance.now?function(){return performance.now()}:function(){return Date.now()};function u(e){cancelAnimationFrame(e.id)}function d(e,t){var r=c();var o={id:requestAnimationFrame((function n(){c()-r>=t?e.call(null):o.id=requestAnimationFrame(n)}))};return o}var f=-1;function h(e){if(void 0===e&&(e=!1),-1===f||e){var t=document.createElement("div"),r=t.style;r.width="50px",r.height="50px",r.overflow="scroll",document.body.appendChild(t),f=t.offsetWidth-t.clientWidth,document.body.removeChild(t)}return f}var p=null;function m(e){if(void 0===e&&(e=!1),null===p||e){var t=document.createElement("div"),r=t.style;r.width="50px",r.height="50px",r.overflow="scroll",r.direction="rtl";var o=document.createElement("div"),n=o.style;return n.width="100px",n.height="100px",t.appendChild(o),document.body.appendChild(t),t.scrollLeft>0?p="positive-descending":(t.scrollLeft=1,p=0===t.scrollLeft?"negative":"positive-ascending"),document.body.removeChild(t),p}return p}var v=function(e){var t=e.columnIndex;e.data;return e.rowIndex+":"+t},g=null,w=null,S=null;function I(e){var n,a=e.getColumnOffset,l=e.getColumnStartIndexForOffset,c=e.getColumnStopIndexForStartIndex,f=e.getColumnWidth,p=e.getEstimatedTotalHeight,g=e.getEstimatedTotalWidth,w=e.getOffsetForColumnAndAlignment,S=e.getOffsetForRowAndAlignment,I=e.getRowHeight,y=e.getRowOffset,x=e.getRowStartIndexForOffset,C=e.getRowStopIndexForStartIndex,b=e.initInstanceProps,_=e.shouldResetStyleCacheOnItemSizeChange,R=e.validateProps;return(n=function(e){function n(t){var r;return(r=e.call(this,t)||this)._instanceProps=b(r.props,o(r)),r._resetIsScrollingTimeoutId=null,r._outerRef=void 0,r.state={instance:o(r),isScrolling:!1,horizontalScrollDirection:"forward",scrollLeft:"number"==typeof r.props.initialScrollLeft?r.props.initialScrollLeft:0,scrollTop:"number"==typeof r.props.initialScrollTop?r.props.initialScrollTop:0,scrollUpdateWasRequested:!1,verticalScrollDirection:"forward"},r._callOnItemsRendered=void 0,r._callOnItemsRendered=s((function(e,t,o,n,i,a,l,s){return r.props.onItemsRendered({overscanColumnStartIndex:e,overscanColumnStopIndex:t,overscanRowStartIndex:o,overscanRowStopIndex:n,visibleColumnStartIndex:i,visibleColumnStopIndex:a,visibleRowStartIndex:l,visibleRowStopIndex:s})})),r._callOnScroll=void 0,r._callOnScroll=s((function(e,t,o,n,i){return r.props.onScroll({horizontalScrollDirection:o,scrollLeft:e,scrollTop:t,verticalScrollDirection:n,scrollUpdateWasRequested:i})})),r._getItemStyle=void 0,r._getItemStyle=function(e,t){var o,n=r.props,i=n.columnWidth,l=n.direction,s=n.rowHeight,c=r._getItemStyleCache(_&&i,_&&l,_&&s),u=e+":"+t;if(c.hasOwnProperty(u))o=c[u];else{var d=a(r.props,t,r._instanceProps),h="rtl"===l;c[u]=o={position:"absolute",left:h?void 0:d,right:h?d:void 0,top:y(r.props,e,r._instanceProps),height:I(r.props,e,r._instanceProps),width:f(r.props,t,r._instanceProps)}}return o},r._getItemStyleCache=void 0,r._getItemStyleCache=s((function(e,t,r){return{}})),r._onScroll=function(e){var t=e.currentTarget,o=t.clientHeight,n=t.clientWidth,i=t.scrollLeft,a=t.scrollTop,l=t.scrollHeight,s=t.scrollWidth;r.setState((function(e){if(e.scrollLeft===i&&e.scrollTop===a)return null;var t=r.props.direction,c=i;if("rtl"===t)switch(m()){case"negative":c=-i;break;case"positive-descending":c=s-n-i}c=Math.max(0,Math.min(c,s-n));var u=Math.max(0,Math.min(a,l-o));return{isScrolling:!0,horizontalScrollDirection:e.scrollLeft<i?"forward":"backward",scrollLeft:c,scrollTop:u,verticalScrollDirection:e.scrollTop<a?"forward":"backward",scrollUpdateWasRequested:!1}}),r._resetIsScrollingDebounced)},r._outerRefSetter=function(e){var t=r.props.outerRef;r._outerRef=e,"function"==typeof t?t(e):null!=t&&"object"==typeof t&&t.hasOwnProperty("current")&&(t.current=e)},r._resetIsScrollingDebounced=function(){null!==r._resetIsScrollingTimeoutId&&u(r._resetIsScrollingTimeoutId),r._resetIsScrollingTimeoutId=d(r._resetIsScrolling,150)},r._resetIsScrolling=function(){r._resetIsScrollingTimeoutId=null,r.setState({isScrolling:!1},(function(){r._getItemStyleCache(-1)}))},r}i(n,e),n.getDerivedStateFromProps=function(e,t){return M(e,t),R(e),null};var T=n.prototype;return T.scrollTo=function(e){var t=e.scrollLeft,r=e.scrollTop;void 0!==t&&(t=Math.max(0,t)),void 0!==r&&(r=Math.max(0,r)),this.setState((function(e){return void 0===t&&(t=e.scrollLeft),void 0===r&&(r=e.scrollTop),e.scrollLeft===t&&e.scrollTop===r?null:{horizontalScrollDirection:e.scrollLeft<t?"forward":"backward",scrollLeft:t,scrollTop:r,scrollUpdateWasRequested:!0,verticalScrollDirection:e.scrollTop<r?"forward":"backward"}}),this._resetIsScrollingDebounced)},T.scrollToItem=function(e){var t=e.align,r=void 0===t?"auto":t,o=e.columnIndex,n=e.rowIndex,i=this.props,a=i.columnCount,l=i.height,s=i.rowCount,c=i.width,u=this.state,d=u.scrollLeft,f=u.scrollTop,m=h();void 0!==o&&(o=Math.max(0,Math.min(o,a-1))),void 0!==n&&(n=Math.max(0,Math.min(n,s-1)));var v=p(this.props,this._instanceProps),I=g(this.props,this._instanceProps)>c?m:0,M=v>l?m:0;this.scrollTo({scrollLeft:void 0!==o?w(this.props,o,r,d,this._instanceProps,M):d,scrollTop:void 0!==n?S(this.props,n,r,f,this._instanceProps,I):f})},T.componentDidMount=function(){var e=this.props,t=e.initialScrollLeft,r=e.initialScrollTop;if(null!=this._outerRef){var o=this._outerRef;"number"==typeof t&&(o.scrollLeft=t),"number"==typeof r&&(o.scrollTop=r)}this._callPropsCallbacks()},T.componentDidUpdate=function(){var e=this.props.direction,t=this.state,r=t.scrollLeft,o=t.scrollTop;if(t.scrollUpdateWasRequested&&null!=this._outerRef){var n=this._outerRef;if("rtl"===e)switch(m()){case"negative":n.scrollLeft=-r;break;case"positive-ascending":n.scrollLeft=r;break;default:var i=n.clientWidth,a=n.scrollWidth;n.scrollLeft=a-i-r}else n.scrollLeft=Math.max(0,r);n.scrollTop=Math.max(0,o)}this._callPropsCallbacks()},T.componentWillUnmount=function(){null!==this._resetIsScrollingTimeoutId&&u(this._resetIsScrollingTimeoutId)},T.render=function(){var e=this.props,o=e.children,n=e.className,i=e.columnCount,a=e.direction,l=e.height,s=e.innerRef,c=e.innerElementType,u=e.innerTagName,d=e.itemData,f=e.itemKey,h=void 0===f?v:f,m=e.outerElementType,w=e.outerTagName,S=e.rowCount,I=e.style,M=e.useIsScrolling,y=e.width,x=e.disableColVirtualized,C=e.disableRowVirtualized,b=this.state.isScrolling,_=this._getHorizontalRangeToRender(),R=_[0],T=_[1],z=this._getVerticalRangeToRender(),O=z[0],P=z[1];x&&(R=0),C&&(O=0);var W=[];if(i>0&&S)for(var E=O;E<=P;E++)for(var A=R;A<=T;A++)W.push(t.createElement(o,{columnIndex:A,data:d,isScrolling:M?b:void 0,key:h({columnIndex:A,data:d,rowIndex:E}),rowIndex:E,style:this._getItemStyle(E,A)}));var k=p(this.props,this._instanceProps),D=g(this.props,this._instanceProps);return t.createElement(m||w||"div",{className:n,onScroll:this._onScroll,ref:this._outerRefSetter,style:r({position:"relative",height:l,width:y,overflow:"auto",WebkitOverflowScrolling:"touch",willChange:"transform",direction:a},I)},t.createElement(c||u||"div",{children:W,ref:s,style:{height:k,pointerEvents:b?"none":void 0,width:D}}))},T._callPropsCallbacks=function(){var e=this.props,t=e.columnCount,r=e.onItemsRendered,o=e.onScroll,n=e.rowCount;if("function"==typeof r&&t>0&&n>0){var i=this._getHorizontalRangeToRender(),a=i[0],l=i[1],s=i[2],c=i[3],u=this._getVerticalRangeToRender(),d=u[0],f=u[1],h=u[2],p=u[3];this._callOnItemsRendered(a,l,d,f,s,c,h,p)}if("function"==typeof o){var m=this.state,v=m.horizontalScrollDirection,g=m.scrollLeft,w=m.scrollTop,S=m.scrollUpdateWasRequested,I=m.verticalScrollDirection;this._callOnScroll(g,w,v,I,S)}},T._getHorizontalRangeToRender=function(){var e=this.props,t=e.columnCount,r=e.overscanColumnCount,o=e.overscanColumnsCount,n=e.overscanCount,i=e.rowCount,a=this.state,s=a.horizontalScrollDirection,u=a.isScrolling,d=a.scrollLeft,f=r||o||n||1;if(0===t||0===i)return[0,0,0,0];var h=l(this.props,d,this._instanceProps),p=c(this.props,h,d,this._instanceProps),m=u&&"backward"!==s?1:Math.max(1,f),v=u&&"forward"!==s?1:Math.max(1,f);return[Math.max(0,h-m),Math.max(0,Math.min(t-1,p+v)),h,p]},T._getVerticalRangeToRender=function(){var e=this.props,t=e.columnCount,r=e.overscanCount,o=e.overscanRowCount,n=e.overscanRowsCount,i=e.rowCount,a=this.state,l=a.isScrolling,s=a.verticalScrollDirection,c=a.scrollTop,u=o||n||r||1;if(0===t||0===i)return[0,0,0,0];var d=x(this.props,c,this._instanceProps),f=C(this.props,d,c,this._instanceProps),h=l&&"backward"!==s?1:Math.max(1,u),p=l&&"forward"!==s?1:Math.max(1,u);return[Math.max(0,d-h),Math.max(0,Math.min(i-1,f+p)),d,f]},n}(t.PureComponent)).defaultProps={direction:"ltr",itemData:void 0,useIsScrolling:!1},n}"undefined"!=typeof window&&void 0!==window.WeakSet&&(g=new WeakSet,w=new WeakSet,S=new WeakSet);var M=function(e,t){var r=e.children,o=e.direction,n=e.height,i=e.innerTagName,a=e.outerTagName,l=e.overscanColumnsCount,s=e.overscanCount,c=e.overscanRowsCount,u=e.width,d=t.instance;if("number"==typeof s&&g&&!g.has(d)&&(g.add(d),console.warn("The overscanCount prop has been deprecated. Please use the overscanColumnCount and overscanRowCount props instead.")),"number"!=typeof l&&"number"!=typeof c||w&&!w.has(d)&&(w.add(d),console.warn("The overscanColumnsCount and overscanRowsCount props have been deprecated. Please use the overscanColumnCount and overscanRowCount props instead.")),null==i&&null==a||S&&!S.has(d)&&(S.add(d),console.warn("The innerTagName and outerTagName props have been deprecated. Please use the innerElementType and outerElementType props instead.")),null==r)throw Error('An invalid "children" prop has been specified. Value should be a React component. "'+(null===r?"null":typeof r)+'" was specified.');switch(o){case"ltr":case"rtl":break;default:throw Error('An invalid "direction" prop has been specified. Value should be either "ltr" or "rtl". "'+o+'" was specified.')}if("number"!=typeof u)throw Error('An invalid "width" prop has been specified. Grids must specify a number for width. "'+(null===u?"null":typeof u)+'" was specified.');if("number"!=typeof n)throw Error('An invalid "height" prop has been specified. Grids must specify a number for height. "'+(null===n?"null":typeof n)+'" was specified.')},y=function(e,t){var r=e.rowCount,o=t.rowMetadataMap,n=t.estimatedRowHeight,i=t.lastMeasuredRowIndex,a=0;if(i>=r&&(i=r-1),i>=0){var l=o[i];a=l.offset+l.size}return a+(r-i-1)*n},x=function(e,t){var r=e.columnCount,o=t.columnMetadataMap,n=t.estimatedColumnWidth,i=t.lastMeasuredColumnIndex,a=0;if(i>=r&&(i=r-1),i>=0){var l=o[i];a=l.offset+l.size}return a+(r-i-1)*n},C=function(e,t,r,o){var n,i,a;if("column"===e?(n=o.columnMetadataMap,i=t.columnWidth,a=o.lastMeasuredColumnIndex):(n=o.rowMetadataMap,i=t.rowHeight,a=o.lastMeasuredRowIndex),r>a){var l=0;if(a>=0){var s=n[a];l=s.offset+s.size}for(var c=a+1;c<=r;c++){var u=i(c);n[c]={offset:l,size:u},l+=u}"column"===e?o.lastMeasuredColumnIndex=r:o.lastMeasuredRowIndex=r}return n[r]},b=function(e,t,r,o){var n,i;return"column"===e?(n=r.columnMetadataMap,i=r.lastMeasuredColumnIndex):(n=r.rowMetadataMap,i=r.lastMeasuredRowIndex),(i>0?n[i].offset:0)>=o?_(e,t,r,i,0,o):R(e,t,r,Math.max(0,i),o)},_=function(e,t,r,o,n,i){for(;n<=o;){var a=n+Math.floor((o-n)/2),l=C(e,t,a,r).offset;if(l===i)return a;l<i?n=a+1:l>i&&(o=a-1)}return n>0?n-1:0},R=function(e,t,r,o,n){for(var i="column"===e?t.columnCount:t.rowCount,a=1;o<i&&C(e,t,o,r).offset<n;)o+=a,a*=2;return _(e,t,r,Math.min(o,i-1),Math.floor(o/2),n)},T=function(e,t,r,o,n,i,a){var l="column"===e?t.width:t.height,s=C(e,t,r,i),c="column"===e?x(t,i):y(t,i),u=Math.max(0,Math.min(c-l,s.offset)),d=Math.max(0,s.offset-l+a+s.size);switch("smart"===o&&(o=n>=d-l&&n<=u+l?"auto":"center"),o){case"start":return u;case"end":return d;case"center":return Math.round(d+(u-d)/2);case"auto":default:return n>=d&&n<=u?n:d>u||n<d?d:u}},z=I({getColumnOffset:function(e,t,r){return C("column",e,t,r).offset},getColumnStartIndexForOffset:function(e,t,r){return b("column",e,r,t)},getColumnStopIndexForStartIndex:function(e,t,r,o){for(var n=e.columnCount,i=e.width,a=C("column",e,t,o),l=r+i,s=a.offset+a.size,c=t;c<n-1&&s<l;)c++,s+=C("column",e,c,o).size;return c},getColumnWidth:function(e,t,r){return r.columnMetadataMap[t].size},getEstimatedTotalHeight:y,getEstimatedTotalWidth:x,getOffsetForColumnAndAlignment:function(e,t,r,o,n,i){return T("column",e,t,r,o,n,i)},getOffsetForRowAndAlignment:function(e,t,r,o,n,i){return T("row",e,t,r,o,n,i)},getRowOffset:function(e,t,r){return C("row",e,t,r).offset},getRowHeight:function(e,t,r){return r.rowMetadataMap[t].size},getRowStartIndexForOffset:function(e,t,r){return b("row",e,r,t)},getRowStopIndexForStartIndex:function(e,t,r,o){for(var n=e.rowCount,i=e.height,a=C("row",e,t,o),l=r+i,s=a.offset+a.size,c=t;c<n-1&&s<l;)c++,s+=C("row",e,c,o).size;return c},initInstanceProps:function(e,t){var r=e,o={columnMetadataMap:{},estimatedColumnWidth:r.estimatedColumnWidth||50,estimatedRowHeight:r.estimatedRowHeight||50,lastMeasuredColumnIndex:-1,lastMeasuredRowIndex:-1,rowMetadataMap:{}};return t.resetAfterColumnIndex=function(e,r){void 0===r&&(r=!0),t.resetAfterIndices({columnIndex:e,shouldForceUpdate:r})},t.resetAfterRowIndex=function(e,r){void 0===r&&(r=!0),t.resetAfterIndices({rowIndex:e,shouldForceUpdate:r})},t.resetAfterIndices=function(e){var r=e.columnIndex,n=e.rowIndex,i=e.shouldForceUpdate,a=void 0===i||i;"number"==typeof r&&(o.lastMeasuredColumnIndex=Math.min(o.lastMeasuredColumnIndex,r-1)),"number"==typeof n&&(o.lastMeasuredRowIndex=Math.min(o.lastMeasuredRowIndex,n-1)),t._getItemStyleCache(-1),a&&t.forceUpdate()},o},shouldResetStyleCacheOnItemSizeChange:!1,validateProps:function(e){var t=e.columnWidth,r=e.rowHeight;if("function"!=typeof t)throw Error('An invalid "columnWidth" prop has been specified. Value should be a function. "'+(null===t?"null":typeof t)+'" was specified.');if("function"!=typeof r)throw Error('An invalid "rowHeight" prop has been specified. Value should be a function. "'+(null===r?"null":typeof r)+'" was specified.')}}),O=function(e,t){return e},P=null,W=null;function E(e){var n,a=e.getItemOffset,l=e.getEstimatedTotalSize,c=e.getItemSize,f=e.getOffsetForIndexAndAlignment,p=e.getStartIndexForOffset,v=e.getStopIndexForStartIndex,g=e.initInstanceProps,w=e.shouldResetStyleCacheOnItemSizeChange,S=e.validateProps;return(n=function(e){function n(t){var r;return(r=e.call(this,t)||this)._instanceProps=g(r.props,o(r)),r._outerRef=void 0,r._resetIsScrollingTimeoutId=null,r.state={instance:o(r),isScrolling:!1,scrollDirection:"forward",scrollOffset:"number"==typeof r.props.initialScrollOffset?r.props.initialScrollOffset:0,scrollUpdateWasRequested:!1},r._callOnItemsRendered=void 0,r._callOnItemsRendered=s((function(e,t,o,n){return r.props.onItemsRendered({overscanStartIndex:e,overscanStopIndex:t,visibleStartIndex:o,visibleStopIndex:n})})),r._callOnScroll=void 0,r._callOnScroll=s((function(e,t,o){return r.props.onScroll({scrollDirection:e,scrollOffset:t,scrollUpdateWasRequested:o})})),r._getItemStyle=void 0,r._getItemStyle=function(e){var t,o=r.props,n=o.direction,i=o.itemSize,l=o.layout,s=r._getItemStyleCache(w&&i,w&&l,w&&n);if(s.hasOwnProperty(e))t=s[e];else{var u=a(r.props,e,r._instanceProps),d=c(r.props,e,r._instanceProps),f="horizontal"===n||"horizontal"===l,h="rtl"===n,p=f?u:0;s[e]=t={position:"absolute",left:h?void 0:p,right:h?p:void 0,top:f?0:u,height:f?"100%":d,width:f?d:"100%"}}return t},r._getItemStyleCache=void 0,r._getItemStyleCache=s((function(e,t,r){return{}})),r._onScrollHorizontal=function(e){var t=e.currentTarget,o=t.clientWidth,n=t.scrollLeft,i=t.scrollWidth;r.setState((function(e){if(e.scrollOffset===n)return null;var t=r.props.direction,a=n;if("rtl"===t)switch(m()){case"negative":a=-n;break;case"positive-descending":a=i-o-n}return a=Math.max(0,Math.min(a,i-o)),{isScrolling:!0,scrollDirection:e.scrollOffset<n?"forward":"backward",scrollOffset:a,scrollUpdateWasRequested:!1}}),r._resetIsScrollingDebounced)},r._onScrollVertical=function(e){var t=e.currentTarget,o=t.clientHeight,n=t.scrollHeight,i=t.scrollTop;r.setState((function(e){if(e.scrollOffset===i)return null;var t=Math.max(0,Math.min(i,n-o));return{isScrolling:!0,scrollDirection:e.scrollOffset<t?"forward":"backward",scrollOffset:t,scrollUpdateWasRequested:!1}}),r._resetIsScrollingDebounced)},r._outerRefSetter=function(e){var t=r.props.outerRef;r._outerRef=e,"function"==typeof t?t(e):null!=t&&"object"==typeof t&&t.hasOwnProperty("current")&&(t.current=e)},r._resetIsScrollingDebounced=function(){null!==r._resetIsScrollingTimeoutId&&u(r._resetIsScrollingTimeoutId),r._resetIsScrollingTimeoutId=d(r._resetIsScrolling,150)},r._resetIsScrolling=function(){r._resetIsScrollingTimeoutId=null,r.setState({isScrolling:!1},(function(){r._getItemStyleCache(-1,null)}))},r}i(n,e),n.getDerivedStateFromProps=function(e,t){return A(e,t),S(e),null};var I=n.prototype;return I.scrollTo=function(e){e=Math.max(0,e),this.setState((function(t){return t.scrollOffset===e?null:{scrollDirection:t.scrollOffset<e?"forward":"backward",scrollOffset:e,scrollUpdateWasRequested:!0}}),this._resetIsScrollingDebounced)},I.scrollToItem=function(e,t){void 0===t&&(t="auto");var r=this.props,o=r.itemCount,n=r.layout,i=this.state.scrollOffset;e=Math.max(0,Math.min(e,o-1));var a=0;if(this._outerRef){var l=this._outerRef;a="vertical"===n?l.scrollWidth>l.clientWidth?h():0:l.scrollHeight>l.clientHeight?h():0}this.scrollTo(f(this.props,e,t,i,this._instanceProps,a))},I.componentDidMount=function(){var e=this.props,t=e.direction,r=e.initialScrollOffset,o=e.layout;if("number"==typeof r&&null!=this._outerRef){var n=this._outerRef;"horizontal"===t||"horizontal"===o?n.scrollLeft=r:n.scrollTop=r}this._callPropsCallbacks()},I.componentDidUpdate=function(){var e=this.props,t=e.direction,r=e.layout,o=this.state,n=o.scrollOffset;if(o.scrollUpdateWasRequested&&null!=this._outerRef){var i=this._outerRef;if("horizontal"===t||"horizontal"===r)if("rtl"===t)switch(m()){case"negative":i.scrollLeft=-n;break;case"positive-ascending":i.scrollLeft=n;break;default:var a=i.clientWidth,l=i.scrollWidth;i.scrollLeft=l-a-n}else i.scrollLeft=n;else i.scrollTop=n}this._callPropsCallbacks()},I.componentWillUnmount=function(){null!==this._resetIsScrollingTimeoutId&&u(this._resetIsScrollingTimeoutId)},I.render=function(){var e=this.props,o=e.children,n=e.className,i=e.direction,a=e.height,s=e.innerRef,c=e.innerElementType,u=e.innerTagName,d=e.itemCount,f=e.itemData,h=e.itemKey,p=void 0===h?O:h,m=e.layout,v=e.outerElementType,g=e.outerTagName,w=e.style,S=e.useIsScrolling,I=e.width,M=this.state.isScrolling,y="horizontal"===i||"horizontal"===m,x=y?this._onScrollHorizontal:this._onScrollVertical,C=this._getRangeToRender(),b=C[0],_=C[1],R=[];if(d>0)for(var T=b;T<=_;T++)R.push(t.createElement(o,{data:f,key:p(T,f),index:T,isScrolling:S?M:void 0,style:this._getItemStyle(T)}));var z=l(this.props,this._instanceProps);return t.createElement(v||g||"div",{className:n,onScroll:x,ref:this._outerRefSetter,style:r({position:"relative",height:a,width:I,overflow:"auto",WebkitOverflowScrolling:"touch",willChange:"transform",direction:i},w)},t.createElement(c||u||"div",{children:R,ref:s,style:{height:y?"100%":z,pointerEvents:M?"none":void 0,width:y?z:"100%"}}))},I._callPropsCallbacks=function(){if("function"==typeof this.props.onItemsRendered&&this.props.itemCount>0){var e=this._getRangeToRender(),t=e[0],r=e[1],o=e[2],n=e[3];this._callOnItemsRendered(t,r,o,n)}if("function"==typeof this.props.onScroll){var i=this.state,a=i.scrollDirection,l=i.scrollOffset,s=i.scrollUpdateWasRequested;this._callOnScroll(a,l,s)}},I._getRangeToRender=function(){var e=this.props,t=e.itemCount,r=e.overscanCount,o=this.state,n=o.isScrolling,i=o.scrollDirection,a=o.scrollOffset;if(0===t)return[0,0,0,0];var l=p(this.props,a,this._instanceProps),s=v(this.props,l,a,this._instanceProps),c=n&&"backward"!==i?1:Math.max(1,r),u=n&&"forward"!==i?1:Math.max(1,r);return[Math.max(0,l-c),Math.max(0,Math.min(t-1,s+u)),l,s]},n}(t.PureComponent)).defaultProps={direction:"ltr",itemData:void 0,layout:"vertical",overscanCount:2,useIsScrolling:!1},n}"undefined"!=typeof window&&void 0!==window.WeakSet&&(P=new WeakSet,W=new WeakSet);var A=function(e,t){var r=e.children,o=e.direction,n=e.height,i=e.layout,a=e.innerTagName,l=e.outerTagName,s=e.width,c=t.instance;null==a&&null==l||W&&!W.has(c)&&(W.add(c),console.warn("The innerTagName and outerTagName props have been deprecated. Please use the innerElementType and outerElementType props instead."));var u="horizontal"===o||"horizontal"===i;switch(o){case"horizontal":case"vertical":P&&!P.has(c)&&(P.add(c),console.warn('The direction prop should be either "ltr" (default) or "rtl". Please use the layout prop to specify "vertical" (default) or "horizontal" orientation.'));break;case"ltr":case"rtl":break;default:throw Error('An invalid "direction" prop has been specified. Value should be either "ltr" or "rtl". "'+o+'" was specified.')}switch(i){case"horizontal":case"vertical":break;default:throw Error('An invalid "layout" prop has been specified. Value should be either "horizontal" or "vertical". "'+i+'" was specified.')}if(null==r)throw Error('An invalid "children" prop has been specified. Value should be a React component. "'+(null===r?"null":typeof r)+'" was specified.');if(u&&"number"!=typeof s)throw Error('An invalid "width" prop has been specified. Horizontal lists must specify a number for width. "'+(null===s?"null":typeof s)+'" was specified.');if(!u&&"number"!=typeof n)throw Error('An invalid "height" prop has been specified. Vertical lists must specify a number for height. "'+(null===n?"null":typeof n)+'" was specified.')},k=function(e,t,r){var o=e.itemSize,n=r.itemMetadataMap,i=r.lastMeasuredIndex;if(t>i){var a=0;if(i>=0){var l=n[i];a=l.offset+l.size}for(var s=i+1;s<=t;s++){var c=o(s);n[s]={offset:a,size:c},a+=c}r.lastMeasuredIndex=t}return n[t]},D=function(e,t,r,o,n){for(;o<=r;){var i=o+Math.floor((r-o)/2),a=k(e,i,t).offset;if(a===n)return i;a<n?o=i+1:a>n&&(r=i-1)}return o>0?o-1:0},F=function(e,t,r,o){for(var n=e.itemCount,i=1;r<n&&k(e,r,t).offset<o;)r+=i,i*=2;return D(e,t,Math.min(r,n-1),Math.floor(r/2),o)},L=function(e,t){var r=e.itemCount,o=t.itemMetadataMap,n=t.estimatedItemSize,i=t.lastMeasuredIndex,a=0;if(i>=r&&(i=r-1),i>=0){var l=o[i];a=l.offset+l.size}return a+(r-i-1)*n},H=E({getItemOffset:function(e,t,r){return k(e,t,r).offset},getItemSize:function(e,t,r){return r.itemMetadataMap[t].size},getEstimatedTotalSize:L,getOffsetForIndexAndAlignment:function(e,t,r,o,n,i){var a=e.direction,l=e.height,s=e.layout,c=e.width,u="horizontal"===a||"horizontal"===s?c:l,d=k(e,t,n),f=L(e,n),h=Math.max(0,Math.min(f-u,d.offset)),p=Math.max(0,d.offset-u+d.size+i);switch("smart"===r&&(r=o>=p-u&&o<=h+u?"auto":"center"),r){case"start":return h;case"end":return p;case"center":return Math.round(p+(h-p)/2);case"auto":default:return o>=p&&o<=h?o:o<p?p:h}},getStartIndexForOffset:function(e,t,r){return function(e,t,r){var o=t.itemMetadataMap,n=t.lastMeasuredIndex;return(n>0?o[n].offset:0)>=r?D(e,t,n,0,r):F(e,t,Math.max(0,n),r)}(e,r,t)},getStopIndexForStartIndex:function(e,t,r,o){for(var n=e.direction,i=e.height,a=e.itemCount,l=e.layout,s=e.width,c="horizontal"===n||"horizontal"===l?s:i,u=k(e,t,o),d=r+c,f=u.offset+u.size,h=t;h<a-1&&f<d;)h++,f+=k(e,h,o).size;return h},initInstanceProps:function(e,t){var r={itemMetadataMap:{},estimatedItemSize:e.estimatedItemSize||50,lastMeasuredIndex:-1};return t.resetAfterIndex=function(e,o){void 0===o&&(o=!0),r.lastMeasuredIndex=Math.min(r.lastMeasuredIndex,e-1),t._getItemStyleCache(-1),o&&t.forceUpdate()},r},shouldResetStyleCacheOnItemSizeChange:!1,validateProps:function(e){var t=e.itemSize;if("function"!=typeof t)throw Error('An invalid "itemSize" prop has been specified. Value should be a function. "'+(null===t?"null":typeof t)+'" was specified.')}}),U=I({getColumnOffset:function(e,t){return t*e.columnWidth},getColumnWidth:function(e,t){return e.columnWidth},getRowOffset:function(e,t){return t*e.rowHeight},getRowHeight:function(e,t){return e.rowHeight},getEstimatedTotalHeight:function(e){var t=e.rowCount;return e.rowHeight*t},getEstimatedTotalWidth:function(e){var t=e.columnCount;return e.columnWidth*t},getOffsetForColumnAndAlignment:function(e,t,r,o,n,i){var a=e.columnCount,l=e.columnWidth,s=e.width,c=Math.max(0,a*l-s),u=Math.min(c,t*l),d=Math.max(0,t*l-s+i+l);switch("smart"===r&&(r=o>=d-s&&o<=u+s?"auto":"center"),r){case"start":return u;case"end":return d;case"center":var f=Math.round(d+(u-d)/2);return f<Math.ceil(s/2)?0:f>c+Math.floor(s/2)?c:f;case"auto":default:return o>=d&&o<=u?o:d>u||o<d?d:u}},getOffsetForRowAndAlignment:function(e,t,r,o,n,i){var a=e.rowHeight,l=e.height,s=e.rowCount,c=Math.max(0,s*a-l),u=Math.min(c,t*a),d=Math.max(0,t*a-l+i+a);switch("smart"===r&&(r=o>=d-l&&o<=u+l?"auto":"center"),r){case"start":return u;case"end":return d;case"center":var f=Math.round(d+(u-d)/2);return f<Math.ceil(l/2)?0:f>c+Math.floor(l/2)?c:f;case"auto":default:return o>=d&&o<=u?o:d>u||o<d?d:u}},getColumnStartIndexForOffset:function(e,t){var r=e.columnWidth,o=e.columnCount;return Math.max(0,Math.min(o-1,Math.floor(t/r)))},getColumnStopIndexForStartIndex:function(e,t,r){var o=e.columnWidth,n=e.columnCount,i=e.width,a=t*o,l=Math.ceil((i+r-a)/o);return Math.max(0,Math.min(n-1,t+l-1))},getRowStartIndexForOffset:function(e,t){var r=e.rowHeight,o=e.rowCount;return Math.max(0,Math.min(o-1,Math.floor(t/r)))},getRowStopIndexForStartIndex:function(e,t,r){var o=e.rowHeight,n=e.rowCount,i=e.height,a=t*o,l=Math.ceil((i+r-a)/o);return Math.max(0,Math.min(n-1,t+l-1))},initInstanceProps:function(e){},shouldResetStyleCacheOnItemSizeChange:!0,validateProps:function(e){var t=e.columnWidth,r=e.rowHeight;if("number"!=typeof t)throw Error('An invalid "columnWidth" prop has been specified. Value should be a number. "'+(null===t?"null":typeof t)+'" was specified.');if("number"!=typeof r)throw Error('An invalid "rowHeight" prop has been specified. Value should be a number. "'+(null===r?"null":typeof r)+'" was specified.')}}),V=E({getItemOffset:function(e,t){return t*e.itemSize},getItemSize:function(e,t){return e.itemSize},getEstimatedTotalSize:function(e){var t=e.itemCount;return e.itemSize*t},getOffsetForIndexAndAlignment:function(e,t,r,o,n,i){var a=e.direction,l=e.height,s=e.itemCount,c=e.itemSize,u=e.layout,d=e.width,f="horizontal"===a||"horizontal"===u?d:l,h=Math.max(0,s*c-f),p=Math.min(h,t*c),m=Math.max(0,t*c-f+c+i);switch("smart"===r&&(r=o>=m-f&&o<=p+f?"auto":"center"),r){case"start":return p;case"end":return m;case"center":var v=Math.round(m+(p-m)/2);return v<Math.ceil(f/2)?0:v>h+Math.floor(f/2)?h:v;case"auto":default:return o>=m&&o<=p?o:o<m?m:p}},getStartIndexForOffset:function(e,t){var r=e.itemCount,o=e.itemSize;return Math.max(0,Math.min(r-1,Math.floor(t/o)))},getStopIndexForStartIndex:function(e,t,r){var o=e.direction,n=e.height,i=e.itemCount,a=e.itemSize,l=e.layout,s=e.width,c=t*a,u="horizontal"===o||"horizontal"===l?s:n,d=Math.ceil((u+r-c)/a);return Math.max(0,Math.min(i-1,t+d-1))},initInstanceProps:function(e){},shouldResetStyleCacheOnItemSizeChange:!0,validateProps:function(e){var t=e.itemSize;if("number"!=typeof t)throw Error('An invalid "itemSize" prop has been specified. Value should be a number. "'+(null===t?"null":typeof t)+'" was specified.')}});function N(e,t){if(null==e)return{};var r,o,n={},i=Object.keys(e);for(o=0;o<i.length;o++)r=i[o],t.indexOf(r)>=0||(n[r]=e[r]);return n}function q(e,t){for(var r in e)if(!(r in t))return!0;for(var o in t)if(e[o]!==t[o])return!0;return!1}var j=["style"],G=["style"];function K(e,t){var r=e.style,o=N(e,j),n=t.style,i=N(t,G);return!q(r,n)&&!q(o,i)}e.FixedSizeGrid=U,e.FixedSizeList=V,e.VariableSizeGrid=z,e.VariableSizeList=H,e.areEqual=K,e.shouldComponentUpdate=function(e,t){return!K(this.props,e)||q(this.state,t)},Object.defineProperty(e,"__esModule",{value:!0})}));
 //# sourceMappingURL=index-dev.umd.js.map
diff --git a/node_modules/react-window/dist/index-dev.umd.js.map b/node_modules/react-window/dist/index-dev.umd.js.map
index eb41895..a2f9792 100644
--- a/node_modules/react-window/dist/index-dev.umd.js.map
+++ b/node_modules/react-window/dist/index-dev.umd.js.map
@@ -1 +1 @@
-{"version":3,"file":"index-dev.umd.js","sources":["../node_modules/@babel/runtime/helpers/esm/extends.js","../node_modules/@babel/runtime/helpers/esm/inheritsLoose.js","../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","../node_modules/memoize-one/dist/memoize-one.esm.js","../src/timer.js","../src/domHelpers.js","../src/createGridComponent.js","../src/VariableSizeGrid.js","../src/createListComponent.js","../src/VariableSizeList.js","../src/FixedSizeGrid.js","../src/FixedSizeList.js","../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js","../src/shallowDiffers.js","../src/areEqual.js","../src/shouldComponentUpdate.js"],"sourcesContent":["export default function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}","export default function _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}","export default function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}","var shallowEqual = function shallowEqual(newValue, oldValue) {\n  return newValue === oldValue;\n};\n\nvar simpleIsEqual = function simpleIsEqual(newArgs, lastArgs) {\n  return newArgs.length === lastArgs.length && newArgs.every(function (newArg, index) {\n    return shallowEqual(newArg, lastArgs[index]);\n  });\n};\n\nfunction index (resultFn, isEqual) {\n  if (isEqual === void 0) {\n    isEqual = simpleIsEqual;\n  }\n\n  var lastThis;\n  var lastArgs = [];\n  var lastResult;\n  var calledOnce = false;\n\n  var result = function result() {\n    for (var _len = arguments.length, newArgs = new Array(_len), _key = 0; _key < _len; _key++) {\n      newArgs[_key] = arguments[_key];\n    }\n\n    if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {\n      return lastResult;\n    }\n\n    lastResult = resultFn.apply(this, newArgs);\n    calledOnce = true;\n    lastThis = this;\n    lastArgs = newArgs;\n    return lastResult;\n  };\n\n  return result;\n}\n\nexport default index;\n","// @flow\n\n// Animation frame based implementation of setTimeout.\n// Inspired by Joe Lambert, https://gist.github.com/joelambert/1002116#file-requesttimeout-js\n\nconst hasNativePerformanceNow =\n  typeof performance === 'object' && typeof performance.now === 'function';\n\nconst now = hasNativePerformanceNow\n  ? () => performance.now()\n  : () => Date.now();\n\nexport type TimeoutID = {|\n  id: AnimationFrameID,\n|};\n\nexport function cancelTimeout(timeoutID: TimeoutID) {\n  cancelAnimationFrame(timeoutID.id);\n}\n\nexport function requestTimeout(callback: Function, delay: number): TimeoutID {\n  const start = now();\n\n  function tick() {\n    if (now() - start >= delay) {\n      callback.call(null);\n    } else {\n      timeoutID.id = requestAnimationFrame(tick);\n    }\n  }\n\n  const timeoutID: TimeoutID = {\n    id: requestAnimationFrame(tick),\n  };\n\n  return timeoutID;\n}\n","// @flow\n\nlet size: number = -1;\n\n// This utility copied from \"dom-helpers\" package.\nexport function getScrollbarSize(recalculate?: boolean = false): number {\n  if (size === -1 || recalculate) {\n    const div = document.createElement('div');\n    const style = div.style;\n    style.width = '50px';\n    style.height = '50px';\n    style.overflow = 'scroll';\n\n    ((document.body: any): HTMLBodyElement).appendChild(div);\n\n    size = div.offsetWidth - div.clientWidth;\n\n    ((document.body: any): HTMLBodyElement).removeChild(div);\n  }\n\n  return size;\n}\n\nexport type RTLOffsetType =\n  | 'negative'\n  | 'positive-descending'\n  | 'positive-ascending';\n\nlet cachedRTLResult: RTLOffsetType | null = null;\n\n// TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n// Chrome does not seem to adhere; its scrollLeft values are positive (measured relative to the left).\n// Safari's elastic bounce makes detecting this even more complicated wrt potential false positives.\n// The safest way to check this is to intentionally set a negative offset,\n// and then verify that the subsequent \"scroll\" event matches the negative offset.\n// If it does not match, then we can assume a non-standard RTL scroll implementation.\nexport function getRTLOffsetType(recalculate?: boolean = false): RTLOffsetType {\n  if (cachedRTLResult === null || recalculate) {\n    const outerDiv = document.createElement('div');\n    const outerStyle = outerDiv.style;\n    outerStyle.width = '50px';\n    outerStyle.height = '50px';\n    outerStyle.overflow = 'scroll';\n    outerStyle.direction = 'rtl';\n\n    const innerDiv = document.createElement('div');\n    const innerStyle = innerDiv.style;\n    innerStyle.width = '100px';\n    innerStyle.height = '100px';\n\n    outerDiv.appendChild(innerDiv);\n\n    ((document.body: any): HTMLBodyElement).appendChild(outerDiv);\n\n    if (outerDiv.scrollLeft > 0) {\n      cachedRTLResult = 'positive-descending';\n    } else {\n      outerDiv.scrollLeft = 1;\n      if (outerDiv.scrollLeft === 0) {\n        cachedRTLResult = 'negative';\n      } else {\n        cachedRTLResult = 'positive-ascending';\n      }\n    }\n\n    ((document.body: any): HTMLBodyElement).removeChild(outerDiv);\n\n    return cachedRTLResult;\n  }\n\n  return cachedRTLResult;\n}\n","// @flow\n\nimport memoizeOne from 'memoize-one';\nimport { createElement, PureComponent } from 'react';\nimport { cancelTimeout, requestTimeout } from './timer';\nimport { getScrollbarSize, getRTLOffsetType } from './domHelpers';\n\nimport type { TimeoutID } from './timer';\n\ntype Direction = 'ltr' | 'rtl';\nexport type ScrollToAlign = 'auto' | 'smart' | 'center' | 'start' | 'end';\n\ntype itemSize = number | ((index: number) => number);\n\ntype RenderComponentProps<T> = {|\n  columnIndex: number,\n  data: T,\n  isScrolling?: boolean,\n  rowIndex: number,\n  style: Object,\n|};\nexport type RenderComponent<T> = React$ComponentType<\n  $Shape<RenderComponentProps<T>>\n>;\n\ntype ScrollDirection = 'forward' | 'backward';\n\ntype OnItemsRenderedCallback = ({\n  overscanColumnStartIndex: number,\n  overscanColumnStopIndex: number,\n  overscanRowStartIndex: number,\n  overscanRowStopIndex: number,\n  visibleColumnStartIndex: number,\n  visibleColumnStopIndex: number,\n  visibleRowStartIndex: number,\n  visibleRowStopIndex: number,\n}) => void;\ntype OnScrollCallback = ({\n  horizontalScrollDirection: ScrollDirection,\n  scrollLeft: number,\n  scrollTop: number,\n  scrollUpdateWasRequested: boolean,\n  verticalScrollDirection: ScrollDirection,\n}) => void;\n\ntype ScrollEvent = SyntheticEvent<HTMLDivElement>;\ntype ItemStyleCache = { [key: string]: Object };\n\ntype OuterProps = {|\n  children: React$Node,\n  className: string | void,\n  onScroll: ScrollEvent => void,\n  style: {\n    [string]: mixed,\n  },\n|};\n\ntype InnerProps = {|\n  children: React$Node,\n  style: {\n    [string]: mixed,\n  },\n|};\n\nexport type Props<T> = {|\n  children: RenderComponent<T>,\n  className?: string,\n  columnCount: number,\n  columnWidth: itemSize,\n  direction: Direction,\n  height: number,\n  initialScrollLeft?: number,\n  initialScrollTop?: number,\n  innerRef?: any,\n  innerElementType?: string | React$AbstractComponent<InnerProps, any>,\n  innerTagName?: string, // deprecated\n  itemData: T,\n  itemKey?: (params: {|\n    columnIndex: number,\n    data: T,\n    rowIndex: number,\n  |}) => any,\n  onItemsRendered?: OnItemsRenderedCallback,\n  onScroll?: OnScrollCallback,\n  outerRef?: any,\n  outerElementType?: string | React$AbstractComponent<OuterProps, any>,\n  outerTagName?: string, // deprecated\n  overscanColumnCount?: number,\n  overscanColumnsCount?: number, // deprecated\n  overscanCount?: number, // deprecated\n  overscanRowCount?: number,\n  overscanRowsCount?: number, // deprecated\n  rowCount: number,\n  rowHeight: itemSize,\n  style?: Object,\n  useIsScrolling: boolean,\n  width: number,\n|};\n\ntype State = {|\n  instance: any,\n  isScrolling: boolean,\n  horizontalScrollDirection: ScrollDirection,\n  scrollLeft: number,\n  scrollTop: number,\n  scrollUpdateWasRequested: boolean,\n  verticalScrollDirection: ScrollDirection,\n|};\n\ntype getItemOffset = (\n  props: Props<any>,\n  index: number,\n  instanceProps: any\n) => number;\ntype getItemSize = (\n  props: Props<any>,\n  index: number,\n  instanceProps: any\n) => number;\ntype getEstimatedTotalSize = (props: Props<any>, instanceProps: any) => number;\ntype GetOffsetForItemAndAlignment = (\n  props: Props<any>,\n  index: number,\n  align: ScrollToAlign,\n  scrollOffset: number,\n  instanceProps: any,\n  scrollbarSize: number\n) => number;\ntype GetStartIndexForOffset = (\n  props: Props<any>,\n  offset: number,\n  instanceProps: any\n) => number;\ntype GetStopIndexForStartIndex = (\n  props: Props<any>,\n  startIndex: number,\n  scrollOffset: number,\n  instanceProps: any\n) => number;\ntype InitInstanceProps = (props: Props<any>, instance: any) => any;\ntype ValidateProps = (props: Props<any>) => void;\n\nconst IS_SCROLLING_DEBOUNCE_INTERVAL = 150;\n\nconst defaultItemKey = ({ columnIndex, data, rowIndex }) =>\n  `${rowIndex}:${columnIndex}`;\n\n// In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\nlet devWarningsOverscanCount = null;\nlet devWarningsOverscanRowsColumnsCount = null;\nlet devWarningsTagName = null;\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsOverscanCount = new WeakSet();\n    devWarningsOverscanRowsColumnsCount = new WeakSet();\n    devWarningsTagName = new WeakSet();\n  }\n}\n\nexport default function createGridComponent({\n  getColumnOffset,\n  getColumnStartIndexForOffset,\n  getColumnStopIndexForStartIndex,\n  getColumnWidth,\n  getEstimatedTotalHeight,\n  getEstimatedTotalWidth,\n  getOffsetForColumnAndAlignment,\n  getOffsetForRowAndAlignment,\n  getRowHeight,\n  getRowOffset,\n  getRowStartIndexForOffset,\n  getRowStopIndexForStartIndex,\n  initInstanceProps,\n  shouldResetStyleCacheOnItemSizeChange,\n  validateProps,\n}: {|\n  getColumnOffset: getItemOffset,\n  getColumnStartIndexForOffset: GetStartIndexForOffset,\n  getColumnStopIndexForStartIndex: GetStopIndexForStartIndex,\n  getColumnWidth: getItemSize,\n  getEstimatedTotalHeight: getEstimatedTotalSize,\n  getEstimatedTotalWidth: getEstimatedTotalSize,\n  getOffsetForColumnAndAlignment: GetOffsetForItemAndAlignment,\n  getOffsetForRowAndAlignment: GetOffsetForItemAndAlignment,\n  getRowOffset: getItemOffset,\n  getRowHeight: getItemSize,\n  getRowStartIndexForOffset: GetStartIndexForOffset,\n  getRowStopIndexForStartIndex: GetStopIndexForStartIndex,\n  initInstanceProps: InitInstanceProps,\n  shouldResetStyleCacheOnItemSizeChange: boolean,\n  validateProps: ValidateProps,\n|}) {\n  return class Grid<T> extends PureComponent<Props<T>, State> {\n    _instanceProps: any = initInstanceProps(this.props, this);\n    _resetIsScrollingTimeoutId: TimeoutID | null = null;\n    _outerRef: ?HTMLDivElement;\n\n    static defaultProps = {\n      direction: 'ltr',\n      itemData: undefined,\n      useIsScrolling: false,\n    };\n\n    state: State = {\n      instance: this,\n      isScrolling: false,\n      horizontalScrollDirection: 'forward',\n      scrollLeft:\n        typeof this.props.initialScrollLeft === 'number'\n          ? this.props.initialScrollLeft\n          : 0,\n      scrollTop:\n        typeof this.props.initialScrollTop === 'number'\n          ? this.props.initialScrollTop\n          : 0,\n      scrollUpdateWasRequested: false,\n      verticalScrollDirection: 'forward',\n    };\n\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    constructor(props: Props<T>) {\n      super(props);\n    }\n\n    static getDerivedStateFromProps(\n      nextProps: Props<T>,\n      prevState: State\n    ): $Shape<State> | null {\n      validateSharedProps(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    }\n\n    scrollTo({\n      scrollLeft,\n      scrollTop,\n    }: {\n      scrollLeft: number,\n      scrollTop: number,\n    }): void {\n      if (scrollLeft !== undefined) {\n        scrollLeft = Math.max(0, scrollLeft);\n      }\n      if (scrollTop !== undefined) {\n        scrollTop = Math.max(0, scrollTop);\n      }\n\n      this.setState(prevState => {\n        if (scrollLeft === undefined) {\n          scrollLeft = prevState.scrollLeft;\n        }\n        if (scrollTop === undefined) {\n          scrollTop = prevState.scrollTop;\n        }\n\n        if (\n          prevState.scrollLeft === scrollLeft &&\n          prevState.scrollTop === scrollTop\n        ) {\n          return null;\n        }\n\n        return {\n          horizontalScrollDirection:\n            prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          scrollUpdateWasRequested: true,\n          verticalScrollDirection:\n            prevState.scrollTop < scrollTop ? 'forward' : 'backward',\n        };\n      }, this._resetIsScrollingDebounced);\n    }\n\n    scrollToItem({\n      align = 'auto',\n      columnIndex,\n      rowIndex,\n    }: {\n      align: ScrollToAlign,\n      columnIndex?: number,\n      rowIndex?: number,\n    }): void {\n      const { columnCount, height, rowCount, width } = this.props;\n      const { scrollLeft, scrollTop } = this.state;\n      const scrollbarSize = getScrollbarSize();\n\n      if (columnIndex !== undefined) {\n        columnIndex = Math.max(0, Math.min(columnIndex, columnCount - 1));\n      }\n      if (rowIndex !== undefined) {\n        rowIndex = Math.max(0, Math.min(rowIndex, rowCount - 1));\n      }\n\n      const estimatedTotalHeight = getEstimatedTotalHeight(\n        this.props,\n        this._instanceProps\n      );\n      const estimatedTotalWidth = getEstimatedTotalWidth(\n        this.props,\n        this._instanceProps\n      );\n\n      // The scrollbar size should be considered when scrolling an item into view,\n      // to ensure it's fully visible.\n      // But we only need to account for its size when it's actually visible.\n      const horizontalScrollbarSize =\n        estimatedTotalWidth > width ? scrollbarSize : 0;\n      const verticalScrollbarSize =\n        estimatedTotalHeight > height ? scrollbarSize : 0;\n\n      this.scrollTo({\n        scrollLeft:\n          columnIndex !== undefined\n            ? getOffsetForColumnAndAlignment(\n                this.props,\n                columnIndex,\n                align,\n                scrollLeft,\n                this._instanceProps,\n                verticalScrollbarSize\n              )\n            : scrollLeft,\n        scrollTop:\n          rowIndex !== undefined\n            ? getOffsetForRowAndAlignment(\n                this.props,\n                rowIndex,\n                align,\n                scrollTop,\n                this._instanceProps,\n                horizontalScrollbarSize\n              )\n            : scrollTop,\n      });\n    }\n\n    componentDidMount() {\n      const { initialScrollLeft, initialScrollTop } = this.props;\n\n      if (this._outerRef != null) {\n        const outerRef = ((this._outerRef: any): HTMLElement);\n        if (typeof initialScrollLeft === 'number') {\n          outerRef.scrollLeft = initialScrollLeft;\n        }\n        if (typeof initialScrollTop === 'number') {\n          outerRef.scrollTop = initialScrollTop;\n        }\n      }\n\n      this._callPropsCallbacks();\n    }\n\n    componentDidUpdate() {\n      const { direction } = this.props;\n      const { scrollLeft, scrollTop, scrollUpdateWasRequested } = this.state;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n        // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n        // So we need to determine which browser behavior we're dealing with, and mimic it.\n        const outerRef = ((this._outerRef: any): HTMLElement);\n        if (direction === 'rtl') {\n          switch (getRTLOffsetType()) {\n            case 'negative':\n              outerRef.scrollLeft = -scrollLeft;\n              break;\n            case 'positive-ascending':\n              outerRef.scrollLeft = scrollLeft;\n              break;\n            default:\n              const { clientWidth, scrollWidth } = outerRef;\n              outerRef.scrollLeft = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        } else {\n          outerRef.scrollLeft = Math.max(0, scrollLeft);\n        }\n\n        outerRef.scrollTop = Math.max(0, scrollTop);\n      }\n\n      this._callPropsCallbacks();\n    }\n\n    componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    }\n\n    render() {\n      const {\n        children,\n        className,\n        columnCount,\n        direction,\n        height,\n        innerRef,\n        innerElementType,\n        innerTagName,\n        itemData,\n        itemKey = defaultItemKey,\n        outerElementType,\n        outerTagName,\n        rowCount,\n        style,\n        useIsScrolling,\n        width,\n      } = this.props;\n      const { isScrolling } = this.state;\n\n      const [\n        columnStartIndex,\n        columnStopIndex,\n      ] = this._getHorizontalRangeToRender();\n      const [rowStartIndex, rowStopIndex] = this._getVerticalRangeToRender();\n\n      const items = [];\n      if (columnCount > 0 && rowCount) {\n        for (\n          let rowIndex = rowStartIndex;\n          rowIndex <= rowStopIndex;\n          rowIndex++\n        ) {\n          for (\n            let columnIndex = columnStartIndex;\n            columnIndex <= columnStopIndex;\n            columnIndex++\n          ) {\n            items.push(\n              createElement(children, {\n                columnIndex,\n                data: itemData,\n                isScrolling: useIsScrolling ? isScrolling : undefined,\n                key: itemKey({ columnIndex, data: itemData, rowIndex }),\n                rowIndex,\n                style: this._getItemStyle(rowIndex, columnIndex),\n              })\n            );\n          }\n        }\n      }\n\n      // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n      const estimatedTotalHeight = getEstimatedTotalHeight(\n        this.props,\n        this._instanceProps\n      );\n      const estimatedTotalWidth = getEstimatedTotalWidth(\n        this.props,\n        this._instanceProps\n      );\n\n      return createElement(\n        outerElementType || outerTagName || 'div',\n        {\n          className,\n          onScroll: this._onScroll,\n          ref: this._outerRefSetter,\n          style: {\n            position: 'relative',\n            height,\n            width,\n            overflow: 'auto',\n            WebkitOverflowScrolling: 'touch',\n            willChange: 'transform',\n            direction,\n            ...style,\n          },\n        },\n        createElement(innerElementType || innerTagName || 'div', {\n          children: items,\n          ref: innerRef,\n          style: {\n            height: estimatedTotalHeight,\n            pointerEvents: isScrolling ? 'none' : undefined,\n            width: estimatedTotalWidth,\n          },\n        })\n      );\n    }\n\n    _callOnItemsRendered: (\n      overscanColumnStartIndex: number,\n      overscanColumnStopIndex: number,\n      overscanRowStartIndex: number,\n      overscanRowStopIndex: number,\n      visibleColumnStartIndex: number,\n      visibleColumnStopIndex: number,\n      visibleRowStartIndex: number,\n      visibleRowStopIndex: number\n    ) => void;\n    _callOnItemsRendered = memoizeOne(\n      (\n        overscanColumnStartIndex: number,\n        overscanColumnStopIndex: number,\n        overscanRowStartIndex: number,\n        overscanRowStopIndex: number,\n        visibleColumnStartIndex: number,\n        visibleColumnStopIndex: number,\n        visibleRowStartIndex: number,\n        visibleRowStopIndex: number\n      ) =>\n        ((this.props.onItemsRendered: any): OnItemsRenderedCallback)({\n          overscanColumnStartIndex,\n          overscanColumnStopIndex,\n          overscanRowStartIndex,\n          overscanRowStopIndex,\n          visibleColumnStartIndex,\n          visibleColumnStopIndex,\n          visibleRowStartIndex,\n          visibleRowStopIndex,\n        })\n    );\n\n    _callOnScroll: (\n      scrollLeft: number,\n      scrollTop: number,\n      horizontalScrollDirection: ScrollDirection,\n      verticalScrollDirection: ScrollDirection,\n      scrollUpdateWasRequested: boolean\n    ) => void;\n    _callOnScroll = memoizeOne(\n      (\n        scrollLeft: number,\n        scrollTop: number,\n        horizontalScrollDirection: ScrollDirection,\n        verticalScrollDirection: ScrollDirection,\n        scrollUpdateWasRequested: boolean\n      ) =>\n        ((this.props.onScroll: any): OnScrollCallback)({\n          horizontalScrollDirection,\n          scrollLeft,\n          scrollTop,\n          verticalScrollDirection,\n          scrollUpdateWasRequested,\n        })\n    );\n\n    _callPropsCallbacks() {\n      const { columnCount, onItemsRendered, onScroll, rowCount } = this.props;\n\n      if (typeof onItemsRendered === 'function') {\n        if (columnCount > 0 && rowCount > 0) {\n          const [\n            overscanColumnStartIndex,\n            overscanColumnStopIndex,\n            visibleColumnStartIndex,\n            visibleColumnStopIndex,\n          ] = this._getHorizontalRangeToRender();\n          const [\n            overscanRowStartIndex,\n            overscanRowStopIndex,\n            visibleRowStartIndex,\n            visibleRowStopIndex,\n          ] = this._getVerticalRangeToRender();\n          this._callOnItemsRendered(\n            overscanColumnStartIndex,\n            overscanColumnStopIndex,\n            overscanRowStartIndex,\n            overscanRowStopIndex,\n            visibleColumnStartIndex,\n            visibleColumnStopIndex,\n            visibleRowStartIndex,\n            visibleRowStopIndex\n          );\n        }\n      }\n\n      if (typeof onScroll === 'function') {\n        const {\n          horizontalScrollDirection,\n          scrollLeft,\n          scrollTop,\n          scrollUpdateWasRequested,\n          verticalScrollDirection,\n        } = this.state;\n        this._callOnScroll(\n          scrollLeft,\n          scrollTop,\n          horizontalScrollDirection,\n          verticalScrollDirection,\n          scrollUpdateWasRequested\n        );\n      }\n    }\n\n    // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n    _getItemStyle: (rowIndex: number, columnIndex: number) => Object;\n    _getItemStyle = (rowIndex: number, columnIndex: number): Object => {\n      const { columnWidth, direction, rowHeight } = this.props;\n\n      const itemStyleCache = this._getItemStyleCache(\n        shouldResetStyleCacheOnItemSizeChange && columnWidth,\n        shouldResetStyleCacheOnItemSizeChange && direction,\n        shouldResetStyleCacheOnItemSizeChange && rowHeight\n      );\n\n      const key = `${rowIndex}:${columnIndex}`;\n\n      let style;\n      if (itemStyleCache.hasOwnProperty(key)) {\n        style = itemStyleCache[key];\n      } else {\n        const offset = getColumnOffset(\n          this.props,\n          columnIndex,\n          this._instanceProps\n        );\n        const isRtl = direction === 'rtl';\n        itemStyleCache[key] = style = {\n          position: 'absolute',\n          left: isRtl ? undefined : offset,\n          right: isRtl ? offset : undefined,\n          top: getRowOffset(this.props, rowIndex, this._instanceProps),\n          height: getRowHeight(this.props, rowIndex, this._instanceProps),\n          width: getColumnWidth(this.props, columnIndex, this._instanceProps),\n        };\n      }\n\n      return style;\n    };\n\n    _getItemStyleCache: (_: any, __: any, ___: any) => ItemStyleCache;\n    _getItemStyleCache = memoizeOne((_: any, __: any, ___: any) => ({}));\n\n    _getHorizontalRangeToRender(): [number, number, number, number] {\n      const {\n        columnCount,\n        overscanColumnCount,\n        overscanColumnsCount,\n        overscanCount,\n        rowCount,\n      } = this.props;\n      const { horizontalScrollDirection, isScrolling, scrollLeft } = this.state;\n\n      const overscanCountResolved: number =\n        overscanColumnCount || overscanColumnsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      const startIndex = getColumnStartIndexForOffset(\n        this.props,\n        scrollLeft,\n        this._instanceProps\n      );\n      const stopIndex = getColumnStopIndexForStartIndex(\n        this.props,\n        startIndex,\n        scrollLeft,\n        this._instanceProps\n      );\n\n      // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n      const overscanBackward =\n        !isScrolling || horizontalScrollDirection === 'backward'\n          ? Math.max(1, overscanCountResolved)\n          : 1;\n      const overscanForward =\n        !isScrolling || horizontalScrollDirection === 'forward'\n          ? Math.max(1, overscanCountResolved)\n          : 1;\n\n      return [\n        Math.max(0, startIndex - overscanBackward),\n        Math.max(0, Math.min(columnCount - 1, stopIndex + overscanForward)),\n        startIndex,\n        stopIndex,\n      ];\n    }\n\n    _getVerticalRangeToRender(): [number, number, number, number] {\n      const {\n        columnCount,\n        overscanCount,\n        overscanRowCount,\n        overscanRowsCount,\n        rowCount,\n      } = this.props;\n      const { isScrolling, verticalScrollDirection, scrollTop } = this.state;\n\n      const overscanCountResolved: number =\n        overscanRowCount || overscanRowsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      const startIndex = getRowStartIndexForOffset(\n        this.props,\n        scrollTop,\n        this._instanceProps\n      );\n      const stopIndex = getRowStopIndexForStartIndex(\n        this.props,\n        startIndex,\n        scrollTop,\n        this._instanceProps\n      );\n\n      // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n      const overscanBackward =\n        !isScrolling || verticalScrollDirection === 'backward'\n          ? Math.max(1, overscanCountResolved)\n          : 1;\n      const overscanForward =\n        !isScrolling || verticalScrollDirection === 'forward'\n          ? Math.max(1, overscanCountResolved)\n          : 1;\n\n      return [\n        Math.max(0, startIndex - overscanBackward),\n        Math.max(0, Math.min(rowCount - 1, stopIndex + overscanForward)),\n        startIndex,\n        stopIndex,\n      ];\n    }\n\n    _onScroll = (event: ScrollEvent): void => {\n      const {\n        clientHeight,\n        clientWidth,\n        scrollLeft,\n        scrollTop,\n        scrollHeight,\n        scrollWidth,\n      } = event.currentTarget;\n      this.setState(prevState => {\n        if (\n          prevState.scrollLeft === scrollLeft &&\n          prevState.scrollTop === scrollTop\n        ) {\n          // Scroll position may have been updated by cDM/cDU,\n          // In which case we don't need to trigger another render,\n          // And we don't want to update state.isScrolling.\n          return null;\n        }\n\n        const { direction } = this.props;\n\n        // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n        // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n        // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n        // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n        let calculatedScrollLeft = scrollLeft;\n        if (direction === 'rtl') {\n          switch (getRTLOffsetType()) {\n            case 'negative':\n              calculatedScrollLeft = -scrollLeft;\n              break;\n            case 'positive-descending':\n              calculatedScrollLeft = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        }\n\n        // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n        calculatedScrollLeft = Math.max(\n          0,\n          Math.min(calculatedScrollLeft, scrollWidth - clientWidth)\n        );\n        const calculatedScrollTop = Math.max(\n          0,\n          Math.min(scrollTop, scrollHeight - clientHeight)\n        );\n\n        return {\n          isScrolling: true,\n          horizontalScrollDirection:\n            prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n          scrollLeft: calculatedScrollLeft,\n          scrollTop: calculatedScrollTop,\n          verticalScrollDirection:\n            prevState.scrollTop < scrollTop ? 'forward' : 'backward',\n          scrollUpdateWasRequested: false,\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _outerRefSetter = (ref: any): void => {\n      const { outerRef } = this.props;\n\n      this._outerRef = ((ref: any): HTMLDivElement);\n\n      if (typeof outerRef === 'function') {\n        outerRef(ref);\n      } else if (\n        outerRef != null &&\n        typeof outerRef === 'object' &&\n        outerRef.hasOwnProperty('current')\n      ) {\n        outerRef.current = ref;\n      }\n    };\n\n    _resetIsScrollingDebounced = () => {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n\n      this._resetIsScrollingTimeoutId = requestTimeout(\n        this._resetIsScrolling,\n        IS_SCROLLING_DEBOUNCE_INTERVAL\n      );\n    };\n\n    _resetIsScrolling = () => {\n      this._resetIsScrollingTimeoutId = null;\n\n      this.setState({ isScrolling: false }, () => {\n        // Clear style cache after state update has been committed.\n        // This way we don't break pure sCU for items that don't use isScrolling param.\n        this._getItemStyleCache(-1);\n      });\n    };\n  };\n}\n\nconst validateSharedProps = (\n  {\n    children,\n    direction,\n    height,\n    innerTagName,\n    outerTagName,\n    overscanColumnsCount,\n    overscanCount,\n    overscanRowsCount,\n    width,\n  }: Props<any>,\n  { instance }: State\n): void => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof overscanCount === 'number') {\n      if (devWarningsOverscanCount && !devWarningsOverscanCount.has(instance)) {\n        devWarningsOverscanCount.add(instance);\n        console.warn(\n          'The overscanCount prop has been deprecated. ' +\n            'Please use the overscanColumnCount and overscanRowCount props instead.'\n        );\n      }\n    }\n\n    if (\n      typeof overscanColumnsCount === 'number' ||\n      typeof overscanRowsCount === 'number'\n    ) {\n      if (\n        devWarningsOverscanRowsColumnsCount &&\n        !devWarningsOverscanRowsColumnsCount.has(instance)\n      ) {\n        devWarningsOverscanRowsColumnsCount.add(instance);\n        console.warn(\n          'The overscanColumnsCount and overscanRowsCount props have been deprecated. ' +\n            'Please use the overscanColumnCount and overscanRowCount props instead.'\n        );\n      }\n    }\n\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName && !devWarningsTagName.has(instance)) {\n        devWarningsTagName.add(instance);\n        console.warn(\n          'The innerTagName and outerTagName props have been deprecated. ' +\n            'Please use the innerElementType and outerElementType props instead.'\n        );\n      }\n    }\n\n    if (children == null) {\n      throw Error(\n        'An invalid \"children\" prop has been specified. ' +\n          'Value should be a React component. ' +\n          `\"${children === null ? 'null' : typeof children}\" was specified.`\n      );\n    }\n\n    switch (direction) {\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n      default:\n        throw Error(\n          'An invalid \"direction\" prop has been specified. ' +\n            'Value should be either \"ltr\" or \"rtl\". ' +\n            `\"${direction}\" was specified.`\n        );\n    }\n\n    if (typeof width !== 'number') {\n      throw Error(\n        'An invalid \"width\" prop has been specified. ' +\n          'Grids must specify a number for width. ' +\n          `\"${width === null ? 'null' : typeof width}\" was specified.`\n      );\n    }\n\n    if (typeof height !== 'number') {\n      throw Error(\n        'An invalid \"height\" prop has been specified. ' +\n          'Grids must specify a number for height. ' +\n          `\"${height === null ? 'null' : typeof height}\" was specified.`\n      );\n    }\n  }\n};\n","// @flow\n\nimport createGridComponent from './createGridComponent';\n\nimport type { Props, ScrollToAlign } from './createGridComponent';\n\nconst DEFAULT_ESTIMATED_ITEM_SIZE = 50;\n\ntype VariableSizeProps = {|\n  estimatedColumnWidth: number,\n  estimatedRowHeight: number,\n  ...Props<any>,\n|};\n\ntype itemSizeGetter = (index: number) => number;\ntype ItemType = 'column' | 'row';\n\ntype ItemMetadata = {|\n  offset: number,\n  size: number,\n|};\ntype ItemMetadataMap = { [index: number]: ItemMetadata };\ntype InstanceProps = {|\n  columnMetadataMap: ItemMetadataMap,\n  estimatedColumnWidth: number,\n  estimatedRowHeight: number,\n  lastMeasuredColumnIndex: number,\n  lastMeasuredRowIndex: number,\n  rowMetadataMap: ItemMetadataMap,\n|};\n\nconst getEstimatedTotalHeight = (\n  { rowCount }: Props<any>,\n  { rowMetadataMap, estimatedRowHeight, lastMeasuredRowIndex }: InstanceProps\n) => {\n  let totalSizeOfMeasuredRows = 0;\n\n  // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n  if (lastMeasuredRowIndex >= rowCount) {\n    lastMeasuredRowIndex = rowCount - 1;\n  }\n\n  if (lastMeasuredRowIndex >= 0) {\n    const itemMetadata = rowMetadataMap[lastMeasuredRowIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  const numUnmeasuredItems = rowCount - lastMeasuredRowIndex - 1;\n  const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedRowHeight;\n\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nconst getEstimatedTotalWidth = (\n  { columnCount }: Props<any>,\n  {\n    columnMetadataMap,\n    estimatedColumnWidth,\n    lastMeasuredColumnIndex,\n  }: InstanceProps\n) => {\n  let totalSizeOfMeasuredRows = 0;\n\n  // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n  if (lastMeasuredColumnIndex >= columnCount) {\n    lastMeasuredColumnIndex = columnCount - 1;\n  }\n\n  if (lastMeasuredColumnIndex >= 0) {\n    const itemMetadata = columnMetadataMap[lastMeasuredColumnIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  const numUnmeasuredItems = columnCount - lastMeasuredColumnIndex - 1;\n  const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedColumnWidth;\n\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nconst getItemMetadata = (\n  itemType: ItemType,\n  props: Props<any>,\n  index: number,\n  instanceProps: InstanceProps\n): ItemMetadata => {\n  let itemMetadataMap, itemSize, lastMeasuredIndex;\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    itemSize = ((props.columnWidth: any): itemSizeGetter);\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    itemSize = ((props.rowHeight: any): itemSizeGetter);\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  if (index > lastMeasuredIndex) {\n    let offset = 0;\n    if (lastMeasuredIndex >= 0) {\n      const itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (let i = lastMeasuredIndex + 1; i <= index; i++) {\n      let size = itemSize(i);\n\n      itemMetadataMap[i] = {\n        offset,\n        size,\n      };\n\n      offset += size;\n    }\n\n    if (itemType === 'column') {\n      instanceProps.lastMeasuredColumnIndex = index;\n    } else {\n      instanceProps.lastMeasuredRowIndex = index;\n    }\n  }\n\n  return itemMetadataMap[index];\n};\n\nconst findNearestItem = (\n  itemType: ItemType,\n  props: Props<any>,\n  instanceProps: InstanceProps,\n  offset: number\n) => {\n  let itemMetadataMap, lastMeasuredIndex;\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  const lastMeasuredItemOffset =\n    lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch(\n      itemType,\n      props,\n      instanceProps,\n      lastMeasuredIndex,\n      0,\n      offset\n    );\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch(\n      itemType,\n      props,\n      instanceProps,\n      Math.max(0, lastMeasuredIndex),\n      offset\n    );\n  }\n};\n\nconst findNearestItemBinarySearch = (\n  itemType: ItemType,\n  props: Props<any>,\n  instanceProps: InstanceProps,\n  high: number,\n  low: number,\n  offset: number\n): number => {\n  while (low <= high) {\n    const middle = low + Math.floor((high - low) / 2);\n    const currentOffset = getItemMetadata(\n      itemType,\n      props,\n      middle,\n      instanceProps\n    ).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nconst findNearestItemExponentialSearch = (\n  itemType: ItemType,\n  props: Props<any>,\n  instanceProps: InstanceProps,\n  index: number,\n  offset: number\n): number => {\n  const itemCount = itemType === 'column' ? props.columnCount : props.rowCount;\n  let interval = 1;\n\n  while (\n    index < itemCount &&\n    getItemMetadata(itemType, props, index, instanceProps).offset < offset\n  ) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch(\n    itemType,\n    props,\n    instanceProps,\n    Math.min(index, itemCount - 1),\n    Math.floor(index / 2),\n    offset\n  );\n};\n\nconst getOffsetForIndexAndAlignment = (\n  itemType: ItemType,\n  props: Props<any>,\n  index: number,\n  align: ScrollToAlign,\n  scrollOffset: number,\n  instanceProps: InstanceProps,\n  scrollbarSize: number\n): number => {\n  const size = itemType === 'column' ? props.width : props.height;\n  const itemMetadata = getItemMetadata(itemType, props, index, instanceProps);\n\n  // Get estimated total size after ItemMetadata is computed,\n  // To ensure it reflects actual measurements instead of just estimates.\n  const estimatedTotalSize =\n    itemType === 'column'\n      ? getEstimatedTotalWidth(props, instanceProps)\n      : getEstimatedTotalHeight(props, instanceProps);\n\n  const maxOffset = Math.max(\n    0,\n    Math.min(estimatedTotalSize - size, itemMetadata.offset)\n  );\n  const minOffset = Math.max(\n    0,\n    itemMetadata.offset - size + scrollbarSize + itemMetadata.size\n  );\n\n  if (align === 'smart') {\n    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n      align = 'auto';\n    } else {\n      align = 'center';\n    }\n  }\n\n  switch (align) {\n    case 'start':\n      return maxOffset;\n    case 'end':\n      return minOffset;\n    case 'center':\n      return Math.round(minOffset + (maxOffset - minOffset) / 2);\n    case 'auto':\n    default:\n      if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n        return scrollOffset;\n      } else if (minOffset > maxOffset) {\n        // Because we only take into account the scrollbar size when calculating minOffset\n        // this value can be larger than maxOffset when at the end of the list\n        return minOffset;\n      } else if (scrollOffset < minOffset) {\n        return minOffset;\n      } else {\n        return maxOffset;\n      }\n  }\n};\n\nconst VariableSizeGrid = createGridComponent({\n  getColumnOffset: (\n    props: Props<any>,\n    index: number,\n    instanceProps: InstanceProps\n  ): number => getItemMetadata('column', props, index, instanceProps).offset,\n\n  getColumnStartIndexForOffset: (\n    props: Props<any>,\n    scrollLeft: number,\n    instanceProps: InstanceProps\n  ): number => findNearestItem('column', props, instanceProps, scrollLeft),\n\n  getColumnStopIndexForStartIndex: (\n    props: Props<any>,\n    startIndex: number,\n    scrollLeft: number,\n    instanceProps: InstanceProps\n  ): number => {\n    const { columnCount, width } = props;\n\n    const itemMetadata = getItemMetadata(\n      'column',\n      props,\n      startIndex,\n      instanceProps\n    );\n    const maxOffset = scrollLeft + width;\n\n    let offset = itemMetadata.offset + itemMetadata.size;\n    let stopIndex = startIndex;\n\n    while (stopIndex < columnCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata('column', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n\n  getColumnWidth: (\n    props: Props<any>,\n    index: number,\n    instanceProps: InstanceProps\n  ): number => instanceProps.columnMetadataMap[index].size,\n\n  getEstimatedTotalHeight,\n  getEstimatedTotalWidth,\n\n  getOffsetForColumnAndAlignment: (\n    props: Props<any>,\n    index: number,\n    align: ScrollToAlign,\n    scrollOffset: number,\n    instanceProps: InstanceProps,\n    scrollbarSize: number\n  ): number =>\n    getOffsetForIndexAndAlignment(\n      'column',\n      props,\n      index,\n      align,\n      scrollOffset,\n      instanceProps,\n      scrollbarSize\n    ),\n\n  getOffsetForRowAndAlignment: (\n    props: Props<any>,\n    index: number,\n    align: ScrollToAlign,\n    scrollOffset: number,\n    instanceProps: InstanceProps,\n    scrollbarSize: number\n  ): number =>\n    getOffsetForIndexAndAlignment(\n      'row',\n      props,\n      index,\n      align,\n      scrollOffset,\n      instanceProps,\n      scrollbarSize\n    ),\n\n  getRowOffset: (\n    props: Props<any>,\n    index: number,\n    instanceProps: InstanceProps\n  ): number => getItemMetadata('row', props, index, instanceProps).offset,\n\n  getRowHeight: (\n    props: Props<any>,\n    index: number,\n    instanceProps: InstanceProps\n  ): number => instanceProps.rowMetadataMap[index].size,\n\n  getRowStartIndexForOffset: (\n    props: Props<any>,\n    scrollTop: number,\n    instanceProps: InstanceProps\n  ): number => findNearestItem('row', props, instanceProps, scrollTop),\n\n  getRowStopIndexForStartIndex: (\n    props: Props<any>,\n    startIndex: number,\n    scrollTop: number,\n    instanceProps: InstanceProps\n  ): number => {\n    const { rowCount, height } = props;\n\n    const itemMetadata = getItemMetadata(\n      'row',\n      props,\n      startIndex,\n      instanceProps\n    );\n    const maxOffset = scrollTop + height;\n\n    let offset = itemMetadata.offset + itemMetadata.size;\n    let stopIndex = startIndex;\n\n    while (stopIndex < rowCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata('row', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n\n  initInstanceProps(props: Props<any>, instance: any): InstanceProps {\n    const {\n      estimatedColumnWidth,\n      estimatedRowHeight,\n    } = ((props: any): VariableSizeProps);\n\n    const instanceProps = {\n      columnMetadataMap: {},\n      estimatedColumnWidth: estimatedColumnWidth || DEFAULT_ESTIMATED_ITEM_SIZE,\n      estimatedRowHeight: estimatedRowHeight || DEFAULT_ESTIMATED_ITEM_SIZE,\n      lastMeasuredColumnIndex: -1,\n      lastMeasuredRowIndex: -1,\n      rowMetadataMap: {},\n    };\n\n    instance.resetAfterColumnIndex = (\n      columnIndex: number,\n      shouldForceUpdate?: boolean = true\n    ) => {\n      instance.resetAfterIndices({ columnIndex, shouldForceUpdate });\n    };\n\n    instance.resetAfterRowIndex = (\n      rowIndex: number,\n      shouldForceUpdate?: boolean = true\n    ) => {\n      instance.resetAfterIndices({ rowIndex, shouldForceUpdate });\n    };\n\n    instance.resetAfterIndices = ({\n      columnIndex,\n      rowIndex,\n      shouldForceUpdate = true,\n    }: {\n      columnIndex?: number,\n      rowIndex?: number,\n      shouldForceUpdate: boolean,\n    }) => {\n      if (typeof columnIndex === 'number') {\n        instanceProps.lastMeasuredColumnIndex = Math.min(\n          instanceProps.lastMeasuredColumnIndex,\n          columnIndex - 1\n        );\n      }\n      if (typeof rowIndex === 'number') {\n        instanceProps.lastMeasuredRowIndex = Math.min(\n          instanceProps.lastMeasuredRowIndex,\n          rowIndex - 1\n        );\n      }\n\n      // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n\n  shouldResetStyleCacheOnItemSizeChange: false,\n\n  validateProps: ({ columnWidth, rowHeight }: Props<any>): void => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'function') {\n        throw Error(\n          'An invalid \"columnWidth\" prop has been specified. ' +\n            'Value should be a function. ' +\n            `\"${\n              columnWidth === null ? 'null' : typeof columnWidth\n            }\" was specified.`\n        );\n      } else if (typeof rowHeight !== 'function') {\n        throw Error(\n          'An invalid \"rowHeight\" prop has been specified. ' +\n            'Value should be a function. ' +\n            `\"${rowHeight === null ? 'null' : typeof rowHeight}\" was specified.`\n        );\n      }\n    }\n  },\n});\n\nexport default VariableSizeGrid;\n","// @flow\n\nimport memoizeOne from 'memoize-one';\nimport { createElement, PureComponent } from 'react';\nimport { cancelTimeout, requestTimeout } from './timer';\nimport { getRTLOffsetType } from './domHelpers';\n\nimport type { TimeoutID } from './timer';\n\nexport type ScrollToAlign = 'auto' | 'smart' | 'center' | 'start' | 'end';\n\ntype itemSize = number | ((index: number) => number);\n// TODO Deprecate directions \"horizontal\" and \"vertical\"\ntype Direction = 'ltr' | 'rtl' | 'horizontal' | 'vertical';\ntype Layout = 'horizontal' | 'vertical';\n\ntype RenderComponentProps<T> = {|\n  data: T,\n  index: number,\n  isScrolling?: boolean,\n  style: Object,\n|};\ntype RenderComponent<T> = React$ComponentType<$Shape<RenderComponentProps<T>>>;\n\ntype ScrollDirection = 'forward' | 'backward';\n\ntype onItemsRenderedCallback = ({\n  overscanStartIndex: number,\n  overscanStopIndex: number,\n  visibleStartIndex: number,\n  visibleStopIndex: number,\n}) => void;\ntype onScrollCallback = ({\n  scrollDirection: ScrollDirection,\n  scrollOffset: number,\n  scrollUpdateWasRequested: boolean,\n}) => void;\n\ntype ScrollEvent = SyntheticEvent<HTMLDivElement>;\ntype ItemStyleCache = { [index: number]: Object };\n\ntype OuterProps = {|\n  children: React$Node,\n  className: string | void,\n  onScroll: ScrollEvent => void,\n  style: {\n    [string]: mixed,\n  },\n|};\n\ntype InnerProps = {|\n  children: React$Node,\n  style: {\n    [string]: mixed,\n  },\n|};\n\nexport type Props<T> = {|\n  children: RenderComponent<T>,\n  className?: string,\n  direction: Direction,\n  height: number | string,\n  initialScrollOffset?: number,\n  innerRef?: any,\n  innerElementType?: string | React$AbstractComponent<InnerProps, any>,\n  innerTagName?: string, // deprecated\n  itemCount: number,\n  itemData: T,\n  itemKey?: (index: number, data: T) => any,\n  itemSize: itemSize,\n  layout: Layout,\n  onItemsRendered?: onItemsRenderedCallback,\n  onScroll?: onScrollCallback,\n  outerRef?: any,\n  outerElementType?: string | React$AbstractComponent<OuterProps, any>,\n  outerTagName?: string, // deprecated\n  overscanCount: number,\n  style?: Object,\n  useIsScrolling: boolean,\n  width: number | string,\n|};\n\ntype State = {|\n  instance: any,\n  isScrolling: boolean,\n  scrollDirection: ScrollDirection,\n  scrollOffset: number,\n  scrollUpdateWasRequested: boolean,\n|};\n\ntype GetItemOffset = (\n  props: Props<any>,\n  index: number,\n  instanceProps: any\n) => number;\ntype GetItemSize = (\n  props: Props<any>,\n  index: number,\n  instanceProps: any\n) => number;\ntype GetEstimatedTotalSize = (props: Props<any>, instanceProps: any) => number;\ntype GetOffsetForIndexAndAlignment = (\n  props: Props<any>,\n  index: number,\n  align: ScrollToAlign,\n  scrollOffset: number,\n  instanceProps: any\n) => number;\ntype GetStartIndexForOffset = (\n  props: Props<any>,\n  offset: number,\n  instanceProps: any\n) => number;\ntype GetStopIndexForStartIndex = (\n  props: Props<any>,\n  startIndex: number,\n  scrollOffset: number,\n  instanceProps: any\n) => number;\ntype InitInstanceProps = (props: Props<any>, instance: any) => any;\ntype ValidateProps = (props: Props<any>) => void;\n\nconst IS_SCROLLING_DEBOUNCE_INTERVAL = 150;\n\nconst defaultItemKey = (index: number, data: any) => index;\n\n// In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\nlet devWarningsDirection = null;\nlet devWarningsTagName = null;\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsDirection = new WeakSet();\n    devWarningsTagName = new WeakSet();\n  }\n}\n\nexport default function createListComponent({\n  getItemOffset,\n  getEstimatedTotalSize,\n  getItemSize,\n  getOffsetForIndexAndAlignment,\n  getStartIndexForOffset,\n  getStopIndexForStartIndex,\n  initInstanceProps,\n  shouldResetStyleCacheOnItemSizeChange,\n  validateProps,\n}: {|\n  getItemOffset: GetItemOffset,\n  getEstimatedTotalSize: GetEstimatedTotalSize,\n  getItemSize: GetItemSize,\n  getOffsetForIndexAndAlignment: GetOffsetForIndexAndAlignment,\n  getStartIndexForOffset: GetStartIndexForOffset,\n  getStopIndexForStartIndex: GetStopIndexForStartIndex,\n  initInstanceProps: InitInstanceProps,\n  shouldResetStyleCacheOnItemSizeChange: boolean,\n  validateProps: ValidateProps,\n|}) {\n  return class List<T> extends PureComponent<Props<T>, State> {\n    _instanceProps: any = initInstanceProps(this.props, this);\n    _outerRef: ?HTMLDivElement;\n    _resetIsScrollingTimeoutId: TimeoutID | null = null;\n\n    static defaultProps = {\n      direction: 'ltr',\n      itemData: undefined,\n      layout: 'vertical',\n      overscanCount: 2,\n      useIsScrolling: false,\n    };\n\n    state: State = {\n      instance: this,\n      isScrolling: false,\n      scrollDirection: 'forward',\n      scrollOffset:\n        typeof this.props.initialScrollOffset === 'number'\n          ? this.props.initialScrollOffset\n          : 0,\n      scrollUpdateWasRequested: false,\n    };\n\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    constructor(props: Props<T>) {\n      super(props);\n    }\n\n    static getDerivedStateFromProps(\n      nextProps: Props<T>,\n      prevState: State\n    ): $Shape<State> | null {\n      validateSharedProps(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    }\n\n    scrollTo(scrollOffset: number): void {\n      scrollOffset = Math.max(0, scrollOffset);\n\n      this.setState(prevState => {\n        if (prevState.scrollOffset === scrollOffset) {\n          return null;\n        }\n        return {\n          scrollDirection:\n            prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n          scrollOffset: scrollOffset,\n          scrollUpdateWasRequested: true,\n        };\n      }, this._resetIsScrollingDebounced);\n    }\n\n    scrollToItem(index: number, align: ScrollToAlign = 'auto'): void {\n      const { itemCount } = this.props;\n      const { scrollOffset } = this.state;\n\n      index = Math.max(0, Math.min(index, itemCount - 1));\n\n      this.scrollTo(\n        getOffsetForIndexAndAlignment(\n          this.props,\n          index,\n          align,\n          scrollOffset,\n          this._instanceProps\n        )\n      );\n    }\n\n    componentDidMount() {\n      const { direction, initialScrollOffset, layout } = this.props;\n\n      if (typeof initialScrollOffset === 'number' && this._outerRef != null) {\n        const outerRef = ((this._outerRef: any): HTMLElement);\n        // TODO Deprecate direction \"horizontal\"\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          outerRef.scrollLeft = initialScrollOffset;\n        } else {\n          outerRef.scrollTop = initialScrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    }\n\n    componentDidUpdate() {\n      const { direction, layout } = this.props;\n      const { scrollOffset, scrollUpdateWasRequested } = this.state;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        const outerRef = ((this._outerRef: any): HTMLElement);\n\n        // TODO Deprecate direction \"horizontal\"\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          if (direction === 'rtl') {\n            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n            // So we need to determine which browser behavior we're dealing with, and mimic it.\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                outerRef.scrollLeft = -scrollOffset;\n                break;\n              case 'positive-ascending':\n                outerRef.scrollLeft = scrollOffset;\n                break;\n              default:\n                const { clientWidth, scrollWidth } = outerRef;\n                outerRef.scrollLeft = scrollWidth - clientWidth - scrollOffset;\n                break;\n            }\n          } else {\n            outerRef.scrollLeft = scrollOffset;\n          }\n        } else {\n          outerRef.scrollTop = scrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    }\n\n    componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    }\n\n    render() {\n      const {\n        children,\n        className,\n        direction,\n        height,\n        innerRef,\n        innerElementType,\n        innerTagName,\n        itemCount,\n        itemData,\n        itemKey = defaultItemKey,\n        layout,\n        outerElementType,\n        outerTagName,\n        style,\n        useIsScrolling,\n        width,\n      } = this.props;\n      const { isScrolling } = this.state;\n\n      // TODO Deprecate direction \"horizontal\"\n      const isHorizontal =\n        direction === 'horizontal' || layout === 'horizontal';\n\n      const onScroll = isHorizontal\n        ? this._onScrollHorizontal\n        : this._onScrollVertical;\n\n      const [startIndex, stopIndex] = this._getRangeToRender();\n\n      const items = [];\n      if (itemCount > 0) {\n        for (let index = startIndex; index <= stopIndex; index++) {\n          items.push(\n            createElement(children, {\n              data: itemData,\n              key: itemKey(index, itemData),\n              index,\n              isScrolling: useIsScrolling ? isScrolling : undefined,\n              style: this._getItemStyle(index),\n            })\n          );\n        }\n      }\n\n      // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n      const estimatedTotalSize = getEstimatedTotalSize(\n        this.props,\n        this._instanceProps\n      );\n\n      return createElement(\n        outerElementType || outerTagName || 'div',\n        {\n          className,\n          onScroll,\n          ref: this._outerRefSetter,\n          style: {\n            position: 'relative',\n            height,\n            width,\n            overflow: 'auto',\n            WebkitOverflowScrolling: 'touch',\n            willChange: 'transform',\n            direction,\n            ...style,\n          },\n        },\n        createElement(innerElementType || innerTagName || 'div', {\n          children: items,\n          ref: innerRef,\n          style: {\n            height: isHorizontal ? '100%' : estimatedTotalSize,\n            pointerEvents: isScrolling ? 'none' : undefined,\n            width: isHorizontal ? estimatedTotalSize : '100%',\n          },\n        })\n      );\n    }\n\n    _callOnItemsRendered: (\n      overscanStartIndex: number,\n      overscanStopIndex: number,\n      visibleStartIndex: number,\n      visibleStopIndex: number\n    ) => void;\n    _callOnItemsRendered = memoizeOne(\n      (\n        overscanStartIndex: number,\n        overscanStopIndex: number,\n        visibleStartIndex: number,\n        visibleStopIndex: number\n      ) =>\n        ((this.props.onItemsRendered: any): onItemsRenderedCallback)({\n          overscanStartIndex,\n          overscanStopIndex,\n          visibleStartIndex,\n          visibleStopIndex,\n        })\n    );\n\n    _callOnScroll: (\n      scrollDirection: ScrollDirection,\n      scrollOffset: number,\n      scrollUpdateWasRequested: boolean\n    ) => void;\n    _callOnScroll = memoizeOne(\n      (\n        scrollDirection: ScrollDirection,\n        scrollOffset: number,\n        scrollUpdateWasRequested: boolean\n      ) =>\n        ((this.props.onScroll: any): onScrollCallback)({\n          scrollDirection,\n          scrollOffset,\n          scrollUpdateWasRequested,\n        })\n    );\n\n    _callPropsCallbacks() {\n      if (typeof this.props.onItemsRendered === 'function') {\n        const { itemCount } = this.props;\n        if (itemCount > 0) {\n          const [\n            overscanStartIndex,\n            overscanStopIndex,\n            visibleStartIndex,\n            visibleStopIndex,\n          ] = this._getRangeToRender();\n          this._callOnItemsRendered(\n            overscanStartIndex,\n            overscanStopIndex,\n            visibleStartIndex,\n            visibleStopIndex\n          );\n        }\n      }\n\n      if (typeof this.props.onScroll === 'function') {\n        const {\n          scrollDirection,\n          scrollOffset,\n          scrollUpdateWasRequested,\n        } = this.state;\n        this._callOnScroll(\n          scrollDirection,\n          scrollOffset,\n          scrollUpdateWasRequested\n        );\n      }\n    }\n\n    // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n    _getItemStyle: (index: number) => Object;\n    _getItemStyle = (index: number): Object => {\n      const { direction, itemSize, layout } = this.props;\n\n      const itemStyleCache = this._getItemStyleCache(\n        shouldResetStyleCacheOnItemSizeChange && itemSize,\n        shouldResetStyleCacheOnItemSizeChange && layout,\n        shouldResetStyleCacheOnItemSizeChange && direction\n      );\n\n      let style;\n      if (itemStyleCache.hasOwnProperty(index)) {\n        style = itemStyleCache[index];\n      } else {\n        const offset = getItemOffset(this.props, index, this._instanceProps);\n        const size = getItemSize(this.props, index, this._instanceProps);\n\n        // TODO Deprecate direction \"horizontal\"\n        const isHorizontal =\n          direction === 'horizontal' || layout === 'horizontal';\n\n        const isRtl = direction === 'rtl';\n        const offsetHorizontal = isHorizontal ? offset : 0;\n        itemStyleCache[index] = style = {\n          position: 'absolute',\n          left: isRtl ? undefined : offsetHorizontal,\n          right: isRtl ? offsetHorizontal : undefined,\n          top: !isHorizontal ? offset : 0,\n          height: !isHorizontal ? size : '100%',\n          width: isHorizontal ? size : '100%',\n        };\n      }\n\n      return style;\n    };\n\n    _getItemStyleCache: (_: any, __: any, ___: any) => ItemStyleCache;\n    _getItemStyleCache = memoizeOne((_: any, __: any, ___: any) => ({}));\n\n    _getRangeToRender(): [number, number, number, number] {\n      const { itemCount, overscanCount } = this.props;\n      const { isScrolling, scrollDirection, scrollOffset } = this.state;\n\n      if (itemCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      const startIndex = getStartIndexForOffset(\n        this.props,\n        scrollOffset,\n        this._instanceProps\n      );\n      const stopIndex = getStopIndexForStartIndex(\n        this.props,\n        startIndex,\n        scrollOffset,\n        this._instanceProps\n      );\n\n      // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n      const overscanBackward =\n        !isScrolling || scrollDirection === 'backward'\n          ? Math.max(1, overscanCount)\n          : 1;\n      const overscanForward =\n        !isScrolling || scrollDirection === 'forward'\n          ? Math.max(1, overscanCount)\n          : 1;\n\n      return [\n        Math.max(0, startIndex - overscanBackward),\n        Math.max(0, Math.min(itemCount - 1, stopIndex + overscanForward)),\n        startIndex,\n        stopIndex,\n      ];\n    }\n\n    _onScrollHorizontal = (event: ScrollEvent): void => {\n      const { clientWidth, scrollLeft, scrollWidth } = event.currentTarget;\n      this.setState(prevState => {\n        if (prevState.scrollOffset === scrollLeft) {\n          // Scroll position may have been updated by cDM/cDU,\n          // In which case we don't need to trigger another render,\n          // And we don't want to update state.isScrolling.\n          return null;\n        }\n\n        const { direction } = this.props;\n\n        let scrollOffset = scrollLeft;\n        if (direction === 'rtl') {\n          // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n          // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n          // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n          // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n          switch (getRTLOffsetType()) {\n            case 'negative':\n              scrollOffset = -scrollLeft;\n              break;\n            case 'positive-descending':\n              scrollOffset = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        }\n\n        // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n        scrollOffset = Math.max(\n          0,\n          Math.min(scrollOffset, scrollWidth - clientWidth)\n        );\n\n        return {\n          isScrolling: true,\n          scrollDirection:\n            prevState.scrollOffset < scrollLeft ? 'forward' : 'backward',\n          scrollOffset,\n          scrollUpdateWasRequested: false,\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _onScrollVertical = (event: ScrollEvent): void => {\n      const { clientHeight, scrollHeight, scrollTop } = event.currentTarget;\n      this.setState(prevState => {\n        if (prevState.scrollOffset === scrollTop) {\n          // Scroll position may have been updated by cDM/cDU,\n          // In which case we don't need to trigger another render,\n          // And we don't want to update state.isScrolling.\n          return null;\n        }\n\n        // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n        const scrollOffset = Math.max(\n          0,\n          Math.min(scrollTop, scrollHeight - clientHeight)\n        );\n\n        return {\n          isScrolling: true,\n          scrollDirection:\n            prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n          scrollOffset,\n          scrollUpdateWasRequested: false,\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _outerRefSetter = (ref: any): void => {\n      const { outerRef } = this.props;\n\n      this._outerRef = ((ref: any): HTMLDivElement);\n\n      if (typeof outerRef === 'function') {\n        outerRef(ref);\n      } else if (\n        outerRef != null &&\n        typeof outerRef === 'object' &&\n        outerRef.hasOwnProperty('current')\n      ) {\n        outerRef.current = ref;\n      }\n    };\n\n    _resetIsScrollingDebounced = () => {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n\n      this._resetIsScrollingTimeoutId = requestTimeout(\n        this._resetIsScrolling,\n        IS_SCROLLING_DEBOUNCE_INTERVAL\n      );\n    };\n\n    _resetIsScrolling = () => {\n      this._resetIsScrollingTimeoutId = null;\n\n      this.setState({ isScrolling: false }, () => {\n        // Clear style cache after state update has been committed.\n        // This way we don't break pure sCU for items that don't use isScrolling param.\n        this._getItemStyleCache(-1, null);\n      });\n    };\n  };\n}\n\n// NOTE: I considered further wrapping individual items with a pure ListItem component.\n// This would avoid ever calling the render function for the same index more than once,\n// But it would also add the overhead of a lot of components/fibers.\n// I assume people already do this (render function returning a class component),\n// So my doing it would just unnecessarily double the wrappers.\n\nconst validateSharedProps = (\n  {\n    children,\n    direction,\n    height,\n    layout,\n    innerTagName,\n    outerTagName,\n    width,\n  }: Props<any>,\n  { instance }: State\n): void => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName && !devWarningsTagName.has(instance)) {\n        devWarningsTagName.add(instance);\n        console.warn(\n          'The innerTagName and outerTagName props have been deprecated. ' +\n            'Please use the innerElementType and outerElementType props instead.'\n        );\n      }\n    }\n\n    // TODO Deprecate direction \"horizontal\"\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n\n    switch (direction) {\n      case 'horizontal':\n      case 'vertical':\n        if (devWarningsDirection && !devWarningsDirection.has(instance)) {\n          devWarningsDirection.add(instance);\n          console.warn(\n            'The direction prop should be either \"ltr\" (default) or \"rtl\". ' +\n              'Please use the layout prop to specify \"vertical\" (default) or \"horizontal\" orientation.'\n          );\n        }\n        break;\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n      default:\n        throw Error(\n          'An invalid \"direction\" prop has been specified. ' +\n            'Value should be either \"ltr\" or \"rtl\". ' +\n            `\"${direction}\" was specified.`\n        );\n    }\n\n    switch (layout) {\n      case 'horizontal':\n      case 'vertical':\n        // Valid values\n        break;\n      default:\n        throw Error(\n          'An invalid \"layout\" prop has been specified. ' +\n            'Value should be either \"horizontal\" or \"vertical\". ' +\n            `\"${layout}\" was specified.`\n        );\n    }\n\n    if (children == null) {\n      throw Error(\n        'An invalid \"children\" prop has been specified. ' +\n          'Value should be a React component. ' +\n          `\"${children === null ? 'null' : typeof children}\" was specified.`\n      );\n    }\n\n    if (isHorizontal && typeof width !== 'number') {\n      throw Error(\n        'An invalid \"width\" prop has been specified. ' +\n          'Horizontal lists must specify a number for width. ' +\n          `\"${width === null ? 'null' : typeof width}\" was specified.`\n      );\n    } else if (!isHorizontal && typeof height !== 'number') {\n      throw Error(\n        'An invalid \"height\" prop has been specified. ' +\n          'Vertical lists must specify a number for height. ' +\n          `\"${height === null ? 'null' : typeof height}\" was specified.`\n      );\n    }\n  }\n};\n","// @flow\n\nimport createListComponent from './createListComponent';\n\nimport type { Props, ScrollToAlign } from './createListComponent';\n\nconst DEFAULT_ESTIMATED_ITEM_SIZE = 50;\n\ntype VariableSizeProps = {|\n  estimatedItemSize: number,\n  ...Props<any>,\n|};\n\ntype itemSizeGetter = (index: number) => number;\n\ntype ItemMetadata = {|\n  offset: number,\n  size: number,\n|};\ntype InstanceProps = {|\n  itemMetadataMap: { [index: number]: ItemMetadata },\n  estimatedItemSize: number,\n  lastMeasuredIndex: number,\n|};\n\nconst getItemMetadata = (\n  props: Props<any>,\n  index: number,\n  instanceProps: InstanceProps\n): ItemMetadata => {\n  const { itemSize } = ((props: any): VariableSizeProps);\n  const { itemMetadataMap, lastMeasuredIndex } = instanceProps;\n\n  if (index > lastMeasuredIndex) {\n    let offset = 0;\n    if (lastMeasuredIndex >= 0) {\n      const itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (let i = lastMeasuredIndex + 1; i <= index; i++) {\n      let size = ((itemSize: any): itemSizeGetter)(i);\n\n      itemMetadataMap[i] = {\n        offset,\n        size,\n      };\n\n      offset += size;\n    }\n\n    instanceProps.lastMeasuredIndex = index;\n  }\n\n  return itemMetadataMap[index];\n};\n\nconst findNearestItem = (\n  props: Props<any>,\n  instanceProps: InstanceProps,\n  offset: number\n) => {\n  const { itemMetadataMap, lastMeasuredIndex } = instanceProps;\n\n  const lastMeasuredItemOffset =\n    lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch(\n      props,\n      instanceProps,\n      lastMeasuredIndex,\n      0,\n      offset\n    );\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch(\n      props,\n      instanceProps,\n      Math.max(0, lastMeasuredIndex),\n      offset\n    );\n  }\n};\n\nconst findNearestItemBinarySearch = (\n  props: Props<any>,\n  instanceProps: InstanceProps,\n  high: number,\n  low: number,\n  offset: number\n): number => {\n  while (low <= high) {\n    const middle = low + Math.floor((high - low) / 2);\n    const currentOffset = getItemMetadata(props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nconst findNearestItemExponentialSearch = (\n  props: Props<any>,\n  instanceProps: InstanceProps,\n  index: number,\n  offset: number\n): number => {\n  const { itemCount } = props;\n  let interval = 1;\n\n  while (\n    index < itemCount &&\n    getItemMetadata(props, index, instanceProps).offset < offset\n  ) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch(\n    props,\n    instanceProps,\n    Math.min(index, itemCount - 1),\n    Math.floor(index / 2),\n    offset\n  );\n};\n\nconst getEstimatedTotalSize = (\n  { itemCount }: Props<any>,\n  { itemMetadataMap, estimatedItemSize, lastMeasuredIndex }: InstanceProps\n) => {\n  let totalSizeOfMeasuredItems = 0;\n\n  // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n  if (lastMeasuredIndex >= itemCount) {\n    lastMeasuredIndex = itemCount - 1;\n  }\n\n  if (lastMeasuredIndex >= 0) {\n    const itemMetadata = itemMetadataMap[lastMeasuredIndex];\n    totalSizeOfMeasuredItems = itemMetadata.offset + itemMetadata.size;\n  }\n\n  const numUnmeasuredItems = itemCount - lastMeasuredIndex - 1;\n  const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;\n\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;\n};\n\nconst VariableSizeList = createListComponent({\n  getItemOffset: (\n    props: Props<any>,\n    index: number,\n    instanceProps: InstanceProps\n  ): number => getItemMetadata(props, index, instanceProps).offset,\n\n  getItemSize: (\n    props: Props<any>,\n    index: number,\n    instanceProps: InstanceProps\n  ): number => instanceProps.itemMetadataMap[index].size,\n\n  getEstimatedTotalSize,\n\n  getOffsetForIndexAndAlignment: (\n    props: Props<any>,\n    index: number,\n    align: ScrollToAlign,\n    scrollOffset: number,\n    instanceProps: InstanceProps\n  ): number => {\n    const { direction, height, layout, width } = props;\n\n    // TODO Deprecate direction \"horizontal\"\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    const size = (((isHorizontal ? width : height): any): number);\n    const itemMetadata = getItemMetadata(props, index, instanceProps);\n\n    // Get estimated total size after ItemMetadata is computed,\n    // To ensure it reflects actual measurements instead of just estimates.\n    const estimatedTotalSize = getEstimatedTotalSize(props, instanceProps);\n\n    const maxOffset = Math.max(\n      0,\n      Math.min(estimatedTotalSize - size, itemMetadata.offset)\n    );\n    const minOffset = Math.max(\n      0,\n      itemMetadata.offset - size + itemMetadata.size\n    );\n\n    if (align === 'smart') {\n      if (\n        scrollOffset >= minOffset - size &&\n        scrollOffset <= maxOffset + size\n      ) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n      case 'end':\n        return minOffset;\n      case 'center':\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n    }\n  },\n\n  getStartIndexForOffset: (\n    props: Props<any>,\n    offset: number,\n    instanceProps: InstanceProps\n  ): number => findNearestItem(props, instanceProps, offset),\n\n  getStopIndexForStartIndex: (\n    props: Props<any>,\n    startIndex: number,\n    scrollOffset: number,\n    instanceProps: InstanceProps\n  ): number => {\n    const { direction, height, itemCount, layout, width } = props;\n\n    // TODO Deprecate direction \"horizontal\"\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    const size = (((isHorizontal ? width : height): any): number);\n    const itemMetadata = getItemMetadata(props, startIndex, instanceProps);\n    const maxOffset = scrollOffset + size;\n\n    let offset = itemMetadata.offset + itemMetadata.size;\n    let stopIndex = startIndex;\n\n    while (stopIndex < itemCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata(props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n\n  initInstanceProps(props: Props<any>, instance: any): InstanceProps {\n    const { estimatedItemSize } = ((props: any): VariableSizeProps);\n\n    const instanceProps = {\n      itemMetadataMap: {},\n      estimatedItemSize: estimatedItemSize || DEFAULT_ESTIMATED_ITEM_SIZE,\n      lastMeasuredIndex: -1,\n    };\n\n    instance.resetAfterIndex = (\n      index: number,\n      shouldForceUpdate?: boolean = true\n    ) => {\n      instanceProps.lastMeasuredIndex = Math.min(\n        instanceProps.lastMeasuredIndex,\n        index - 1\n      );\n\n      // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n\n  shouldResetStyleCacheOnItemSizeChange: false,\n\n  validateProps: ({ itemSize }: Props<any>): void => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'function') {\n        throw Error(\n          'An invalid \"itemSize\" prop has been specified. ' +\n            'Value should be a function. ' +\n            `\"${itemSize === null ? 'null' : typeof itemSize}\" was specified.`\n        );\n      }\n    }\n  },\n});\n\nexport default VariableSizeList;\n","// @flow\n\nimport createGridComponent from './createGridComponent';\n\nimport type { Props, ScrollToAlign } from './createGridComponent';\n\nconst FixedSizeGrid = createGridComponent({\n  getColumnOffset: ({ columnWidth }: Props<any>, index: number): number =>\n    index * ((columnWidth: any): number),\n\n  getColumnWidth: ({ columnWidth }: Props<any>, index: number): number =>\n    ((columnWidth: any): number),\n\n  getRowOffset: ({ rowHeight }: Props<any>, index: number): number =>\n    index * ((rowHeight: any): number),\n\n  getRowHeight: ({ rowHeight }: Props<any>, index: number): number =>\n    ((rowHeight: any): number),\n\n  getEstimatedTotalHeight: ({ rowCount, rowHeight }: Props<any>) =>\n    ((rowHeight: any): number) * rowCount,\n\n  getEstimatedTotalWidth: ({ columnCount, columnWidth }: Props<any>) =>\n    ((columnWidth: any): number) * columnCount,\n\n  getOffsetForColumnAndAlignment: (\n    { columnCount, columnWidth, width }: Props<any>,\n    columnIndex: number,\n    align: ScrollToAlign,\n    scrollLeft: number,\n    instanceProps: typeof undefined,\n    scrollbarSize: number\n  ): number => {\n    const lastColumnOffset = Math.max(\n      0,\n      columnCount * ((columnWidth: any): number) - width\n    );\n    const maxOffset = Math.min(\n      lastColumnOffset,\n      columnIndex * ((columnWidth: any): number)\n    );\n    const minOffset = Math.max(\n      0,\n      columnIndex * ((columnWidth: any): number) -\n        width +\n        scrollbarSize +\n        ((columnWidth: any): number)\n    );\n\n    if (align === 'smart') {\n      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n      case 'end':\n        return minOffset;\n      case 'center':\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        const middleOffset = Math.round(\n          minOffset + (maxOffset - minOffset) / 2\n        );\n        if (middleOffset < Math.ceil(width / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {\n          return lastColumnOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n      case 'auto':\n      default:\n        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {\n          return scrollLeft;\n        } else if (minOffset > maxOffset) {\n          // Because we only take into account the scrollbar size when calculating minOffset\n          // this value can be larger than maxOffset when at the end of the list\n          return minOffset;\n        } else if (scrollLeft < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n    }\n  },\n\n  getOffsetForRowAndAlignment: (\n    { rowHeight, height, rowCount }: Props<any>,\n    rowIndex: number,\n    align: ScrollToAlign,\n    scrollTop: number,\n    instanceProps: typeof undefined,\n    scrollbarSize: number\n  ): number => {\n    const lastRowOffset = Math.max(\n      0,\n      rowCount * ((rowHeight: any): number) - height\n    );\n    const maxOffset = Math.min(\n      lastRowOffset,\n      rowIndex * ((rowHeight: any): number)\n    );\n    const minOffset = Math.max(\n      0,\n      rowIndex * ((rowHeight: any): number) -\n        height +\n        scrollbarSize +\n        ((rowHeight: any): number)\n    );\n\n    if (align === 'smart') {\n      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n      case 'end':\n        return minOffset;\n      case 'center':\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        const middleOffset = Math.round(\n          minOffset + (maxOffset - minOffset) / 2\n        );\n        if (middleOffset < Math.ceil(height / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {\n          return lastRowOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n      case 'auto':\n      default:\n        if (scrollTop >= minOffset && scrollTop <= maxOffset) {\n          return scrollTop;\n        } else if (minOffset > maxOffset) {\n          // Because we only take into account the scrollbar size when calculating minOffset\n          // this value can be larger than maxOffset when at the end of the list\n          return minOffset;\n        } else if (scrollTop < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n    }\n  },\n\n  getColumnStartIndexForOffset: (\n    { columnWidth, columnCount }: Props<any>,\n    scrollLeft: number\n  ): number =>\n    Math.max(\n      0,\n      Math.min(\n        columnCount - 1,\n        Math.floor(scrollLeft / ((columnWidth: any): number))\n      )\n    ),\n\n  getColumnStopIndexForStartIndex: (\n    { columnWidth, columnCount, width }: Props<any>,\n    startIndex: number,\n    scrollLeft: number\n  ): number => {\n    const left = startIndex * ((columnWidth: any): number);\n    const numVisibleColumns = Math.ceil(\n      (width + scrollLeft - left) / ((columnWidth: any): number)\n    );\n    return Math.max(\n      0,\n      Math.min(\n        columnCount - 1,\n        startIndex + numVisibleColumns - 1 // -1 is because stop index is inclusive\n      )\n    );\n  },\n\n  getRowStartIndexForOffset: (\n    { rowHeight, rowCount }: Props<any>,\n    scrollTop: number\n  ): number =>\n    Math.max(\n      0,\n      Math.min(rowCount - 1, Math.floor(scrollTop / ((rowHeight: any): number)))\n    ),\n\n  getRowStopIndexForStartIndex: (\n    { rowHeight, rowCount, height }: Props<any>,\n    startIndex: number,\n    scrollTop: number\n  ): number => {\n    const top = startIndex * ((rowHeight: any): number);\n    const numVisibleRows = Math.ceil(\n      (height + scrollTop - top) / ((rowHeight: any): number)\n    );\n    return Math.max(\n      0,\n      Math.min(\n        rowCount - 1,\n        startIndex + numVisibleRows - 1 // -1 is because stop index is inclusive\n      )\n    );\n  },\n\n  initInstanceProps(props: Props<any>): any {\n    // Noop\n  },\n\n  shouldResetStyleCacheOnItemSizeChange: true,\n\n  validateProps: ({ columnWidth, rowHeight }: Props<any>): void => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'number') {\n        throw Error(\n          'An invalid \"columnWidth\" prop has been specified. ' +\n            'Value should be a number. ' +\n            `\"${\n              columnWidth === null ? 'null' : typeof columnWidth\n            }\" was specified.`\n        );\n      }\n\n      if (typeof rowHeight !== 'number') {\n        throw Error(\n          'An invalid \"rowHeight\" prop has been specified. ' +\n            'Value should be a number. ' +\n            `\"${rowHeight === null ? 'null' : typeof rowHeight}\" was specified.`\n        );\n      }\n    }\n  },\n});\n\nexport default FixedSizeGrid;\n","// @flow\n\nimport createListComponent from './createListComponent';\n\nimport type { Props, ScrollToAlign } from './createListComponent';\n\nconst FixedSizeList = createListComponent({\n  getItemOffset: ({ itemSize }: Props<any>, index: number): number =>\n    index * ((itemSize: any): number),\n\n  getItemSize: ({ itemSize }: Props<any>, index: number): number =>\n    ((itemSize: any): number),\n\n  getEstimatedTotalSize: ({ itemCount, itemSize }: Props<any>) =>\n    ((itemSize: any): number) * itemCount,\n\n  getOffsetForIndexAndAlignment: (\n    { direction, height, itemCount, itemSize, layout, width }: Props<any>,\n    index: number,\n    align: ScrollToAlign,\n    scrollOffset: number\n  ): number => {\n    // TODO Deprecate direction \"horizontal\"\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    const size = (((isHorizontal ? width : height): any): number);\n    const lastItemOffset = Math.max(\n      0,\n      itemCount * ((itemSize: any): number) - size\n    );\n    const maxOffset = Math.min(\n      lastItemOffset,\n      index * ((itemSize: any): number)\n    );\n    const minOffset = Math.max(\n      0,\n      index * ((itemSize: any): number) - size + ((itemSize: any): number)\n    );\n\n    if (align === 'smart') {\n      if (\n        scrollOffset >= minOffset - size &&\n        scrollOffset <= maxOffset + size\n      ) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n      case 'end':\n        return minOffset;\n      case 'center': {\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        const middleOffset = Math.round(\n          minOffset + (maxOffset - minOffset) / 2\n        );\n        if (middleOffset < Math.ceil(size / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {\n          return lastItemOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n      }\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n    }\n  },\n\n  getStartIndexForOffset: (\n    { itemCount, itemSize }: Props<any>,\n    offset: number\n  ): number =>\n    Math.max(\n      0,\n      Math.min(itemCount - 1, Math.floor(offset / ((itemSize: any): number)))\n    ),\n\n  getStopIndexForStartIndex: (\n    { direction, height, itemCount, itemSize, layout, width }: Props<any>,\n    startIndex: number,\n    scrollOffset: number\n  ): number => {\n    // TODO Deprecate direction \"horizontal\"\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    const offset = startIndex * ((itemSize: any): number);\n    const size = (((isHorizontal ? width : height): any): number);\n    const numVisibleItems = Math.ceil(\n      (size + scrollOffset - offset) / ((itemSize: any): number)\n    );\n    return Math.max(\n      0,\n      Math.min(\n        itemCount - 1,\n        startIndex + numVisibleItems - 1 // -1 is because stop index is inclusive\n      )\n    );\n  },\n\n  initInstanceProps(props: Props<any>): any {\n    // Noop\n  },\n\n  shouldResetStyleCacheOnItemSizeChange: true,\n\n  validateProps: ({ itemSize }: Props<any>): void => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'number') {\n        throw Error(\n          'An invalid \"itemSize\" prop has been specified. ' +\n            'Value should be a number. ' +\n            `\"${itemSize === null ? 'null' : typeof itemSize}\" was specified.`\n        );\n      }\n    }\n  },\n});\n\nexport default FixedSizeList;\n","export default function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}","// @flow\n\n// Pulled from react-compat\n// https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349\nexport default function shallowDiffers(prev: Object, next: Object): boolean {\n  for (let attribute in prev) {\n    if (!(attribute in next)) {\n      return true;\n    }\n  }\n  for (let attribute in next) {\n    if (prev[attribute] !== next[attribute]) {\n      return true;\n    }\n  }\n  return false;\n}\n","// @flow\n\nimport shallowDiffers from './shallowDiffers';\n\n// Custom comparison function for React.memo().\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-api.html#reactmemo\nexport default function areEqual(\n  prevProps: Object,\n  nextProps: Object\n): boolean {\n  const { style: prevStyle, ...prevRest } = prevProps;\n  const { style: nextStyle, ...nextRest } = nextProps;\n\n  return (\n    !shallowDiffers(prevStyle, nextStyle) && !shallowDiffers(prevRest, nextRest)\n  );\n}\n","// @flow\n\nimport areEqual from './areEqual';\nimport shallowDiffers from './shallowDiffers';\n\n// Custom shouldComponentUpdate for class components.\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-component.html#shouldcomponentupdate\nexport default function shouldComponentUpdate(\n  nextProps: Object,\n  nextState: Object\n): boolean {\n  return (\n    !areEqual(this.props, nextProps) || shallowDiffers(this.state, nextState)\n  );\n}\n"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","this","_inheritsLoose","subClass","superClass","create","constructor","__proto__","_assertThisInitialized","self","ReferenceError","simpleIsEqual","newArgs","lastArgs","every","newArg","index","newValue","oldValue","resultFn","isEqual","lastThis","lastResult","calledOnce","_len","Array","_key","now","performance","Date","cancelTimeout","timeoutID","cancelAnimationFrame","id","requestTimeout","callback","delay","start","requestAnimationFrame","tick","size","cachedRTLResult","getRTLOffsetType","recalculate","outerDiv","document","createElement","outerStyle","style","width","height","overflow","direction","innerDiv","innerStyle","appendChild","body","scrollLeft","removeChild","IS_SCROLLING_DEBOUNCE_INTERVAL","defaultItemKey","columnIndex","data","rowIndex","devWarningsOverscanCount","devWarningsOverscanRowsColumnsCount","devWarningsTagName","createGridComponent","getColumnOffset","getColumnStartIndexForOffset","getColumnStopIndexForStartIndex","getColumnWidth","getEstimatedTotalHeight","getEstimatedTotalWidth","getOffsetForColumnAndAlignment","getOffsetForRowAndAlignment","getRowHeight","getRowOffset","getRowStartIndexForOffset","getRowStopIndexForStartIndex","initInstanceProps","shouldResetStyleCacheOnItemSizeChange","validateProps","props","_instanceProps","_this","_resetIsScrollingTimeoutId","_outerRef","state","instance","isScrolling","horizontalScrollDirection","initialScrollLeft","scrollTop","initialScrollTop","scrollUpdateWasRequested","verticalScrollDirection","_callOnItemsRendered","memoizeOne","overscanColumnStartIndex","overscanColumnStopIndex","overscanRowStartIndex","overscanRowStopIndex","visibleColumnStartIndex","visibleColumnStopIndex","visibleRowStartIndex","visibleRowStopIndex","onItemsRendered","_callOnScroll","onScroll","_getItemStyle","columnWidth","rowHeight","itemStyleCache","_getItemStyleCache","offset","isRtl","position","left","undefined","right","top","_","__","___","_onScroll","event","currentTarget","clientHeight","clientWidth","scrollHeight","scrollWidth","setState","prevState","calculatedScrollLeft","Math","max","min","calculatedScrollTop","_resetIsScrollingDebounced","_outerRefSetter","ref","outerRef","current","_resetIsScrolling","getDerivedStateFromProps","nextProps","validateSharedProps","scrollTo","scrollToItem","align","columnCount","rowCount","scrollbarSize","div","offsetWidth","getScrollbarSize","estimatedTotalHeight","horizontalScrollbarSize","verticalScrollbarSize","componentDidMount","_callPropsCallbacks","componentDidUpdate","componentWillUnmount","render","children","className","innerRef","innerElementType","innerTagName","itemData","itemKey","outerElementType","outerTagName","useIsScrolling","_getHorizontalRangeToRender","columnStartIndex","columnStopIndex","_getVerticalRangeToRender","rowStartIndex","rowStopIndex","items","push","estimatedTotalWidth","WebkitOverflowScrolling","willChange","pointerEvents","overscanColumnCount","overscanColumnsCount","overscanCount","overscanCountResolved","startIndex","stopIndex","overscanBackward","overscanForward","overscanRowCount","overscanRowsCount","PureComponent","defaultProps","window","WeakSet","has","add","console","warn","Error","rowMetadataMap","estimatedRowHeight","lastMeasuredRowIndex","totalSizeOfMeasuredRows","itemMetadata","columnMetadataMap","estimatedColumnWidth","lastMeasuredColumnIndex","getItemMetadata","itemType","instanceProps","itemMetadataMap","itemSize","lastMeasuredIndex","findNearestItem","findNearestItemBinarySearch","findNearestItemExponentialSearch","high","low","middle","floor","currentOffset","itemCount","interval","getOffsetForIndexAndAlignment","scrollOffset","estimatedTotalSize","maxOffset","minOffset","round","VariableSizeGrid","resetAfterColumnIndex","shouldForceUpdate","resetAfterIndices","resetAfterRowIndex","forceUpdate","devWarningsDirection","createListComponent","getItemOffset","getEstimatedTotalSize","getItemSize","getStartIndexForOffset","getStopIndexForStartIndex","scrollDirection","initialScrollOffset","overscanStartIndex","overscanStopIndex","visibleStartIndex","visibleStopIndex","layout","isHorizontal","offsetHorizontal","_onScrollHorizontal","_onScrollVertical","_getRangeToRender","estimatedItemSize","totalSizeOfMeasuredItems","VariableSizeList","resetAfterIndex","FixedSizeGrid","lastColumnOffset","middleOffset","ceil","lastRowOffset","numVisibleColumns","numVisibleRows","FixedSizeList","lastItemOffset","numVisibleItems","_objectWithoutPropertiesLoose","excluded","sourceKeys","keys","indexOf","shallowDiffers","prev","next","attribute","areEqual","prevProps","prevStyle","prevRest","nextStyle","nextRest","nextState"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"index-dev.umd.js","sources":["../node_modules/@babel/runtime/helpers/esm/extends.js","../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","../node_modules/@babel/runtime/helpers/esm/inheritsLoose.js","../node_modules/memoize-one/dist/memoize-one.esm.js","../src/timer.js","../src/domHelpers.js","../src/createGridComponent.js","../src/VariableSizeGrid.js","../src/createListComponent.js","../src/VariableSizeList.js","../src/FixedSizeGrid.js","../src/FixedSizeList.js","../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js","../src/shallowDiffers.js","../src/areEqual.js","../src/shouldComponentUpdate.js"],"sourcesContent":["export default function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}","export default function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}","export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}","import setPrototypeOf from \"./setPrototypeOf.js\";\nexport default function _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  setPrototypeOf(subClass, superClass);\n}","var safeIsNaN = Number.isNaN ||\n    function ponyfill(value) {\n        return typeof value === 'number' && value !== value;\n    };\nfunction isEqual(first, second) {\n    if (first === second) {\n        return true;\n    }\n    if (safeIsNaN(first) && safeIsNaN(second)) {\n        return true;\n    }\n    return false;\n}\nfunction areInputsEqual(newInputs, lastInputs) {\n    if (newInputs.length !== lastInputs.length) {\n        return false;\n    }\n    for (var i = 0; i < newInputs.length; i++) {\n        if (!isEqual(newInputs[i], lastInputs[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction memoizeOne(resultFn, isEqual) {\n    if (isEqual === void 0) { isEqual = areInputsEqual; }\n    var lastThis;\n    var lastArgs = [];\n    var lastResult;\n    var calledOnce = false;\n    function memoized() {\n        var newArgs = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            newArgs[_i] = arguments[_i];\n        }\n        if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {\n            return lastResult;\n        }\n        lastResult = resultFn.apply(this, newArgs);\n        calledOnce = true;\n        lastThis = this;\n        lastArgs = newArgs;\n        return lastResult;\n    }\n    return memoized;\n}\n\nexport default memoizeOne;\n","// @flow\r\n\r\n// Animation frame based implementation of setTimeout.\r\n// Inspired by Joe Lambert, https://gist.github.com/joelambert/1002116#file-requesttimeout-js\r\n\r\nconst hasNativePerformanceNow =\r\n  typeof performance === 'object' && typeof performance.now === 'function';\r\n\r\nconst now = hasNativePerformanceNow\r\n  ? () => performance.now()\r\n  : () => Date.now();\r\n\r\nexport type TimeoutID = {|\r\n  id: AnimationFrameID,\r\n|};\r\n\r\nexport function cancelTimeout(timeoutID: TimeoutID) {\r\n  cancelAnimationFrame(timeoutID.id);\r\n}\r\n\r\nexport function requestTimeout(callback: Function, delay: number): TimeoutID {\r\n  const start = now();\r\n\r\n  function tick() {\r\n    if (now() - start >= delay) {\r\n      callback.call(null);\r\n    } else {\r\n      timeoutID.id = requestAnimationFrame(tick);\r\n    }\r\n  }\r\n\r\n  const timeoutID: TimeoutID = {\r\n    id: requestAnimationFrame(tick),\r\n  };\r\n\r\n  return timeoutID;\r\n}\r\n","// @flow\r\n\r\nlet size: number = -1;\r\n\r\n// This utility copied from \"dom-helpers\" package.\r\nexport function getScrollbarSize(recalculate?: boolean = false): number {\r\n  if (size === -1 || recalculate) {\r\n    const div = document.createElement('div');\r\n    const style = div.style;\r\n    style.width = '50px';\r\n    style.height = '50px';\r\n    style.overflow = 'scroll';\r\n\r\n    ((document.body: any): HTMLBodyElement).appendChild(div);\r\n\r\n    size = div.offsetWidth - div.clientWidth;\r\n\r\n    ((document.body: any): HTMLBodyElement).removeChild(div);\r\n  }\r\n\r\n  return size;\r\n}\r\n\r\nexport type RTLOffsetType =\r\n  | 'negative'\r\n  | 'positive-descending'\r\n  | 'positive-ascending';\r\n\r\nlet cachedRTLResult: RTLOffsetType | null = null;\r\n\r\n// TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\r\n// Chrome does not seem to adhere; its scrollLeft values are positive (measured relative to the left).\r\n// Safari's elastic bounce makes detecting this even more complicated wrt potential false positives.\r\n// The safest way to check this is to intentionally set a negative offset,\r\n// and then verify that the subsequent \"scroll\" event matches the negative offset.\r\n// If it does not match, then we can assume a non-standard RTL scroll implementation.\r\nexport function getRTLOffsetType(recalculate?: boolean = false): RTLOffsetType {\r\n  if (cachedRTLResult === null || recalculate) {\r\n    const outerDiv = document.createElement('div');\r\n    const outerStyle = outerDiv.style;\r\n    outerStyle.width = '50px';\r\n    outerStyle.height = '50px';\r\n    outerStyle.overflow = 'scroll';\r\n    outerStyle.direction = 'rtl';\r\n\r\n    const innerDiv = document.createElement('div');\r\n    const innerStyle = innerDiv.style;\r\n    innerStyle.width = '100px';\r\n    innerStyle.height = '100px';\r\n\r\n    outerDiv.appendChild(innerDiv);\r\n\r\n    ((document.body: any): HTMLBodyElement).appendChild(outerDiv);\r\n\r\n    if (outerDiv.scrollLeft > 0) {\r\n      cachedRTLResult = 'positive-descending';\r\n    } else {\r\n      outerDiv.scrollLeft = 1;\r\n      if (outerDiv.scrollLeft === 0) {\r\n        cachedRTLResult = 'negative';\r\n      } else {\r\n        cachedRTLResult = 'positive-ascending';\r\n      }\r\n    }\r\n\r\n    ((document.body: any): HTMLBodyElement).removeChild(outerDiv);\r\n\r\n    return cachedRTLResult;\r\n  }\r\n\r\n  return cachedRTLResult;\r\n}\r\n","// @flow\r\n\r\nimport memoizeOne from 'memoize-one';\r\nimport { createElement, PureComponent } from 'react';\r\nimport { cancelTimeout, requestTimeout } from './timer';\r\nimport { getScrollbarSize, getRTLOffsetType } from './domHelpers';\r\n\r\nimport type { TimeoutID } from './timer';\r\n\r\ntype Direction = 'ltr' | 'rtl';\r\nexport type ScrollToAlign = 'auto' | 'smart' | 'center' | 'start' | 'end';\r\n\r\ntype itemSize = number | ((index: number) => number);\r\n\r\ntype RenderComponentProps<T> = {|\r\n  columnIndex: number,\r\n  data: T,\r\n  isScrolling?: boolean,\r\n  rowIndex: number,\r\n  style: Object,\r\n|};\r\nexport type RenderComponent<T> = React$ComponentType<\r\n  $Shape<RenderComponentProps<T>>\r\n>;\r\n\r\ntype ScrollDirection = 'forward' | 'backward';\r\n\r\ntype OnItemsRenderedCallback = ({\r\n  overscanColumnStartIndex: number,\r\n  overscanColumnStopIndex: number,\r\n  overscanRowStartIndex: number,\r\n  overscanRowStopIndex: number,\r\n  visibleColumnStartIndex: number,\r\n  visibleColumnStopIndex: number,\r\n  visibleRowStartIndex: number,\r\n  visibleRowStopIndex: number,\r\n}) => void;\r\ntype OnScrollCallback = ({\r\n  horizontalScrollDirection: ScrollDirection,\r\n  scrollLeft: number,\r\n  scrollTop: number,\r\n  scrollUpdateWasRequested: boolean,\r\n  verticalScrollDirection: ScrollDirection,\r\n}) => void;\r\n\r\ntype ScrollEvent = SyntheticEvent<HTMLDivElement>;\r\ntype ItemStyleCache = { [key: string]: Object };\r\n\r\ntype OuterProps = {|\r\n  children: React$Node,\r\n  className: string | void,\r\n  onScroll: ScrollEvent => void,\r\n  style: {\r\n    [string]: mixed,\r\n  },\r\n|};\r\n\r\ntype InnerProps = {|\r\n  children: React$Node,\r\n  style: {\r\n    [string]: mixed,\r\n  },\r\n|};\r\n\r\nexport type Props<T> = {|\r\n  children: RenderComponent<T>,\r\n  className?: string,\r\n  columnCount: number,\r\n  columnWidth: itemSize,\r\n  direction: Direction,\r\n  height: number,\r\n  initialScrollLeft?: number,\r\n  initialScrollTop?: number,\r\n  innerRef?: any,\r\n  innerElementType?: string | React$AbstractComponent<InnerProps, any>,\r\n  innerTagName?: string, // deprecated\r\n  itemData: T,\r\n  itemKey?: (params: {|\r\n    columnIndex: number,\r\n    data: T,\r\n    rowIndex: number,\r\n  |}) => any,\r\n  onItemsRendered?: OnItemsRenderedCallback,\r\n  onScroll?: OnScrollCallback,\r\n  outerRef?: any,\r\n  outerElementType?: string | React$AbstractComponent<OuterProps, any>,\r\n  outerTagName?: string, // deprecated\r\n  overscanColumnCount?: number,\r\n  overscanColumnsCount?: number, // deprecated\r\n  overscanCount?: number, // deprecated\r\n  overscanRowCount?: number,\r\n  overscanRowsCount?: number, // deprecated\r\n  rowCount: number,\r\n  rowHeight: itemSize,\r\n  style?: Object,\r\n  useIsScrolling: boolean,\r\n  width: number,\r\n|};\r\n\r\ntype State = {|\r\n  instance: any,\r\n  isScrolling: boolean,\r\n  horizontalScrollDirection: ScrollDirection,\r\n  scrollLeft: number,\r\n  scrollTop: number,\r\n  scrollUpdateWasRequested: boolean,\r\n  verticalScrollDirection: ScrollDirection,\r\n|};\r\n\r\ntype getItemOffset = (\r\n  props: Props<any>,\r\n  index: number,\r\n  instanceProps: any\r\n) => number;\r\ntype getItemSize = (\r\n  props: Props<any>,\r\n  index: number,\r\n  instanceProps: any\r\n) => number;\r\ntype getEstimatedTotalSize = (props: Props<any>, instanceProps: any) => number;\r\ntype GetOffsetForItemAndAlignment = (\r\n  props: Props<any>,\r\n  index: number,\r\n  align: ScrollToAlign,\r\n  scrollOffset: number,\r\n  instanceProps: any,\r\n  scrollbarSize: number\r\n) => number;\r\ntype GetStartIndexForOffset = (\r\n  props: Props<any>,\r\n  offset: number,\r\n  instanceProps: any\r\n) => number;\r\ntype GetStopIndexForStartIndex = (\r\n  props: Props<any>,\r\n  startIndex: number,\r\n  scrollOffset: number,\r\n  instanceProps: any\r\n) => number;\r\ntype InitInstanceProps = (props: Props<any>, instance: any) => any;\r\ntype ValidateProps = (props: Props<any>) => void;\r\n\r\nconst IS_SCROLLING_DEBOUNCE_INTERVAL = 150;\r\n\r\nconst defaultItemKey = ({ columnIndex, data, rowIndex }) =>\r\n  `${rowIndex}:${columnIndex}`;\r\n\r\n// In DEV mode, this Set helps us only log a warning once per component instance.\r\n// This avoids spamming the console every time a render happens.\r\nlet devWarningsOverscanCount = null;\r\nlet devWarningsOverscanRowsColumnsCount = null;\r\nlet devWarningsTagName = null;\r\nif (process.env.NODE_ENV !== 'production') {\r\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\r\n    devWarningsOverscanCount = new WeakSet();\r\n    devWarningsOverscanRowsColumnsCount = new WeakSet();\r\n    devWarningsTagName = new WeakSet();\r\n  }\r\n}\r\n\r\nexport default function createGridComponent({\r\n  getColumnOffset,\r\n  getColumnStartIndexForOffset,\r\n  getColumnStopIndexForStartIndex,\r\n  getColumnWidth,\r\n  getEstimatedTotalHeight,\r\n  getEstimatedTotalWidth,\r\n  getOffsetForColumnAndAlignment,\r\n  getOffsetForRowAndAlignment,\r\n  getRowHeight,\r\n  getRowOffset,\r\n  getRowStartIndexForOffset,\r\n  getRowStopIndexForStartIndex,\r\n  initInstanceProps,\r\n  shouldResetStyleCacheOnItemSizeChange,\r\n  validateProps,\r\n}: {|\r\n  getColumnOffset: getItemOffset,\r\n  getColumnStartIndexForOffset: GetStartIndexForOffset,\r\n  getColumnStopIndexForStartIndex: GetStopIndexForStartIndex,\r\n  getColumnWidth: getItemSize,\r\n  getEstimatedTotalHeight: getEstimatedTotalSize,\r\n  getEstimatedTotalWidth: getEstimatedTotalSize,\r\n  getOffsetForColumnAndAlignment: GetOffsetForItemAndAlignment,\r\n  getOffsetForRowAndAlignment: GetOffsetForItemAndAlignment,\r\n  getRowOffset: getItemOffset,\r\n  getRowHeight: getItemSize,\r\n  getRowStartIndexForOffset: GetStartIndexForOffset,\r\n  getRowStopIndexForStartIndex: GetStopIndexForStartIndex,\r\n  initInstanceProps: InitInstanceProps,\r\n  shouldResetStyleCacheOnItemSizeChange: boolean,\r\n  validateProps: ValidateProps,\r\n|}) {\r\n  return class Grid<T> extends PureComponent<Props<T>, State> {\r\n    _instanceProps: any = initInstanceProps(this.props, this);\r\n    _resetIsScrollingTimeoutId: TimeoutID | null = null;\r\n    _outerRef: ?HTMLDivElement;\r\n\r\n    static defaultProps = {\r\n      direction: 'ltr',\r\n      itemData: undefined,\r\n      useIsScrolling: false,\r\n    };\r\n\r\n    state: State = {\r\n      instance: this,\r\n      isScrolling: false,\r\n      horizontalScrollDirection: 'forward',\r\n      scrollLeft:\r\n        typeof this.props.initialScrollLeft === 'number'\r\n          ? this.props.initialScrollLeft\r\n          : 0,\r\n      scrollTop:\r\n        typeof this.props.initialScrollTop === 'number'\r\n          ? this.props.initialScrollTop\r\n          : 0,\r\n      scrollUpdateWasRequested: false,\r\n      verticalScrollDirection: 'forward',\r\n    };\r\n\r\n    // Always use explicit constructor for React components.\r\n    // It produces less code after transpilation. (#26)\r\n    // eslint-disable-next-line no-useless-constructor\r\n    constructor(props: Props<T>) {\r\n      super(props);\r\n    }\r\n\r\n    static getDerivedStateFromProps(\r\n      nextProps: Props<T>,\r\n      prevState: State\r\n    ): $Shape<State> | null {\r\n      validateSharedProps(nextProps, prevState);\r\n      validateProps(nextProps);\r\n      return null;\r\n    }\r\n\r\n    scrollTo({\r\n      scrollLeft,\r\n      scrollTop,\r\n    }: {\r\n      scrollLeft: number,\r\n      scrollTop: number,\r\n    }): void {\r\n      if (scrollLeft !== undefined) {\r\n        scrollLeft = Math.max(0, scrollLeft);\r\n      }\r\n      if (scrollTop !== undefined) {\r\n        scrollTop = Math.max(0, scrollTop);\r\n      }\r\n\r\n      this.setState(prevState => {\r\n        if (scrollLeft === undefined) {\r\n          scrollLeft = prevState.scrollLeft;\r\n        }\r\n        if (scrollTop === undefined) {\r\n          scrollTop = prevState.scrollTop;\r\n        }\r\n\r\n        if (\r\n          prevState.scrollLeft === scrollLeft &&\r\n          prevState.scrollTop === scrollTop\r\n        ) {\r\n          return null;\r\n        }\r\n\r\n        return {\r\n          horizontalScrollDirection:\r\n            prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\r\n          scrollLeft: scrollLeft,\r\n          scrollTop: scrollTop,\r\n          scrollUpdateWasRequested: true,\r\n          verticalScrollDirection:\r\n            prevState.scrollTop < scrollTop ? 'forward' : 'backward',\r\n        };\r\n      }, this._resetIsScrollingDebounced);\r\n    }\r\n\r\n    scrollToItem({\r\n      align = 'auto',\r\n      columnIndex,\r\n      rowIndex,\r\n    }: {\r\n      align: ScrollToAlign,\r\n      columnIndex?: number,\r\n      rowIndex?: number,\r\n    }): void {\r\n      const { columnCount, height, rowCount, width } = this.props;\r\n      const { scrollLeft, scrollTop } = this.state;\r\n      const scrollbarSize = getScrollbarSize();\r\n\r\n      if (columnIndex !== undefined) {\r\n        columnIndex = Math.max(0, Math.min(columnIndex, columnCount - 1));\r\n      }\r\n      if (rowIndex !== undefined) {\r\n        rowIndex = Math.max(0, Math.min(rowIndex, rowCount - 1));\r\n      }\r\n\r\n      const estimatedTotalHeight = getEstimatedTotalHeight(\r\n        this.props,\r\n        this._instanceProps\r\n      );\r\n      const estimatedTotalWidth = getEstimatedTotalWidth(\r\n        this.props,\r\n        this._instanceProps\r\n      );\r\n\r\n      // The scrollbar size should be considered when scrolling an item into view,\r\n      // to ensure it's fully visible.\r\n      // But we only need to account for its size when it's actually visible.\r\n      const horizontalScrollbarSize =\r\n        estimatedTotalWidth > width ? scrollbarSize : 0;\r\n      const verticalScrollbarSize =\r\n        estimatedTotalHeight > height ? scrollbarSize : 0;\r\n\r\n      this.scrollTo({\r\n        scrollLeft:\r\n          columnIndex !== undefined\r\n            ? getOffsetForColumnAndAlignment(\r\n                this.props,\r\n                columnIndex,\r\n                align,\r\n                scrollLeft,\r\n                this._instanceProps,\r\n                verticalScrollbarSize\r\n              )\r\n            : scrollLeft,\r\n        scrollTop:\r\n          rowIndex !== undefined\r\n            ? getOffsetForRowAndAlignment(\r\n                this.props,\r\n                rowIndex,\r\n                align,\r\n                scrollTop,\r\n                this._instanceProps,\r\n                horizontalScrollbarSize\r\n              )\r\n            : scrollTop,\r\n      });\r\n    }\r\n\r\n    componentDidMount() {\r\n      const { initialScrollLeft, initialScrollTop } = this.props;\r\n\r\n      if (this._outerRef != null) {\r\n        const outerRef = ((this._outerRef: any): HTMLElement);\r\n        if (typeof initialScrollLeft === 'number') {\r\n          outerRef.scrollLeft = initialScrollLeft;\r\n        }\r\n        if (typeof initialScrollTop === 'number') {\r\n          outerRef.scrollTop = initialScrollTop;\r\n        }\r\n      }\r\n\r\n      this._callPropsCallbacks();\r\n    }\r\n\r\n    componentDidUpdate() {\r\n      const { direction } = this.props;\r\n      const { scrollLeft, scrollTop, scrollUpdateWasRequested } = this.state;\r\n\r\n      if (scrollUpdateWasRequested && this._outerRef != null) {\r\n        // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\r\n        // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\r\n        // So we need to determine which browser behavior we're dealing with, and mimic it.\r\n        const outerRef = ((this._outerRef: any): HTMLElement);\r\n        if (direction === 'rtl') {\r\n          switch (getRTLOffsetType()) {\r\n            case 'negative':\r\n              outerRef.scrollLeft = -scrollLeft;\r\n              break;\r\n            case 'positive-ascending':\r\n              outerRef.scrollLeft = scrollLeft;\r\n              break;\r\n            default:\r\n              const { clientWidth, scrollWidth } = outerRef;\r\n              outerRef.scrollLeft = scrollWidth - clientWidth - scrollLeft;\r\n              break;\r\n          }\r\n        } else {\r\n          outerRef.scrollLeft = Math.max(0, scrollLeft);\r\n        }\r\n\r\n        outerRef.scrollTop = Math.max(0, scrollTop);\r\n      }\r\n\r\n      this._callPropsCallbacks();\r\n    }\r\n\r\n    componentWillUnmount() {\r\n      if (this._resetIsScrollingTimeoutId !== null) {\r\n        cancelTimeout(this._resetIsScrollingTimeoutId);\r\n      }\r\n    }\r\n\r\n    render() {\r\n      const {\r\n        children,\r\n        className,\r\n        columnCount,\r\n        direction,\r\n        height,\r\n        innerRef,\r\n        innerElementType,\r\n        innerTagName,\r\n        itemData,\r\n        itemKey = defaultItemKey,\r\n        outerElementType,\r\n        outerTagName,\r\n        rowCount,\r\n        style,\r\n        useIsScrolling,\r\n        width,\r\n        disableColVirtualized,\r\n        disableRowVirtualized\r\n      } = this.props;\r\n      const { isScrolling } = this.state;\r\n\r\n      let [\r\n        columnStartIndex,\r\n        columnStopIndex,\r\n      ] = this._getHorizontalRangeToRender();\r\n      let [rowStartIndex, rowStopIndex] = this._getVerticalRangeToRender();\r\n\r\n      if(disableColVirtualized) columnStartIndex = 0;\r\n      if(disableRowVirtualized) rowStartIndex = 0;\r\n      \r\n      const items = [];\r\n      if (columnCount > 0 && rowCount) {\r\n        for (\r\n          let rowIndex = rowStartIndex;\r\n          rowIndex <= rowStopIndex;\r\n          rowIndex++\r\n        ) {\r\n          for (\r\n            let columnIndex = columnStartIndex;\r\n            columnIndex <= columnStopIndex;\r\n            columnIndex++\r\n          ) {\r\n            items.push(\r\n              createElement(children, {\r\n                columnIndex,\r\n                data: itemData,\r\n                isScrolling: useIsScrolling ? isScrolling : undefined,\r\n                key: itemKey({ columnIndex, data: itemData, rowIndex }),\r\n                rowIndex,\r\n                style: this._getItemStyle(rowIndex, columnIndex),\r\n              })\r\n            );\r\n          }\r\n        }\r\n      }\r\n\r\n      // Read this value AFTER items have been created,\r\n      // So their actual sizes (if variable) are taken into consideration.\r\n      const estimatedTotalHeight = getEstimatedTotalHeight(\r\n        this.props,\r\n        this._instanceProps\r\n      );\r\n      const estimatedTotalWidth = getEstimatedTotalWidth(\r\n        this.props,\r\n        this._instanceProps\r\n      );\r\n\r\n      return createElement(\r\n        outerElementType || outerTagName || 'div',\r\n        {\r\n          className,\r\n          onScroll: this._onScroll,\r\n          ref: this._outerRefSetter,\r\n          style: {\r\n            position: 'relative',\r\n            height,\r\n            width,\r\n            overflow: 'auto',\r\n            WebkitOverflowScrolling: 'touch',\r\n            willChange: 'transform',\r\n            direction,\r\n            ...style,\r\n          },\r\n        },\r\n        createElement(innerElementType || innerTagName || 'div', {\r\n          children: items,\r\n          ref: innerRef,\r\n          style: {\r\n            height: estimatedTotalHeight,\r\n            pointerEvents: isScrolling ? 'none' : undefined,\r\n            width: estimatedTotalWidth,\r\n          },\r\n        })\r\n      );\r\n    }\r\n\r\n    _callOnItemsRendered: (\r\n      overscanColumnStartIndex: number,\r\n      overscanColumnStopIndex: number,\r\n      overscanRowStartIndex: number,\r\n      overscanRowStopIndex: number,\r\n      visibleColumnStartIndex: number,\r\n      visibleColumnStopIndex: number,\r\n      visibleRowStartIndex: number,\r\n      visibleRowStopIndex: number\r\n    ) => void;\r\n    _callOnItemsRendered = memoizeOne(\r\n      (\r\n        overscanColumnStartIndex: number,\r\n        overscanColumnStopIndex: number,\r\n        overscanRowStartIndex: number,\r\n        overscanRowStopIndex: number,\r\n        visibleColumnStartIndex: number,\r\n        visibleColumnStopIndex: number,\r\n        visibleRowStartIndex: number,\r\n        visibleRowStopIndex: number\r\n      ) =>\r\n        ((this.props.onItemsRendered: any): OnItemsRenderedCallback)({\r\n          overscanColumnStartIndex,\r\n          overscanColumnStopIndex,\r\n          overscanRowStartIndex,\r\n          overscanRowStopIndex,\r\n          visibleColumnStartIndex,\r\n          visibleColumnStopIndex,\r\n          visibleRowStartIndex,\r\n          visibleRowStopIndex,\r\n        })\r\n    );\r\n\r\n    _callOnScroll: (\r\n      scrollLeft: number,\r\n      scrollTop: number,\r\n      horizontalScrollDirection: ScrollDirection,\r\n      verticalScrollDirection: ScrollDirection,\r\n      scrollUpdateWasRequested: boolean\r\n    ) => void;\r\n    _callOnScroll = memoizeOne(\r\n      (\r\n        scrollLeft: number,\r\n        scrollTop: number,\r\n        horizontalScrollDirection: ScrollDirection,\r\n        verticalScrollDirection: ScrollDirection,\r\n        scrollUpdateWasRequested: boolean\r\n      ) =>\r\n        ((this.props.onScroll: any): OnScrollCallback)({\r\n          horizontalScrollDirection,\r\n          scrollLeft,\r\n          scrollTop,\r\n          verticalScrollDirection,\r\n          scrollUpdateWasRequested,\r\n        })\r\n    );\r\n\r\n    _callPropsCallbacks() {\r\n      const { columnCount, onItemsRendered, onScroll, rowCount } = this.props;\r\n\r\n      if (typeof onItemsRendered === 'function') {\r\n        if (columnCount > 0 && rowCount > 0) {\r\n          const [\r\n            overscanColumnStartIndex,\r\n            overscanColumnStopIndex,\r\n            visibleColumnStartIndex,\r\n            visibleColumnStopIndex,\r\n          ] = this._getHorizontalRangeToRender();\r\n          const [\r\n            overscanRowStartIndex,\r\n            overscanRowStopIndex,\r\n            visibleRowStartIndex,\r\n            visibleRowStopIndex,\r\n          ] = this._getVerticalRangeToRender();\r\n          this._callOnItemsRendered(\r\n            overscanColumnStartIndex,\r\n            overscanColumnStopIndex,\r\n            overscanRowStartIndex,\r\n            overscanRowStopIndex,\r\n            visibleColumnStartIndex,\r\n            visibleColumnStopIndex,\r\n            visibleRowStartIndex,\r\n            visibleRowStopIndex\r\n          );\r\n        }\r\n      }\r\n\r\n      if (typeof onScroll === 'function') {\r\n        const {\r\n          horizontalScrollDirection,\r\n          scrollLeft,\r\n          scrollTop,\r\n          scrollUpdateWasRequested,\r\n          verticalScrollDirection,\r\n        } = this.state;\r\n        this._callOnScroll(\r\n          scrollLeft,\r\n          scrollTop,\r\n          horizontalScrollDirection,\r\n          verticalScrollDirection,\r\n          scrollUpdateWasRequested\r\n        );\r\n      }\r\n    }\r\n\r\n    // Lazily create and cache item styles while scrolling,\r\n    // So that pure component sCU will prevent re-renders.\r\n    // We maintain this cache, and pass a style prop rather than index,\r\n    // So that List can clear cached styles and force item re-render if necessary.\r\n    _getItemStyle: (rowIndex: number, columnIndex: number) => Object;\r\n    _getItemStyle = (rowIndex: number, columnIndex: number): Object => {\r\n      const { columnWidth, direction, rowHeight } = this.props;\r\n\r\n      const itemStyleCache = this._getItemStyleCache(\r\n        shouldResetStyleCacheOnItemSizeChange && columnWidth,\r\n        shouldResetStyleCacheOnItemSizeChange && direction,\r\n        shouldResetStyleCacheOnItemSizeChange && rowHeight\r\n      );\r\n\r\n      const key = `${rowIndex}:${columnIndex}`;\r\n\r\n      let style;\r\n      if (itemStyleCache.hasOwnProperty(key)) {\r\n        style = itemStyleCache[key];\r\n      } else {\r\n        const offset = getColumnOffset(\r\n          this.props,\r\n          columnIndex,\r\n          this._instanceProps\r\n        );\r\n        const isRtl = direction === 'rtl';\r\n        itemStyleCache[key] = style = {\r\n          position: 'absolute',\r\n          left: isRtl ? undefined : offset,\r\n          right: isRtl ? offset : undefined,\r\n          top: getRowOffset(this.props, rowIndex, this._instanceProps),\r\n          height: getRowHeight(this.props, rowIndex, this._instanceProps),\r\n          width: getColumnWidth(this.props, columnIndex, this._instanceProps),\r\n        };\r\n      }\r\n\r\n      return style;\r\n    };\r\n\r\n    _getItemStyleCache: (_: any, __: any, ___: any) => ItemStyleCache;\r\n    _getItemStyleCache = memoizeOne((_: any, __: any, ___: any) => ({}));\r\n\r\n    _getHorizontalRangeToRender(): [number, number, number, number] {\r\n      const {\r\n        columnCount,\r\n        overscanColumnCount,\r\n        overscanColumnsCount,\r\n        overscanCount,\r\n        rowCount,\r\n      } = this.props;\r\n      const { horizontalScrollDirection, isScrolling, scrollLeft } = this.state;\r\n\r\n      const overscanCountResolved: number =\r\n        overscanColumnCount || overscanColumnsCount || overscanCount || 1;\r\n\r\n      if (columnCount === 0 || rowCount === 0) {\r\n        return [0, 0, 0, 0];\r\n      }\r\n\r\n      const startIndex = getColumnStartIndexForOffset(\r\n        this.props,\r\n        scrollLeft,\r\n        this._instanceProps\r\n      );\r\n      const stopIndex = getColumnStopIndexForStartIndex(\r\n        this.props,\r\n        startIndex,\r\n        scrollLeft,\r\n        this._instanceProps\r\n      );\r\n\r\n      // Overscan by one item in each direction so that tab/focus works.\r\n      // If there isn't at least one extra item, tab loops back around.\r\n      const overscanBackward =\r\n        !isScrolling || horizontalScrollDirection === 'backward'\r\n          ? Math.max(1, overscanCountResolved)\r\n          : 1;\r\n      const overscanForward =\r\n        !isScrolling || horizontalScrollDirection === 'forward'\r\n          ? Math.max(1, overscanCountResolved)\r\n          : 1;\r\n\r\n      return [\r\n        Math.max(0, startIndex - overscanBackward),\r\n        Math.max(0, Math.min(columnCount - 1, stopIndex + overscanForward)),\r\n        startIndex,\r\n        stopIndex,\r\n      ];\r\n    }\r\n\r\n    _getVerticalRangeToRender(): [number, number, number, number] {\r\n      const {\r\n        columnCount,\r\n        overscanCount,\r\n        overscanRowCount,\r\n        overscanRowsCount,\r\n        rowCount,\r\n      } = this.props;\r\n      const { isScrolling, verticalScrollDirection, scrollTop } = this.state;\r\n\r\n      const overscanCountResolved: number =\r\n        overscanRowCount || overscanRowsCount || overscanCount || 1;\r\n\r\n      if (columnCount === 0 || rowCount === 0) {\r\n        return [0, 0, 0, 0];\r\n      }\r\n\r\n      const startIndex = getRowStartIndexForOffset(\r\n        this.props,\r\n        scrollTop,\r\n        this._instanceProps\r\n      );\r\n      const stopIndex = getRowStopIndexForStartIndex(\r\n        this.props,\r\n        startIndex,\r\n        scrollTop,\r\n        this._instanceProps\r\n      );\r\n\r\n      // Overscan by one item in each direction so that tab/focus works.\r\n      // If there isn't at least one extra item, tab loops back around.\r\n      const overscanBackward =\r\n        !isScrolling || verticalScrollDirection === 'backward'\r\n          ? Math.max(1, overscanCountResolved)\r\n          : 1;\r\n      const overscanForward =\r\n        !isScrolling || verticalScrollDirection === 'forward'\r\n          ? Math.max(1, overscanCountResolved)\r\n          : 1;\r\n\r\n      return [\r\n        Math.max(0, startIndex - overscanBackward),\r\n        Math.max(0, Math.min(rowCount - 1, stopIndex + overscanForward)),\r\n        startIndex,\r\n        stopIndex,\r\n      ];\r\n    }\r\n\r\n    _onScroll = (event: ScrollEvent): void => {\r\n      const {\r\n        clientHeight,\r\n        clientWidth,\r\n        scrollLeft,\r\n        scrollTop,\r\n        scrollHeight,\r\n        scrollWidth,\r\n      } = event.currentTarget;\r\n      this.setState(prevState => {\r\n        if (\r\n          prevState.scrollLeft === scrollLeft &&\r\n          prevState.scrollTop === scrollTop\r\n        ) {\r\n          // Scroll position may have been updated by cDM/cDU,\r\n          // In which case we don't need to trigger another render,\r\n          // And we don't want to update state.isScrolling.\r\n          return null;\r\n        }\r\n\r\n        const { direction } = this.props;\r\n\r\n        // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\r\n        // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\r\n        // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\r\n        // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\r\n        let calculatedScrollLeft = scrollLeft;\r\n        if (direction === 'rtl') {\r\n          switch (getRTLOffsetType()) {\r\n            case 'negative':\r\n              calculatedScrollLeft = -scrollLeft;\r\n              break;\r\n            case 'positive-descending':\r\n              calculatedScrollLeft = scrollWidth - clientWidth - scrollLeft;\r\n              break;\r\n          }\r\n        }\r\n\r\n        // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\r\n        calculatedScrollLeft = Math.max(\r\n          0,\r\n          Math.min(calculatedScrollLeft, scrollWidth - clientWidth)\r\n        );\r\n        const calculatedScrollTop = Math.max(\r\n          0,\r\n          Math.min(scrollTop, scrollHeight - clientHeight)\r\n        );\r\n\r\n        return {\r\n          isScrolling: true,\r\n          horizontalScrollDirection:\r\n            prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\r\n          scrollLeft: calculatedScrollLeft,\r\n          scrollTop: calculatedScrollTop,\r\n          verticalScrollDirection:\r\n            prevState.scrollTop < scrollTop ? 'forward' : 'backward',\r\n          scrollUpdateWasRequested: false,\r\n        };\r\n      }, this._resetIsScrollingDebounced);\r\n    };\r\n\r\n    _outerRefSetter = (ref: any): void => {\r\n      const { outerRef } = this.props;\r\n\r\n      this._outerRef = ((ref: any): HTMLDivElement);\r\n\r\n      if (typeof outerRef === 'function') {\r\n        outerRef(ref);\r\n      } else if (\r\n        outerRef != null &&\r\n        typeof outerRef === 'object' &&\r\n        outerRef.hasOwnProperty('current')\r\n      ) {\r\n        outerRef.current = ref;\r\n      }\r\n    };\r\n\r\n    _resetIsScrollingDebounced = () => {\r\n      if (this._resetIsScrollingTimeoutId !== null) {\r\n        cancelTimeout(this._resetIsScrollingTimeoutId);\r\n      }\r\n\r\n      this._resetIsScrollingTimeoutId = requestTimeout(\r\n        this._resetIsScrolling,\r\n        IS_SCROLLING_DEBOUNCE_INTERVAL\r\n      );\r\n    };\r\n\r\n    _resetIsScrolling = () => {\r\n      this._resetIsScrollingTimeoutId = null;\r\n\r\n      this.setState({ isScrolling: false }, () => {\r\n        // Clear style cache after state update has been committed.\r\n        // This way we don't break pure sCU for items that don't use isScrolling param.\r\n        this._getItemStyleCache(-1);\r\n      });\r\n    };\r\n  };\r\n}\r\n\r\nconst validateSharedProps = (\r\n  {\r\n    children,\r\n    direction,\r\n    height,\r\n    innerTagName,\r\n    outerTagName,\r\n    overscanColumnsCount,\r\n    overscanCount,\r\n    overscanRowsCount,\r\n    width,\r\n  }: Props<any>,\r\n  { instance }: State\r\n): void => {\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    if (typeof overscanCount === 'number') {\r\n      if (devWarningsOverscanCount && !devWarningsOverscanCount.has(instance)) {\r\n        devWarningsOverscanCount.add(instance);\r\n        console.warn(\r\n          'The overscanCount prop has been deprecated. ' +\r\n            'Please use the overscanColumnCount and overscanRowCount props instead.'\r\n        );\r\n      }\r\n    }\r\n\r\n    if (\r\n      typeof overscanColumnsCount === 'number' ||\r\n      typeof overscanRowsCount === 'number'\r\n    ) {\r\n      if (\r\n        devWarningsOverscanRowsColumnsCount &&\r\n        !devWarningsOverscanRowsColumnsCount.has(instance)\r\n      ) {\r\n        devWarningsOverscanRowsColumnsCount.add(instance);\r\n        console.warn(\r\n          'The overscanColumnsCount and overscanRowsCount props have been deprecated. ' +\r\n            'Please use the overscanColumnCount and overscanRowCount props instead.'\r\n        );\r\n      }\r\n    }\r\n\r\n    if (innerTagName != null || outerTagName != null) {\r\n      if (devWarningsTagName && !devWarningsTagName.has(instance)) {\r\n        devWarningsTagName.add(instance);\r\n        console.warn(\r\n          'The innerTagName and outerTagName props have been deprecated. ' +\r\n            'Please use the innerElementType and outerElementType props instead.'\r\n        );\r\n      }\r\n    }\r\n\r\n    if (children == null) {\r\n      throw Error(\r\n        'An invalid \"children\" prop has been specified. ' +\r\n          'Value should be a React component. ' +\r\n          `\"${children === null ? 'null' : typeof children}\" was specified.`\r\n      );\r\n    }\r\n\r\n    switch (direction) {\r\n      case 'ltr':\r\n      case 'rtl':\r\n        // Valid values\r\n        break;\r\n      default:\r\n        throw Error(\r\n          'An invalid \"direction\" prop has been specified. ' +\r\n            'Value should be either \"ltr\" or \"rtl\". ' +\r\n            `\"${direction}\" was specified.`\r\n        );\r\n    }\r\n\r\n    if (typeof width !== 'number') {\r\n      throw Error(\r\n        'An invalid \"width\" prop has been specified. ' +\r\n          'Grids must specify a number for width. ' +\r\n          `\"${width === null ? 'null' : typeof width}\" was specified.`\r\n      );\r\n    }\r\n\r\n    if (typeof height !== 'number') {\r\n      throw Error(\r\n        'An invalid \"height\" prop has been specified. ' +\r\n          'Grids must specify a number for height. ' +\r\n          `\"${height === null ? 'null' : typeof height}\" was specified.`\r\n      );\r\n    }\r\n  }\r\n};\r\n","// @flow\r\n\r\nimport createGridComponent from './createGridComponent';\r\n\r\nimport type { Props, ScrollToAlign } from './createGridComponent';\r\n\r\nconst DEFAULT_ESTIMATED_ITEM_SIZE = 50;\r\n\r\ntype VariableSizeProps = {|\r\n  estimatedColumnWidth: number,\r\n  estimatedRowHeight: number,\r\n  disableColVirtualized?: boolean,\r\n  disableRowVirtualized?: boolean,\r\n  ...Props<any>,\r\n|};\r\n\r\ntype itemSizeGetter = (index: number) => number;\r\ntype ItemType = 'column' | 'row';\r\n\r\ntype ItemMetadata = {|\r\n  offset: number,\r\n  size: number,\r\n|};\r\ntype ItemMetadataMap = { [index: number]: ItemMetadata };\r\ntype InstanceProps = {|\r\n  columnMetadataMap: ItemMetadataMap,\r\n  estimatedColumnWidth: number,\r\n  estimatedRowHeight: number,\r\n  lastMeasuredColumnIndex: number,\r\n  lastMeasuredRowIndex: number,\r\n  rowMetadataMap: ItemMetadataMap,\r\n|};\r\n\r\nconst getEstimatedTotalHeight = (\r\n  { rowCount }: Props<any>,\r\n  { rowMetadataMap, estimatedRowHeight, lastMeasuredRowIndex }: InstanceProps\r\n) => {\r\n  let totalSizeOfMeasuredRows = 0;\r\n\r\n  // Edge case check for when the number of items decreases while a scroll is in progress.\r\n  // https://github.com/bvaughn/react-window/pull/138\r\n  if (lastMeasuredRowIndex >= rowCount) {\r\n    lastMeasuredRowIndex = rowCount - 1;\r\n  }\r\n\r\n  if (lastMeasuredRowIndex >= 0) {\r\n    const itemMetadata = rowMetadataMap[lastMeasuredRowIndex];\r\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\r\n  }\r\n\r\n  const numUnmeasuredItems = rowCount - lastMeasuredRowIndex - 1;\r\n  const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedRowHeight;\r\n\r\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\r\n};\r\n\r\nconst getEstimatedTotalWidth = (\r\n  { columnCount }: Props<any>,\r\n  {\r\n    columnMetadataMap,\r\n    estimatedColumnWidth,\r\n    lastMeasuredColumnIndex,\r\n  }: InstanceProps\r\n) => {\r\n  let totalSizeOfMeasuredRows = 0;\r\n\r\n  // Edge case check for when the number of items decreases while a scroll is in progress.\r\n  // https://github.com/bvaughn/react-window/pull/138\r\n  if (lastMeasuredColumnIndex >= columnCount) {\r\n    lastMeasuredColumnIndex = columnCount - 1;\r\n  }\r\n\r\n  if (lastMeasuredColumnIndex >= 0) {\r\n    const itemMetadata = columnMetadataMap[lastMeasuredColumnIndex];\r\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\r\n  }\r\n\r\n  const numUnmeasuredItems = columnCount - lastMeasuredColumnIndex - 1;\r\n  const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedColumnWidth;\r\n\r\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\r\n};\r\n\r\nconst getItemMetadata = (\r\n  itemType: ItemType,\r\n  props: Props<any>,\r\n  index: number,\r\n  instanceProps: InstanceProps\r\n): ItemMetadata => {\r\n  let itemMetadataMap, itemSize, lastMeasuredIndex;\r\n  if (itemType === 'column') {\r\n    itemMetadataMap = instanceProps.columnMetadataMap;\r\n    itemSize = ((props.columnWidth: any): itemSizeGetter);\r\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\r\n  } else {\r\n    itemMetadataMap = instanceProps.rowMetadataMap;\r\n    itemSize = ((props.rowHeight: any): itemSizeGetter);\r\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\r\n  }\r\n\r\n  if (index > lastMeasuredIndex) {\r\n    let offset = 0;\r\n    if (lastMeasuredIndex >= 0) {\r\n      const itemMetadata = itemMetadataMap[lastMeasuredIndex];\r\n      offset = itemMetadata.offset + itemMetadata.size;\r\n    }\r\n\r\n    for (let i = lastMeasuredIndex + 1; i <= index; i++) {\r\n      let size = itemSize(i);\r\n\r\n      itemMetadataMap[i] = {\r\n        offset,\r\n        size,\r\n      };\r\n\r\n      offset += size;\r\n    }\r\n\r\n    if (itemType === 'column') {\r\n      instanceProps.lastMeasuredColumnIndex = index;\r\n    } else {\r\n      instanceProps.lastMeasuredRowIndex = index;\r\n    }\r\n  }\r\n\r\n  return itemMetadataMap[index];\r\n};\r\n\r\nconst findNearestItem = (\r\n  itemType: ItemType,\r\n  props: Props<any>,\r\n  instanceProps: InstanceProps,\r\n  offset: number\r\n) => {\r\n  let itemMetadataMap, lastMeasuredIndex;\r\n  if (itemType === 'column') {\r\n    itemMetadataMap = instanceProps.columnMetadataMap;\r\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\r\n  } else {\r\n    itemMetadataMap = instanceProps.rowMetadataMap;\r\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\r\n  }\r\n\r\n  const lastMeasuredItemOffset =\r\n    lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\r\n\r\n  if (lastMeasuredItemOffset >= offset) {\r\n    // If we've already measured items within this range just use a binary search as it's faster.\r\n    return findNearestItemBinarySearch(\r\n      itemType,\r\n      props,\r\n      instanceProps,\r\n      lastMeasuredIndex,\r\n      0,\r\n      offset\r\n    );\r\n  } else {\r\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\r\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\r\n    // The overall complexity for this approach is O(log n).\r\n    return findNearestItemExponentialSearch(\r\n      itemType,\r\n      props,\r\n      instanceProps,\r\n      Math.max(0, lastMeasuredIndex),\r\n      offset\r\n    );\r\n  }\r\n};\r\n\r\nconst findNearestItemBinarySearch = (\r\n  itemType: ItemType,\r\n  props: Props<any>,\r\n  instanceProps: InstanceProps,\r\n  high: number,\r\n  low: number,\r\n  offset: number\r\n): number => {\r\n  while (low <= high) {\r\n    const middle = low + Math.floor((high - low) / 2);\r\n    const currentOffset = getItemMetadata(\r\n      itemType,\r\n      props,\r\n      middle,\r\n      instanceProps\r\n    ).offset;\r\n\r\n    if (currentOffset === offset) {\r\n      return middle;\r\n    } else if (currentOffset < offset) {\r\n      low = middle + 1;\r\n    } else if (currentOffset > offset) {\r\n      high = middle - 1;\r\n    }\r\n  }\r\n\r\n  if (low > 0) {\r\n    return low - 1;\r\n  } else {\r\n    return 0;\r\n  }\r\n};\r\n\r\nconst findNearestItemExponentialSearch = (\r\n  itemType: ItemType,\r\n  props: Props<any>,\r\n  instanceProps: InstanceProps,\r\n  index: number,\r\n  offset: number\r\n): number => {\r\n  const itemCount = itemType === 'column' ? props.columnCount : props.rowCount;\r\n  let interval = 1;\r\n\r\n  while (\r\n    index < itemCount &&\r\n    getItemMetadata(itemType, props, index, instanceProps).offset < offset\r\n  ) {\r\n    index += interval;\r\n    interval *= 2;\r\n  }\r\n\r\n  return findNearestItemBinarySearch(\r\n    itemType,\r\n    props,\r\n    instanceProps,\r\n    Math.min(index, itemCount - 1),\r\n    Math.floor(index / 2),\r\n    offset\r\n  );\r\n};\r\n\r\nconst getOffsetForIndexAndAlignment = (\r\n  itemType: ItemType,\r\n  props: Props<any>,\r\n  index: number,\r\n  align: ScrollToAlign,\r\n  scrollOffset: number,\r\n  instanceProps: InstanceProps,\r\n  scrollbarSize: number\r\n): number => {\r\n  const size = itemType === 'column' ? props.width : props.height;\r\n  const itemMetadata = getItemMetadata(itemType, props, index, instanceProps);\r\n\r\n  // Get estimated total size after ItemMetadata is computed,\r\n  // To ensure it reflects actual measurements instead of just estimates.\r\n  const estimatedTotalSize =\r\n    itemType === 'column'\r\n      ? getEstimatedTotalWidth(props, instanceProps)\r\n      : getEstimatedTotalHeight(props, instanceProps);\r\n\r\n  const maxOffset = Math.max(\r\n    0,\r\n    Math.min(estimatedTotalSize - size, itemMetadata.offset)\r\n  );\r\n  const minOffset = Math.max(\r\n    0,\r\n    itemMetadata.offset - size + scrollbarSize + itemMetadata.size\r\n  );\r\n\r\n  if (align === 'smart') {\r\n    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\r\n      align = 'auto';\r\n    } else {\r\n      align = 'center';\r\n    }\r\n  }\r\n\r\n  switch (align) {\r\n    case 'start':\r\n      return maxOffset;\r\n    case 'end':\r\n      return minOffset;\r\n    case 'center':\r\n      return Math.round(minOffset + (maxOffset - minOffset) / 2);\r\n    case 'auto':\r\n    default:\r\n      if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\r\n        return scrollOffset;\r\n      } else if (minOffset > maxOffset) {\r\n        // Because we only take into account the scrollbar size when calculating minOffset\r\n        // this value can be larger than maxOffset when at the end of the list\r\n        return minOffset;\r\n      } else if (scrollOffset < minOffset) {\r\n        return minOffset;\r\n      } else {\r\n        return maxOffset;\r\n      }\r\n  }\r\n};\r\n\r\nconst VariableSizeGrid = createGridComponent({\r\n  getColumnOffset: (\r\n    props: Props<any>,\r\n    index: number,\r\n    instanceProps: InstanceProps\r\n  ): number => getItemMetadata('column', props, index, instanceProps).offset,\r\n\r\n  getColumnStartIndexForOffset: (\r\n    props: Props<any>,\r\n    scrollLeft: number,\r\n    instanceProps: InstanceProps\r\n  ): number => findNearestItem('column', props, instanceProps, scrollLeft),\r\n\r\n  getColumnStopIndexForStartIndex: (\r\n    props: Props<any>,\r\n    startIndex: number,\r\n    scrollLeft: number,\r\n    instanceProps: InstanceProps\r\n  ): number => {\r\n    const { columnCount, width } = props;\r\n\r\n    const itemMetadata = getItemMetadata(\r\n      'column',\r\n      props,\r\n      startIndex,\r\n      instanceProps\r\n    );\r\n    const maxOffset = scrollLeft + width;\r\n\r\n    let offset = itemMetadata.offset + itemMetadata.size;\r\n    let stopIndex = startIndex;\r\n\r\n    while (stopIndex < columnCount - 1 && offset < maxOffset) {\r\n      stopIndex++;\r\n      offset += getItemMetadata('column', props, stopIndex, instanceProps).size;\r\n    }\r\n\r\n    return stopIndex;\r\n  },\r\n\r\n  getColumnWidth: (\r\n    props: Props<any>,\r\n    index: number,\r\n    instanceProps: InstanceProps\r\n  ): number => instanceProps.columnMetadataMap[index].size,\r\n\r\n  getEstimatedTotalHeight,\r\n  getEstimatedTotalWidth,\r\n\r\n  getOffsetForColumnAndAlignment: (\r\n    props: Props<any>,\r\n    index: number,\r\n    align: ScrollToAlign,\r\n    scrollOffset: number,\r\n    instanceProps: InstanceProps,\r\n    scrollbarSize: number\r\n  ): number =>\r\n    getOffsetForIndexAndAlignment(\r\n      'column',\r\n      props,\r\n      index,\r\n      align,\r\n      scrollOffset,\r\n      instanceProps,\r\n      scrollbarSize\r\n    ),\r\n\r\n  getOffsetForRowAndAlignment: (\r\n    props: Props<any>,\r\n    index: number,\r\n    align: ScrollToAlign,\r\n    scrollOffset: number,\r\n    instanceProps: InstanceProps,\r\n    scrollbarSize: number\r\n  ): number =>\r\n    getOffsetForIndexAndAlignment(\r\n      'row',\r\n      props,\r\n      index,\r\n      align,\r\n      scrollOffset,\r\n      instanceProps,\r\n      scrollbarSize\r\n    ),\r\n\r\n  getRowOffset: (\r\n    props: Props<any>,\r\n    index: number,\r\n    instanceProps: InstanceProps\r\n  ): number => getItemMetadata('row', props, index, instanceProps).offset,\r\n\r\n  getRowHeight: (\r\n    props: Props<any>,\r\n    index: number,\r\n    instanceProps: InstanceProps\r\n  ): number => instanceProps.rowMetadataMap[index].size,\r\n\r\n  getRowStartIndexForOffset: (\r\n    props: Props<any>,\r\n    scrollTop: number,\r\n    instanceProps: InstanceProps\r\n  ): number => findNearestItem('row', props, instanceProps, scrollTop),\r\n\r\n  getRowStopIndexForStartIndex: (\r\n    props: Props<any>,\r\n    startIndex: number,\r\n    scrollTop: number,\r\n    instanceProps: InstanceProps\r\n  ): number => {\r\n    const { rowCount, height } = props;\r\n\r\n    const itemMetadata = getItemMetadata(\r\n      'row',\r\n      props,\r\n      startIndex,\r\n      instanceProps\r\n    );\r\n    const maxOffset = scrollTop + height;\r\n\r\n    let offset = itemMetadata.offset + itemMetadata.size;\r\n    let stopIndex = startIndex;\r\n\r\n    while (stopIndex < rowCount - 1 && offset < maxOffset) {\r\n      stopIndex++;\r\n      offset += getItemMetadata('row', props, stopIndex, instanceProps).size;\r\n    }\r\n\r\n    return stopIndex;\r\n  },\r\n\r\n  initInstanceProps(props: Props<any>, instance: any): InstanceProps {\r\n    const {\r\n      estimatedColumnWidth,\r\n      estimatedRowHeight,\r\n    } = ((props: any): VariableSizeProps);\r\n\r\n    const instanceProps = {\r\n      columnMetadataMap: {},\r\n      estimatedColumnWidth: estimatedColumnWidth || DEFAULT_ESTIMATED_ITEM_SIZE,\r\n      estimatedRowHeight: estimatedRowHeight || DEFAULT_ESTIMATED_ITEM_SIZE,\r\n      lastMeasuredColumnIndex: -1,\r\n      lastMeasuredRowIndex: -1,\r\n      rowMetadataMap: {},\r\n    };\r\n\r\n    instance.resetAfterColumnIndex = (\r\n      columnIndex: number,\r\n      shouldForceUpdate?: boolean = true\r\n    ) => {\r\n      instance.resetAfterIndices({ columnIndex, shouldForceUpdate });\r\n    };\r\n\r\n    instance.resetAfterRowIndex = (\r\n      rowIndex: number,\r\n      shouldForceUpdate?: boolean = true\r\n    ) => {\r\n      instance.resetAfterIndices({ rowIndex, shouldForceUpdate });\r\n    };\r\n\r\n    instance.resetAfterIndices = ({\r\n      columnIndex,\r\n      rowIndex,\r\n      shouldForceUpdate = true,\r\n    }: {\r\n      columnIndex?: number,\r\n      rowIndex?: number,\r\n      shouldForceUpdate: boolean,\r\n    }) => {\r\n      if (typeof columnIndex === 'number') {\r\n        instanceProps.lastMeasuredColumnIndex = Math.min(\r\n          instanceProps.lastMeasuredColumnIndex,\r\n          columnIndex - 1\r\n        );\r\n      }\r\n      if (typeof rowIndex === 'number') {\r\n        instanceProps.lastMeasuredRowIndex = Math.min(\r\n          instanceProps.lastMeasuredRowIndex,\r\n          rowIndex - 1\r\n        );\r\n      }\r\n\r\n      // We could potentially optimize further by only evicting styles after this index,\r\n      // But since styles are only cached while scrolling is in progress-\r\n      // It seems an unnecessary optimization.\r\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\r\n      instance._getItemStyleCache(-1);\r\n\r\n      if (shouldForceUpdate) {\r\n        instance.forceUpdate();\r\n      }\r\n    };\r\n\r\n    return instanceProps;\r\n  },\r\n\r\n  shouldResetStyleCacheOnItemSizeChange: false,\r\n\r\n  validateProps: ({ columnWidth, rowHeight }: Props<any>): void => {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      if (typeof columnWidth !== 'function') {\r\n        throw Error(\r\n          'An invalid \"columnWidth\" prop has been specified. ' +\r\n            'Value should be a function. ' +\r\n            `\"${\r\n              columnWidth === null ? 'null' : typeof columnWidth\r\n            }\" was specified.`\r\n        );\r\n      } else if (typeof rowHeight !== 'function') {\r\n        throw Error(\r\n          'An invalid \"rowHeight\" prop has been specified. ' +\r\n            'Value should be a function. ' +\r\n            `\"${rowHeight === null ? 'null' : typeof rowHeight}\" was specified.`\r\n        );\r\n      }\r\n    }\r\n  },\r\n});\r\n\r\nexport default VariableSizeGrid;\r\n","// @flow\r\n\r\nimport memoizeOne from 'memoize-one';\r\nimport { createElement, PureComponent } from 'react';\r\nimport { cancelTimeout, requestTimeout } from './timer';\r\nimport { getScrollbarSize, getRTLOffsetType } from './domHelpers';\r\n\r\nimport type { TimeoutID } from './timer';\r\n\r\nexport type ScrollToAlign = 'auto' | 'smart' | 'center' | 'start' | 'end';\r\n\r\ntype itemSize = number | ((index: number) => number);\r\n// TODO Deprecate directions \"horizontal\" and \"vertical\"\r\ntype Direction = 'ltr' | 'rtl' | 'horizontal' | 'vertical';\r\ntype Layout = 'horizontal' | 'vertical';\r\n\r\ntype RenderComponentProps<T> = {|\r\n  data: T,\r\n  index: number,\r\n  isScrolling?: boolean,\r\n  style: Object,\r\n|};\r\ntype RenderComponent<T> = React$ComponentType<$Shape<RenderComponentProps<T>>>;\r\n\r\ntype ScrollDirection = 'forward' | 'backward';\r\n\r\ntype onItemsRenderedCallback = ({\r\n  overscanStartIndex: number,\r\n  overscanStopIndex: number,\r\n  visibleStartIndex: number,\r\n  visibleStopIndex: number,\r\n}) => void;\r\ntype onScrollCallback = ({\r\n  scrollDirection: ScrollDirection,\r\n  scrollOffset: number,\r\n  scrollUpdateWasRequested: boolean,\r\n}) => void;\r\n\r\ntype ScrollEvent = SyntheticEvent<HTMLDivElement>;\r\ntype ItemStyleCache = { [index: number]: Object };\r\n\r\ntype OuterProps = {|\r\n  children: React$Node,\r\n  className: string | void,\r\n  onScroll: ScrollEvent => void,\r\n  style: {\r\n    [string]: mixed,\r\n  },\r\n|};\r\n\r\ntype InnerProps = {|\r\n  children: React$Node,\r\n  style: {\r\n    [string]: mixed,\r\n  },\r\n|};\r\n\r\nexport type Props<T> = {|\r\n  children: RenderComponent<T>,\r\n  className?: string,\r\n  direction: Direction,\r\n  height: number | string,\r\n  initialScrollOffset?: number,\r\n  innerRef?: any,\r\n  innerElementType?: string | React$AbstractComponent<InnerProps, any>,\r\n  innerTagName?: string, // deprecated\r\n  itemCount: number,\r\n  itemData: T,\r\n  itemKey?: (index: number, data: T) => any,\r\n  itemSize: itemSize,\r\n  layout: Layout,\r\n  onItemsRendered?: onItemsRenderedCallback,\r\n  onScroll?: onScrollCallback,\r\n  outerRef?: any,\r\n  outerElementType?: string | React$AbstractComponent<OuterProps, any>,\r\n  outerTagName?: string, // deprecated\r\n  overscanCount: number,\r\n  style?: Object,\r\n  useIsScrolling: boolean,\r\n  width: number | string,\r\n|};\r\n\r\ntype State = {|\r\n  instance: any,\r\n  isScrolling: boolean,\r\n  scrollDirection: ScrollDirection,\r\n  scrollOffset: number,\r\n  scrollUpdateWasRequested: boolean,\r\n|};\r\n\r\ntype GetItemOffset = (\r\n  props: Props<any>,\r\n  index: number,\r\n  instanceProps: any\r\n) => number;\r\ntype GetItemSize = (\r\n  props: Props<any>,\r\n  index: number,\r\n  instanceProps: any\r\n) => number;\r\ntype GetEstimatedTotalSize = (props: Props<any>, instanceProps: any) => number;\r\ntype GetOffsetForIndexAndAlignment = (\r\n  props: Props<any>,\r\n  index: number,\r\n  align: ScrollToAlign,\r\n  scrollOffset: number,\r\n  instanceProps: any\r\n) => number;\r\ntype GetStartIndexForOffset = (\r\n  props: Props<any>,\r\n  offset: number,\r\n  instanceProps: any\r\n) => number;\r\ntype GetStopIndexForStartIndex = (\r\n  props: Props<any>,\r\n  startIndex: number,\r\n  scrollOffset: number,\r\n  instanceProps: any\r\n) => number;\r\ntype InitInstanceProps = (props: Props<any>, instance: any) => any;\r\ntype ValidateProps = (props: Props<any>) => void;\r\n\r\nconst IS_SCROLLING_DEBOUNCE_INTERVAL = 150;\r\n\r\nconst defaultItemKey = (index: number, data: any) => index;\r\n\r\n// In DEV mode, this Set helps us only log a warning once per component instance.\r\n// This avoids spamming the console every time a render happens.\r\nlet devWarningsDirection = null;\r\nlet devWarningsTagName = null;\r\nif (process.env.NODE_ENV !== 'production') {\r\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\r\n    devWarningsDirection = new WeakSet();\r\n    devWarningsTagName = new WeakSet();\r\n  }\r\n}\r\n\r\nexport default function createListComponent({\r\n  getItemOffset,\r\n  getEstimatedTotalSize,\r\n  getItemSize,\r\n  getOffsetForIndexAndAlignment,\r\n  getStartIndexForOffset,\r\n  getStopIndexForStartIndex,\r\n  initInstanceProps,\r\n  shouldResetStyleCacheOnItemSizeChange,\r\n  validateProps,\r\n}: {|\r\n  getItemOffset: GetItemOffset,\r\n  getEstimatedTotalSize: GetEstimatedTotalSize,\r\n  getItemSize: GetItemSize,\r\n  getOffsetForIndexAndAlignment: GetOffsetForIndexAndAlignment,\r\n  getStartIndexForOffset: GetStartIndexForOffset,\r\n  getStopIndexForStartIndex: GetStopIndexForStartIndex,\r\n  initInstanceProps: InitInstanceProps,\r\n  shouldResetStyleCacheOnItemSizeChange: boolean,\r\n  validateProps: ValidateProps,\r\n|}) {\r\n  return class List<T> extends PureComponent<Props<T>, State> {\r\n    _instanceProps: any = initInstanceProps(this.props, this);\r\n    _outerRef: ?HTMLDivElement;\r\n    _resetIsScrollingTimeoutId: TimeoutID | null = null;\r\n\r\n    static defaultProps = {\r\n      direction: 'ltr',\r\n      itemData: undefined,\r\n      layout: 'vertical',\r\n      overscanCount: 2,\r\n      useIsScrolling: false,\r\n    };\r\n\r\n    state: State = {\r\n      instance: this,\r\n      isScrolling: false,\r\n      scrollDirection: 'forward',\r\n      scrollOffset:\r\n        typeof this.props.initialScrollOffset === 'number'\r\n          ? this.props.initialScrollOffset\r\n          : 0,\r\n      scrollUpdateWasRequested: false,\r\n    };\r\n\r\n    // Always use explicit constructor for React components.\r\n    // It produces less code after transpilation. (#26)\r\n    // eslint-disable-next-line no-useless-constructor\r\n    constructor(props: Props<T>) {\r\n      super(props);\r\n    }\r\n\r\n    static getDerivedStateFromProps(\r\n      nextProps: Props<T>,\r\n      prevState: State\r\n    ): $Shape<State> | null {\r\n      validateSharedProps(nextProps, prevState);\r\n      validateProps(nextProps);\r\n      return null;\r\n    }\r\n\r\n    scrollTo(scrollOffset: number): void {\r\n      scrollOffset = Math.max(0, scrollOffset);\r\n\r\n      this.setState(prevState => {\r\n        if (prevState.scrollOffset === scrollOffset) {\r\n          return null;\r\n        }\r\n        return {\r\n          scrollDirection:\r\n            prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\r\n          scrollOffset: scrollOffset,\r\n          scrollUpdateWasRequested: true,\r\n        };\r\n      }, this._resetIsScrollingDebounced);\r\n    }\r\n\r\n    scrollToItem(index: number, align: ScrollToAlign = 'auto'): void {\r\n      const { itemCount, layout } = this.props;\r\n      const { scrollOffset } = this.state;\r\n\r\n      index = Math.max(0, Math.min(index, itemCount - 1));\r\n\r\n      // The scrollbar size should be considered when scrolling an item into view, to ensure it's fully visible.\r\n      // But we only need to account for its size when it's actually visible.\r\n      // This is an edge case for lists; normally they only scroll in the dominant direction.\r\n      let scrollbarSize = 0;\r\n      if (this._outerRef) {\r\n        const outerRef = ((this._outerRef: any): HTMLElement);\r\n        if (layout === 'vertical') {\r\n          scrollbarSize =\r\n            outerRef.scrollWidth > outerRef.clientWidth\r\n              ? getScrollbarSize()\r\n              : 0;\r\n        } else {\r\n          scrollbarSize =\r\n            outerRef.scrollHeight > outerRef.clientHeight\r\n              ? getScrollbarSize()\r\n              : 0;\r\n        }\r\n      }\r\n\r\n      this.scrollTo(\r\n        getOffsetForIndexAndAlignment(\r\n          this.props,\r\n          index,\r\n          align,\r\n          scrollOffset,\r\n          this._instanceProps,\r\n          scrollbarSize\r\n        )\r\n      );\r\n    }\r\n\r\n    componentDidMount() {\r\n      const { direction, initialScrollOffset, layout } = this.props;\r\n\r\n      if (typeof initialScrollOffset === 'number' && this._outerRef != null) {\r\n        const outerRef = ((this._outerRef: any): HTMLElement);\r\n        // TODO Deprecate direction \"horizontal\"\r\n        if (direction === 'horizontal' || layout === 'horizontal') {\r\n          outerRef.scrollLeft = initialScrollOffset;\r\n        } else {\r\n          outerRef.scrollTop = initialScrollOffset;\r\n        }\r\n      }\r\n\r\n      this._callPropsCallbacks();\r\n    }\r\n\r\n    componentDidUpdate() {\r\n      const { direction, layout } = this.props;\r\n      const { scrollOffset, scrollUpdateWasRequested } = this.state;\r\n\r\n      if (scrollUpdateWasRequested && this._outerRef != null) {\r\n        const outerRef = ((this._outerRef: any): HTMLElement);\r\n\r\n        // TODO Deprecate direction \"horizontal\"\r\n        if (direction === 'horizontal' || layout === 'horizontal') {\r\n          if (direction === 'rtl') {\r\n            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\r\n            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\r\n            // So we need to determine which browser behavior we're dealing with, and mimic it.\r\n            switch (getRTLOffsetType()) {\r\n              case 'negative':\r\n                outerRef.scrollLeft = -scrollOffset;\r\n                break;\r\n              case 'positive-ascending':\r\n                outerRef.scrollLeft = scrollOffset;\r\n                break;\r\n              default:\r\n                const { clientWidth, scrollWidth } = outerRef;\r\n                outerRef.scrollLeft = scrollWidth - clientWidth - scrollOffset;\r\n                break;\r\n            }\r\n          } else {\r\n            outerRef.scrollLeft = scrollOffset;\r\n          }\r\n        } else {\r\n          outerRef.scrollTop = scrollOffset;\r\n        }\r\n      }\r\n\r\n      this._callPropsCallbacks();\r\n    }\r\n\r\n    componentWillUnmount() {\r\n      if (this._resetIsScrollingTimeoutId !== null) {\r\n        cancelTimeout(this._resetIsScrollingTimeoutId);\r\n      }\r\n    }\r\n\r\n    render() {\r\n      const {\r\n        children,\r\n        className,\r\n        direction,\r\n        height,\r\n        innerRef,\r\n        innerElementType,\r\n        innerTagName,\r\n        itemCount,\r\n        itemData,\r\n        itemKey = defaultItemKey,\r\n        layout,\r\n        outerElementType,\r\n        outerTagName,\r\n        style,\r\n        useIsScrolling,\r\n        width,\r\n      } = this.props;\r\n      const { isScrolling } = this.state;\r\n\r\n      // TODO Deprecate direction \"horizontal\"\r\n      const isHorizontal =\r\n        direction === 'horizontal' || layout === 'horizontal';\r\n\r\n      const onScroll = isHorizontal\r\n        ? this._onScrollHorizontal\r\n        : this._onScrollVertical;\r\n\r\n      const [startIndex, stopIndex] = this._getRangeToRender();\r\n\r\n      const items = [];\r\n      if (itemCount > 0) {\r\n        for (let index = startIndex; index <= stopIndex; index++) {\r\n          items.push(\r\n            createElement(children, {\r\n              data: itemData,\r\n              key: itemKey(index, itemData),\r\n              index,\r\n              isScrolling: useIsScrolling ? isScrolling : undefined,\r\n              style: this._getItemStyle(index),\r\n            })\r\n          );\r\n        }\r\n      }\r\n\r\n      // Read this value AFTER items have been created,\r\n      // So their actual sizes (if variable) are taken into consideration.\r\n      const estimatedTotalSize = getEstimatedTotalSize(\r\n        this.props,\r\n        this._instanceProps\r\n      );\r\n\r\n      return createElement(\r\n        outerElementType || outerTagName || 'div',\r\n        {\r\n          className,\r\n          onScroll,\r\n          ref: this._outerRefSetter,\r\n          style: {\r\n            position: 'relative',\r\n            height,\r\n            width,\r\n            overflow: 'auto',\r\n            WebkitOverflowScrolling: 'touch',\r\n            willChange: 'transform',\r\n            direction,\r\n            ...style,\r\n          },\r\n        },\r\n        createElement(innerElementType || innerTagName || 'div', {\r\n          children: items,\r\n          ref: innerRef,\r\n          style: {\r\n            height: isHorizontal ? '100%' : estimatedTotalSize,\r\n            pointerEvents: isScrolling ? 'none' : undefined,\r\n            width: isHorizontal ? estimatedTotalSize : '100%',\r\n          },\r\n        })\r\n      );\r\n    }\r\n\r\n    _callOnItemsRendered: (\r\n      overscanStartIndex: number,\r\n      overscanStopIndex: number,\r\n      visibleStartIndex: number,\r\n      visibleStopIndex: number\r\n    ) => void;\r\n    _callOnItemsRendered = memoizeOne(\r\n      (\r\n        overscanStartIndex: number,\r\n        overscanStopIndex: number,\r\n        visibleStartIndex: number,\r\n        visibleStopIndex: number\r\n      ) =>\r\n        ((this.props.onItemsRendered: any): onItemsRenderedCallback)({\r\n          overscanStartIndex,\r\n          overscanStopIndex,\r\n          visibleStartIndex,\r\n          visibleStopIndex,\r\n        })\r\n    );\r\n\r\n    _callOnScroll: (\r\n      scrollDirection: ScrollDirection,\r\n      scrollOffset: number,\r\n      scrollUpdateWasRequested: boolean\r\n    ) => void;\r\n    _callOnScroll = memoizeOne(\r\n      (\r\n        scrollDirection: ScrollDirection,\r\n        scrollOffset: number,\r\n        scrollUpdateWasRequested: boolean\r\n      ) =>\r\n        ((this.props.onScroll: any): onScrollCallback)({\r\n          scrollDirection,\r\n          scrollOffset,\r\n          scrollUpdateWasRequested,\r\n        })\r\n    );\r\n\r\n    _callPropsCallbacks() {\r\n      if (typeof this.props.onItemsRendered === 'function') {\r\n        const { itemCount } = this.props;\r\n        if (itemCount > 0) {\r\n          const [\r\n            overscanStartIndex,\r\n            overscanStopIndex,\r\n            visibleStartIndex,\r\n            visibleStopIndex,\r\n          ] = this._getRangeToRender();\r\n          this._callOnItemsRendered(\r\n            overscanStartIndex,\r\n            overscanStopIndex,\r\n            visibleStartIndex,\r\n            visibleStopIndex\r\n          );\r\n        }\r\n      }\r\n\r\n      if (typeof this.props.onScroll === 'function') {\r\n        const {\r\n          scrollDirection,\r\n          scrollOffset,\r\n          scrollUpdateWasRequested,\r\n        } = this.state;\r\n        this._callOnScroll(\r\n          scrollDirection,\r\n          scrollOffset,\r\n          scrollUpdateWasRequested\r\n        );\r\n      }\r\n    }\r\n\r\n    // Lazily create and cache item styles while scrolling,\r\n    // So that pure component sCU will prevent re-renders.\r\n    // We maintain this cache, and pass a style prop rather than index,\r\n    // So that List can clear cached styles and force item re-render if necessary.\r\n    _getItemStyle: (index: number) => Object;\r\n    _getItemStyle = (index: number): Object => {\r\n      const { direction, itemSize, layout } = this.props;\r\n\r\n      const itemStyleCache = this._getItemStyleCache(\r\n        shouldResetStyleCacheOnItemSizeChange && itemSize,\r\n        shouldResetStyleCacheOnItemSizeChange && layout,\r\n        shouldResetStyleCacheOnItemSizeChange && direction\r\n      );\r\n\r\n      let style;\r\n      if (itemStyleCache.hasOwnProperty(index)) {\r\n        style = itemStyleCache[index];\r\n      } else {\r\n        const offset = getItemOffset(this.props, index, this._instanceProps);\r\n        const size = getItemSize(this.props, index, this._instanceProps);\r\n\r\n        // TODO Deprecate direction \"horizontal\"\r\n        const isHorizontal =\r\n          direction === 'horizontal' || layout === 'horizontal';\r\n\r\n        const isRtl = direction === 'rtl';\r\n        const offsetHorizontal = isHorizontal ? offset : 0;\r\n        itemStyleCache[index] = style = {\r\n          position: 'absolute',\r\n          left: isRtl ? undefined : offsetHorizontal,\r\n          right: isRtl ? offsetHorizontal : undefined,\r\n          top: !isHorizontal ? offset : 0,\r\n          height: !isHorizontal ? size : '100%',\r\n          width: isHorizontal ? size : '100%',\r\n        };\r\n      }\r\n\r\n      return style;\r\n    };\r\n\r\n    _getItemStyleCache: (_: any, __: any, ___: any) => ItemStyleCache;\r\n    _getItemStyleCache = memoizeOne((_: any, __: any, ___: any) => ({}));\r\n\r\n    _getRangeToRender(): [number, number, number, number] {\r\n      const { itemCount, overscanCount } = this.props;\r\n      const { isScrolling, scrollDirection, scrollOffset } = this.state;\r\n\r\n      if (itemCount === 0) {\r\n        return [0, 0, 0, 0];\r\n      }\r\n\r\n      const startIndex = getStartIndexForOffset(\r\n        this.props,\r\n        scrollOffset,\r\n        this._instanceProps\r\n      );\r\n      const stopIndex = getStopIndexForStartIndex(\r\n        this.props,\r\n        startIndex,\r\n        scrollOffset,\r\n        this._instanceProps\r\n      );\r\n\r\n      // Overscan by one item in each direction so that tab/focus works.\r\n      // If there isn't at least one extra item, tab loops back around.\r\n      const overscanBackward =\r\n        !isScrolling || scrollDirection === 'backward'\r\n          ? Math.max(1, overscanCount)\r\n          : 1;\r\n      const overscanForward =\r\n        !isScrolling || scrollDirection === 'forward'\r\n          ? Math.max(1, overscanCount)\r\n          : 1;\r\n\r\n      return [\r\n        Math.max(0, startIndex - overscanBackward),\r\n        Math.max(0, Math.min(itemCount - 1, stopIndex + overscanForward)),\r\n        startIndex,\r\n        stopIndex,\r\n      ];\r\n    }\r\n\r\n    _onScrollHorizontal = (event: ScrollEvent): void => {\r\n      const { clientWidth, scrollLeft, scrollWidth } = event.currentTarget;\r\n      this.setState(prevState => {\r\n        if (prevState.scrollOffset === scrollLeft) {\r\n          // Scroll position may have been updated by cDM/cDU,\r\n          // In which case we don't need to trigger another render,\r\n          // And we don't want to update state.isScrolling.\r\n          return null;\r\n        }\r\n\r\n        const { direction } = this.props;\r\n\r\n        let scrollOffset = scrollLeft;\r\n        if (direction === 'rtl') {\r\n          // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\r\n          // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\r\n          // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\r\n          // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\r\n          switch (getRTLOffsetType()) {\r\n            case 'negative':\r\n              scrollOffset = -scrollLeft;\r\n              break;\r\n            case 'positive-descending':\r\n              scrollOffset = scrollWidth - clientWidth - scrollLeft;\r\n              break;\r\n          }\r\n        }\r\n\r\n        // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\r\n        scrollOffset = Math.max(\r\n          0,\r\n          Math.min(scrollOffset, scrollWidth - clientWidth)\r\n        );\r\n\r\n        return {\r\n          isScrolling: true,\r\n          scrollDirection:\r\n            prevState.scrollOffset < scrollLeft ? 'forward' : 'backward',\r\n          scrollOffset,\r\n          scrollUpdateWasRequested: false,\r\n        };\r\n      }, this._resetIsScrollingDebounced);\r\n    };\r\n\r\n    _onScrollVertical = (event: ScrollEvent): void => {\r\n      const { clientHeight, scrollHeight, scrollTop } = event.currentTarget;\r\n      this.setState(prevState => {\r\n        if (prevState.scrollOffset === scrollTop) {\r\n          // Scroll position may have been updated by cDM/cDU,\r\n          // In which case we don't need to trigger another render,\r\n          // And we don't want to update state.isScrolling.\r\n          return null;\r\n        }\r\n\r\n        // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\r\n        const scrollOffset = Math.max(\r\n          0,\r\n          Math.min(scrollTop, scrollHeight - clientHeight)\r\n        );\r\n\r\n        return {\r\n          isScrolling: true,\r\n          scrollDirection:\r\n            prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\r\n          scrollOffset,\r\n          scrollUpdateWasRequested: false,\r\n        };\r\n      }, this._resetIsScrollingDebounced);\r\n    };\r\n\r\n    _outerRefSetter = (ref: any): void => {\r\n      const { outerRef } = this.props;\r\n\r\n      this._outerRef = ((ref: any): HTMLDivElement);\r\n\r\n      if (typeof outerRef === 'function') {\r\n        outerRef(ref);\r\n      } else if (\r\n        outerRef != null &&\r\n        typeof outerRef === 'object' &&\r\n        outerRef.hasOwnProperty('current')\r\n      ) {\r\n        outerRef.current = ref;\r\n      }\r\n    };\r\n\r\n    _resetIsScrollingDebounced = () => {\r\n      if (this._resetIsScrollingTimeoutId !== null) {\r\n        cancelTimeout(this._resetIsScrollingTimeoutId);\r\n      }\r\n\r\n      this._resetIsScrollingTimeoutId = requestTimeout(\r\n        this._resetIsScrolling,\r\n        IS_SCROLLING_DEBOUNCE_INTERVAL\r\n      );\r\n    };\r\n\r\n    _resetIsScrolling = () => {\r\n      this._resetIsScrollingTimeoutId = null;\r\n\r\n      this.setState({ isScrolling: false }, () => {\r\n        // Clear style cache after state update has been committed.\r\n        // This way we don't break pure sCU for items that don't use isScrolling param.\r\n        this._getItemStyleCache(-1, null);\r\n      });\r\n    };\r\n  };\r\n}\r\n\r\n// NOTE: I considered further wrapping individual items with a pure ListItem component.\r\n// This would avoid ever calling the render function for the same index more than once,\r\n// But it would also add the overhead of a lot of components/fibers.\r\n// I assume people already do this (render function returning a class component),\r\n// So my doing it would just unnecessarily double the wrappers.\r\n\r\nconst validateSharedProps = (\r\n  {\r\n    children,\r\n    direction,\r\n    height,\r\n    layout,\r\n    innerTagName,\r\n    outerTagName,\r\n    width,\r\n  }: Props<any>,\r\n  { instance }: State\r\n): void => {\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    if (innerTagName != null || outerTagName != null) {\r\n      if (devWarningsTagName && !devWarningsTagName.has(instance)) {\r\n        devWarningsTagName.add(instance);\r\n        console.warn(\r\n          'The innerTagName and outerTagName props have been deprecated. ' +\r\n            'Please use the innerElementType and outerElementType props instead.'\r\n        );\r\n      }\r\n    }\r\n\r\n    // TODO Deprecate direction \"horizontal\"\r\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\r\n\r\n    switch (direction) {\r\n      case 'horizontal':\r\n      case 'vertical':\r\n        if (devWarningsDirection && !devWarningsDirection.has(instance)) {\r\n          devWarningsDirection.add(instance);\r\n          console.warn(\r\n            'The direction prop should be either \"ltr\" (default) or \"rtl\". ' +\r\n              'Please use the layout prop to specify \"vertical\" (default) or \"horizontal\" orientation.'\r\n          );\r\n        }\r\n        break;\r\n      case 'ltr':\r\n      case 'rtl':\r\n        // Valid values\r\n        break;\r\n      default:\r\n        throw Error(\r\n          'An invalid \"direction\" prop has been specified. ' +\r\n            'Value should be either \"ltr\" or \"rtl\". ' +\r\n            `\"${direction}\" was specified.`\r\n        );\r\n    }\r\n\r\n    switch (layout) {\r\n      case 'horizontal':\r\n      case 'vertical':\r\n        // Valid values\r\n        break;\r\n      default:\r\n        throw Error(\r\n          'An invalid \"layout\" prop has been specified. ' +\r\n            'Value should be either \"horizontal\" or \"vertical\". ' +\r\n            `\"${layout}\" was specified.`\r\n        );\r\n    }\r\n\r\n    if (children == null) {\r\n      throw Error(\r\n        'An invalid \"children\" prop has been specified. ' +\r\n          'Value should be a React component. ' +\r\n          `\"${children === null ? 'null' : typeof children}\" was specified.`\r\n      );\r\n    }\r\n\r\n    if (isHorizontal && typeof width !== 'number') {\r\n      throw Error(\r\n        'An invalid \"width\" prop has been specified. ' +\r\n          'Horizontal lists must specify a number for width. ' +\r\n          `\"${width === null ? 'null' : typeof width}\" was specified.`\r\n      );\r\n    } else if (!isHorizontal && typeof height !== 'number') {\r\n      throw Error(\r\n        'An invalid \"height\" prop has been specified. ' +\r\n          'Vertical lists must specify a number for height. ' +\r\n          `\"${height === null ? 'null' : typeof height}\" was specified.`\r\n      );\r\n    }\r\n  }\r\n};\r\n","// @flow\r\n\r\nimport createListComponent from './createListComponent';\r\n\r\nimport type { Props, ScrollToAlign } from './createListComponent';\r\n\r\nconst DEFAULT_ESTIMATED_ITEM_SIZE = 50;\r\n\r\ntype VariableSizeProps = {|\r\n  estimatedItemSize: number,\r\n  ...Props<any>,\r\n|};\r\n\r\ntype itemSizeGetter = (index: number) => number;\r\n\r\ntype ItemMetadata = {|\r\n  offset: number,\r\n  size: number,\r\n|};\r\ntype InstanceProps = {|\r\n  itemMetadataMap: { [index: number]: ItemMetadata },\r\n  estimatedItemSize: number,\r\n  lastMeasuredIndex: number,\r\n|};\r\n\r\nconst getItemMetadata = (\r\n  props: Props<any>,\r\n  index: number,\r\n  instanceProps: InstanceProps\r\n): ItemMetadata => {\r\n  const { itemSize } = ((props: any): VariableSizeProps);\r\n  const { itemMetadataMap, lastMeasuredIndex } = instanceProps;\r\n\r\n  if (index > lastMeasuredIndex) {\r\n    let offset = 0;\r\n    if (lastMeasuredIndex >= 0) {\r\n      const itemMetadata = itemMetadataMap[lastMeasuredIndex];\r\n      offset = itemMetadata.offset + itemMetadata.size;\r\n    }\r\n\r\n    for (let i = lastMeasuredIndex + 1; i <= index; i++) {\r\n      let size = ((itemSize: any): itemSizeGetter)(i);\r\n\r\n      itemMetadataMap[i] = {\r\n        offset,\r\n        size,\r\n      };\r\n\r\n      offset += size;\r\n    }\r\n\r\n    instanceProps.lastMeasuredIndex = index;\r\n  }\r\n\r\n  return itemMetadataMap[index];\r\n};\r\n\r\nconst findNearestItem = (\r\n  props: Props<any>,\r\n  instanceProps: InstanceProps,\r\n  offset: number\r\n) => {\r\n  const { itemMetadataMap, lastMeasuredIndex } = instanceProps;\r\n\r\n  const lastMeasuredItemOffset =\r\n    lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\r\n\r\n  if (lastMeasuredItemOffset >= offset) {\r\n    // If we've already measured items within this range just use a binary search as it's faster.\r\n    return findNearestItemBinarySearch(\r\n      props,\r\n      instanceProps,\r\n      lastMeasuredIndex,\r\n      0,\r\n      offset\r\n    );\r\n  } else {\r\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\r\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\r\n    // The overall complexity for this approach is O(log n).\r\n    return findNearestItemExponentialSearch(\r\n      props,\r\n      instanceProps,\r\n      Math.max(0, lastMeasuredIndex),\r\n      offset\r\n    );\r\n  }\r\n};\r\n\r\nconst findNearestItemBinarySearch = (\r\n  props: Props<any>,\r\n  instanceProps: InstanceProps,\r\n  high: number,\r\n  low: number,\r\n  offset: number\r\n): number => {\r\n  while (low <= high) {\r\n    const middle = low + Math.floor((high - low) / 2);\r\n    const currentOffset = getItemMetadata(props, middle, instanceProps).offset;\r\n\r\n    if (currentOffset === offset) {\r\n      return middle;\r\n    } else if (currentOffset < offset) {\r\n      low = middle + 1;\r\n    } else if (currentOffset > offset) {\r\n      high = middle - 1;\r\n    }\r\n  }\r\n\r\n  if (low > 0) {\r\n    return low - 1;\r\n  } else {\r\n    return 0;\r\n  }\r\n};\r\n\r\nconst findNearestItemExponentialSearch = (\r\n  props: Props<any>,\r\n  instanceProps: InstanceProps,\r\n  index: number,\r\n  offset: number\r\n): number => {\r\n  const { itemCount } = props;\r\n  let interval = 1;\r\n\r\n  while (\r\n    index < itemCount &&\r\n    getItemMetadata(props, index, instanceProps).offset < offset\r\n  ) {\r\n    index += interval;\r\n    interval *= 2;\r\n  }\r\n\r\n  return findNearestItemBinarySearch(\r\n    props,\r\n    instanceProps,\r\n    Math.min(index, itemCount - 1),\r\n    Math.floor(index / 2),\r\n    offset\r\n  );\r\n};\r\n\r\nconst getEstimatedTotalSize = (\r\n  { itemCount }: Props<any>,\r\n  { itemMetadataMap, estimatedItemSize, lastMeasuredIndex }: InstanceProps\r\n) => {\r\n  let totalSizeOfMeasuredItems = 0;\r\n\r\n  // Edge case check for when the number of items decreases while a scroll is in progress.\r\n  // https://github.com/bvaughn/react-window/pull/138\r\n  if (lastMeasuredIndex >= itemCount) {\r\n    lastMeasuredIndex = itemCount - 1;\r\n  }\r\n\r\n  if (lastMeasuredIndex >= 0) {\r\n    const itemMetadata = itemMetadataMap[lastMeasuredIndex];\r\n    totalSizeOfMeasuredItems = itemMetadata.offset + itemMetadata.size;\r\n  }\r\n\r\n  const numUnmeasuredItems = itemCount - lastMeasuredIndex - 1;\r\n  const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;\r\n\r\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;\r\n};\r\n\r\nconst VariableSizeList = createListComponent({\r\n  getItemOffset: (\r\n    props: Props<any>,\r\n    index: number,\r\n    instanceProps: InstanceProps\r\n  ): number => getItemMetadata(props, index, instanceProps).offset,\r\n\r\n  getItemSize: (\r\n    props: Props<any>,\r\n    index: number,\r\n    instanceProps: InstanceProps\r\n  ): number => instanceProps.itemMetadataMap[index].size,\r\n\r\n  getEstimatedTotalSize,\r\n\r\n  getOffsetForIndexAndAlignment: (\r\n    props: Props<any>,\r\n    index: number,\r\n    align: ScrollToAlign,\r\n    scrollOffset: number,\r\n    instanceProps: InstanceProps,\r\n    scrollbarSize: number\r\n  ): number => {\r\n    const { direction, height, layout, width } = props;\r\n\r\n    // TODO Deprecate direction \"horizontal\"\r\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\r\n    const size = (((isHorizontal ? width : height): any): number);\r\n    const itemMetadata = getItemMetadata(props, index, instanceProps);\r\n\r\n    // Get estimated total size after ItemMetadata is computed,\r\n    // To ensure it reflects actual measurements instead of just estimates.\r\n    const estimatedTotalSize = getEstimatedTotalSize(props, instanceProps);\r\n\r\n    const maxOffset = Math.max(\r\n      0,\r\n      Math.min(estimatedTotalSize - size, itemMetadata.offset)\r\n    );\r\n    const minOffset = Math.max(\r\n      0,\r\n      itemMetadata.offset - size + itemMetadata.size + scrollbarSize\r\n    );\r\n\r\n    if (align === 'smart') {\r\n      if (\r\n        scrollOffset >= minOffset - size &&\r\n        scrollOffset <= maxOffset + size\r\n      ) {\r\n        align = 'auto';\r\n      } else {\r\n        align = 'center';\r\n      }\r\n    }\r\n\r\n    switch (align) {\r\n      case 'start':\r\n        return maxOffset;\r\n      case 'end':\r\n        return minOffset;\r\n      case 'center':\r\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\r\n      case 'auto':\r\n      default:\r\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\r\n          return scrollOffset;\r\n        } else if (scrollOffset < minOffset) {\r\n          return minOffset;\r\n        } else {\r\n          return maxOffset;\r\n        }\r\n    }\r\n  },\r\n\r\n  getStartIndexForOffset: (\r\n    props: Props<any>,\r\n    offset: number,\r\n    instanceProps: InstanceProps\r\n  ): number => findNearestItem(props, instanceProps, offset),\r\n\r\n  getStopIndexForStartIndex: (\r\n    props: Props<any>,\r\n    startIndex: number,\r\n    scrollOffset: number,\r\n    instanceProps: InstanceProps\r\n  ): number => {\r\n    const { direction, height, itemCount, layout, width } = props;\r\n\r\n    // TODO Deprecate direction \"horizontal\"\r\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\r\n    const size = (((isHorizontal ? width : height): any): number);\r\n    const itemMetadata = getItemMetadata(props, startIndex, instanceProps);\r\n    const maxOffset = scrollOffset + size;\r\n\r\n    let offset = itemMetadata.offset + itemMetadata.size;\r\n    let stopIndex = startIndex;\r\n\r\n    while (stopIndex < itemCount - 1 && offset < maxOffset) {\r\n      stopIndex++;\r\n      offset += getItemMetadata(props, stopIndex, instanceProps).size;\r\n    }\r\n\r\n    return stopIndex;\r\n  },\r\n\r\n  initInstanceProps(props: Props<any>, instance: any): InstanceProps {\r\n    const { estimatedItemSize } = ((props: any): VariableSizeProps);\r\n\r\n    const instanceProps = {\r\n      itemMetadataMap: {},\r\n      estimatedItemSize: estimatedItemSize || DEFAULT_ESTIMATED_ITEM_SIZE,\r\n      lastMeasuredIndex: -1,\r\n    };\r\n\r\n    instance.resetAfterIndex = (\r\n      index: number,\r\n      shouldForceUpdate?: boolean = true\r\n    ) => {\r\n      instanceProps.lastMeasuredIndex = Math.min(\r\n        instanceProps.lastMeasuredIndex,\r\n        index - 1\r\n      );\r\n\r\n      // We could potentially optimize further by only evicting styles after this index,\r\n      // But since styles are only cached while scrolling is in progress-\r\n      // It seems an unnecessary optimization.\r\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\r\n      instance._getItemStyleCache(-1);\r\n\r\n      if (shouldForceUpdate) {\r\n        instance.forceUpdate();\r\n      }\r\n    };\r\n\r\n    return instanceProps;\r\n  },\r\n\r\n  shouldResetStyleCacheOnItemSizeChange: false,\r\n\r\n  validateProps: ({ itemSize }: Props<any>): void => {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      if (typeof itemSize !== 'function') {\r\n        throw Error(\r\n          'An invalid \"itemSize\" prop has been specified. ' +\r\n            'Value should be a function. ' +\r\n            `\"${itemSize === null ? 'null' : typeof itemSize}\" was specified.`\r\n        );\r\n      }\r\n    }\r\n  },\r\n});\r\n\r\nexport default VariableSizeList;\r\n","// @flow\r\n\r\nimport createGridComponent from './createGridComponent';\r\n\r\nimport type { Props, ScrollToAlign } from './createGridComponent';\r\n\r\nconst FixedSizeGrid = createGridComponent({\r\n  getColumnOffset: ({ columnWidth }: Props<any>, index: number): number =>\r\n    index * ((columnWidth: any): number),\r\n\r\n  getColumnWidth: ({ columnWidth }: Props<any>, index: number): number =>\r\n    ((columnWidth: any): number),\r\n\r\n  getRowOffset: ({ rowHeight }: Props<any>, index: number): number =>\r\n    index * ((rowHeight: any): number),\r\n\r\n  getRowHeight: ({ rowHeight }: Props<any>, index: number): number =>\r\n    ((rowHeight: any): number),\r\n\r\n  getEstimatedTotalHeight: ({ rowCount, rowHeight }: Props<any>) =>\r\n    ((rowHeight: any): number) * rowCount,\r\n\r\n  getEstimatedTotalWidth: ({ columnCount, columnWidth }: Props<any>) =>\r\n    ((columnWidth: any): number) * columnCount,\r\n\r\n  getOffsetForColumnAndAlignment: (\r\n    { columnCount, columnWidth, width }: Props<any>,\r\n    columnIndex: number,\r\n    align: ScrollToAlign,\r\n    scrollLeft: number,\r\n    instanceProps: typeof undefined,\r\n    scrollbarSize: number\r\n  ): number => {\r\n    const lastColumnOffset = Math.max(\r\n      0,\r\n      columnCount * ((columnWidth: any): number) - width\r\n    );\r\n    const maxOffset = Math.min(\r\n      lastColumnOffset,\r\n      columnIndex * ((columnWidth: any): number)\r\n    );\r\n    const minOffset = Math.max(\r\n      0,\r\n      columnIndex * ((columnWidth: any): number) -\r\n        width +\r\n        scrollbarSize +\r\n        ((columnWidth: any): number)\r\n    );\r\n\r\n    if (align === 'smart') {\r\n      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {\r\n        align = 'auto';\r\n      } else {\r\n        align = 'center';\r\n      }\r\n    }\r\n\r\n    switch (align) {\r\n      case 'start':\r\n        return maxOffset;\r\n      case 'end':\r\n        return minOffset;\r\n      case 'center':\r\n        // \"Centered\" offset is usually the average of the min and max.\r\n        // But near the edges of the list, this doesn't hold true.\r\n        const middleOffset = Math.round(\r\n          minOffset + (maxOffset - minOffset) / 2\r\n        );\r\n        if (middleOffset < Math.ceil(width / 2)) {\r\n          return 0; // near the beginning\r\n        } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {\r\n          return lastColumnOffset; // near the end\r\n        } else {\r\n          return middleOffset;\r\n        }\r\n      case 'auto':\r\n      default:\r\n        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {\r\n          return scrollLeft;\r\n        } else if (minOffset > maxOffset) {\r\n          // Because we only take into account the scrollbar size when calculating minOffset\r\n          // this value can be larger than maxOffset when at the end of the list\r\n          return minOffset;\r\n        } else if (scrollLeft < minOffset) {\r\n          return minOffset;\r\n        } else {\r\n          return maxOffset;\r\n        }\r\n    }\r\n  },\r\n\r\n  getOffsetForRowAndAlignment: (\r\n    { rowHeight, height, rowCount }: Props<any>,\r\n    rowIndex: number,\r\n    align: ScrollToAlign,\r\n    scrollTop: number,\r\n    instanceProps: typeof undefined,\r\n    scrollbarSize: number\r\n  ): number => {\r\n    const lastRowOffset = Math.max(\r\n      0,\r\n      rowCount * ((rowHeight: any): number) - height\r\n    );\r\n    const maxOffset = Math.min(\r\n      lastRowOffset,\r\n      rowIndex * ((rowHeight: any): number)\r\n    );\r\n    const minOffset = Math.max(\r\n      0,\r\n      rowIndex * ((rowHeight: any): number) -\r\n        height +\r\n        scrollbarSize +\r\n        ((rowHeight: any): number)\r\n    );\r\n\r\n    if (align === 'smart') {\r\n      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {\r\n        align = 'auto';\r\n      } else {\r\n        align = 'center';\r\n      }\r\n    }\r\n\r\n    switch (align) {\r\n      case 'start':\r\n        return maxOffset;\r\n      case 'end':\r\n        return minOffset;\r\n      case 'center':\r\n        // \"Centered\" offset is usually the average of the min and max.\r\n        // But near the edges of the list, this doesn't hold true.\r\n        const middleOffset = Math.round(\r\n          minOffset + (maxOffset - minOffset) / 2\r\n        );\r\n        if (middleOffset < Math.ceil(height / 2)) {\r\n          return 0; // near the beginning\r\n        } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {\r\n          return lastRowOffset; // near the end\r\n        } else {\r\n          return middleOffset;\r\n        }\r\n      case 'auto':\r\n      default:\r\n        if (scrollTop >= minOffset && scrollTop <= maxOffset) {\r\n          return scrollTop;\r\n        } else if (minOffset > maxOffset) {\r\n          // Because we only take into account the scrollbar size when calculating minOffset\r\n          // this value can be larger than maxOffset when at the end of the list\r\n          return minOffset;\r\n        } else if (scrollTop < minOffset) {\r\n          return minOffset;\r\n        } else {\r\n          return maxOffset;\r\n        }\r\n    }\r\n  },\r\n\r\n  getColumnStartIndexForOffset: (\r\n    { columnWidth, columnCount }: Props<any>,\r\n    scrollLeft: number\r\n  ): number =>\r\n    Math.max(\r\n      0,\r\n      Math.min(\r\n        columnCount - 1,\r\n        Math.floor(scrollLeft / ((columnWidth: any): number))\r\n      )\r\n    ),\r\n\r\n  getColumnStopIndexForStartIndex: (\r\n    { columnWidth, columnCount, width }: Props<any>,\r\n    startIndex: number,\r\n    scrollLeft: number\r\n  ): number => {\r\n    const left = startIndex * ((columnWidth: any): number);\r\n    const numVisibleColumns = Math.ceil(\r\n      (width + scrollLeft - left) / ((columnWidth: any): number)\r\n    );\r\n    return Math.max(\r\n      0,\r\n      Math.min(\r\n        columnCount - 1,\r\n        startIndex + numVisibleColumns - 1 // -1 is because stop index is inclusive\r\n      )\r\n    );\r\n  },\r\n\r\n  getRowStartIndexForOffset: (\r\n    { rowHeight, rowCount }: Props<any>,\r\n    scrollTop: number\r\n  ): number =>\r\n    Math.max(\r\n      0,\r\n      Math.min(rowCount - 1, Math.floor(scrollTop / ((rowHeight: any): number)))\r\n    ),\r\n\r\n  getRowStopIndexForStartIndex: (\r\n    { rowHeight, rowCount, height }: Props<any>,\r\n    startIndex: number,\r\n    scrollTop: number\r\n  ): number => {\r\n    const top = startIndex * ((rowHeight: any): number);\r\n    const numVisibleRows = Math.ceil(\r\n      (height + scrollTop - top) / ((rowHeight: any): number)\r\n    );\r\n    return Math.max(\r\n      0,\r\n      Math.min(\r\n        rowCount - 1,\r\n        startIndex + numVisibleRows - 1 // -1 is because stop index is inclusive\r\n      )\r\n    );\r\n  },\r\n\r\n  initInstanceProps(props: Props<any>): any {\r\n    // Noop\r\n  },\r\n\r\n  shouldResetStyleCacheOnItemSizeChange: true,\r\n\r\n  validateProps: ({ columnWidth, rowHeight }: Props<any>): void => {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      if (typeof columnWidth !== 'number') {\r\n        throw Error(\r\n          'An invalid \"columnWidth\" prop has been specified. ' +\r\n            'Value should be a number. ' +\r\n            `\"${\r\n              columnWidth === null ? 'null' : typeof columnWidth\r\n            }\" was specified.`\r\n        );\r\n      }\r\n\r\n      if (typeof rowHeight !== 'number') {\r\n        throw Error(\r\n          'An invalid \"rowHeight\" prop has been specified. ' +\r\n            'Value should be a number. ' +\r\n            `\"${rowHeight === null ? 'null' : typeof rowHeight}\" was specified.`\r\n        );\r\n      }\r\n    }\r\n  },\r\n});\r\n\r\nexport default FixedSizeGrid;\r\n","// @flow\r\n\r\nimport createListComponent from './createListComponent';\r\n\r\nimport type { Props, ScrollToAlign } from './createListComponent';\r\n\r\ntype InstanceProps = any;\r\n\r\nconst FixedSizeList = createListComponent({\r\n  getItemOffset: ({ itemSize }: Props<any>, index: number): number =>\r\n    index * ((itemSize: any): number),\r\n\r\n  getItemSize: ({ itemSize }: Props<any>, index: number): number =>\r\n    ((itemSize: any): number),\r\n\r\n  getEstimatedTotalSize: ({ itemCount, itemSize }: Props<any>) =>\r\n    ((itemSize: any): number) * itemCount,\r\n\r\n  getOffsetForIndexAndAlignment: (\r\n    { direction, height, itemCount, itemSize, layout, width }: Props<any>,\r\n    index: number,\r\n    align: ScrollToAlign,\r\n    scrollOffset: number,\r\n    instanceProps: InstanceProps,\r\n    scrollbarSize: number\r\n  ): number => {\r\n    // TODO Deprecate direction \"horizontal\"\r\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\r\n    const size = (((isHorizontal ? width : height): any): number);\r\n    const lastItemOffset = Math.max(\r\n      0,\r\n      itemCount * ((itemSize: any): number) - size\r\n    );\r\n    const maxOffset = Math.min(\r\n      lastItemOffset,\r\n      index * ((itemSize: any): number)\r\n    );\r\n    const minOffset = Math.max(\r\n      0,\r\n      index * ((itemSize: any): number) -\r\n        size +\r\n        ((itemSize: any): number) +\r\n        scrollbarSize\r\n    );\r\n\r\n    if (align === 'smart') {\r\n      if (\r\n        scrollOffset >= minOffset - size &&\r\n        scrollOffset <= maxOffset + size\r\n      ) {\r\n        align = 'auto';\r\n      } else {\r\n        align = 'center';\r\n      }\r\n    }\r\n\r\n    switch (align) {\r\n      case 'start':\r\n        return maxOffset;\r\n      case 'end':\r\n        return minOffset;\r\n      case 'center': {\r\n        // \"Centered\" offset is usually the average of the min and max.\r\n        // But near the edges of the list, this doesn't hold true.\r\n        const middleOffset = Math.round(\r\n          minOffset + (maxOffset - minOffset) / 2\r\n        );\r\n        if (middleOffset < Math.ceil(size / 2)) {\r\n          return 0; // near the beginning\r\n        } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {\r\n          return lastItemOffset; // near the end\r\n        } else {\r\n          return middleOffset;\r\n        }\r\n      }\r\n      case 'auto':\r\n      default:\r\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\r\n          return scrollOffset;\r\n        } else if (scrollOffset < minOffset) {\r\n          return minOffset;\r\n        } else {\r\n          return maxOffset;\r\n        }\r\n    }\r\n  },\r\n\r\n  getStartIndexForOffset: (\r\n    { itemCount, itemSize }: Props<any>,\r\n    offset: number\r\n  ): number =>\r\n    Math.max(\r\n      0,\r\n      Math.min(itemCount - 1, Math.floor(offset / ((itemSize: any): number)))\r\n    ),\r\n\r\n  getStopIndexForStartIndex: (\r\n    { direction, height, itemCount, itemSize, layout, width }: Props<any>,\r\n    startIndex: number,\r\n    scrollOffset: number\r\n  ): number => {\r\n    // TODO Deprecate direction \"horizontal\"\r\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\r\n    const offset = startIndex * ((itemSize: any): number);\r\n    const size = (((isHorizontal ? width : height): any): number);\r\n    const numVisibleItems = Math.ceil(\r\n      (size + scrollOffset - offset) / ((itemSize: any): number)\r\n    );\r\n    return Math.max(\r\n      0,\r\n      Math.min(\r\n        itemCount - 1,\r\n        startIndex + numVisibleItems - 1 // -1 is because stop index is inclusive\r\n      )\r\n    );\r\n  },\r\n\r\n  initInstanceProps(props: Props<any>): any {\r\n    // Noop\r\n  },\r\n\r\n  shouldResetStyleCacheOnItemSizeChange: true,\r\n\r\n  validateProps: ({ itemSize }: Props<any>): void => {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      if (typeof itemSize !== 'number') {\r\n        throw Error(\r\n          'An invalid \"itemSize\" prop has been specified. ' +\r\n            'Value should be a number. ' +\r\n            `\"${itemSize === null ? 'null' : typeof itemSize}\" was specified.`\r\n        );\r\n      }\r\n    }\r\n  },\r\n});\r\n\r\nexport default FixedSizeList;\r\n","export default function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}","// @flow\r\n\r\n// Pulled from react-compat\r\n// https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349\r\nexport default function shallowDiffers(prev: Object, next: Object): boolean {\r\n  for (let attribute in prev) {\r\n    if (!(attribute in next)) {\r\n      return true;\r\n    }\r\n  }\r\n  for (let attribute in next) {\r\n    if (prev[attribute] !== next[attribute]) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n","// @flow\r\n\r\nimport shallowDiffers from './shallowDiffers';\r\n\r\n// Custom comparison function for React.memo().\r\n// It knows to compare individual style props and ignore the wrapper object.\r\n// See https://reactjs.org/docs/react-api.html#reactmemo\r\nexport default function areEqual(\r\n  prevProps: Object,\r\n  nextProps: Object\r\n): boolean {\r\n  const { style: prevStyle, ...prevRest } = prevProps;\r\n  const { style: nextStyle, ...nextRest } = nextProps;\r\n\r\n  return (\r\n    !shallowDiffers(prevStyle, nextStyle) && !shallowDiffers(prevRest, nextRest)\r\n  );\r\n}\r\n","// @flow\r\n\r\nimport areEqual from './areEqual';\r\nimport shallowDiffers from './shallowDiffers';\r\n\r\n// Custom shouldComponentUpdate for class components.\r\n// It knows to compare individual style props and ignore the wrapper object.\r\n// See https://reactjs.org/docs/react-component.html#shouldcomponentupdate\r\nexport default function shouldComponentUpdate(\r\n  nextProps: Object,\r\n  nextState: Object\r\n): boolean {\r\n  return (\r\n    !areEqual(this.props, nextProps) || shallowDiffers(this.state, nextState)\r\n  );\r\n}\r\n"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","this","_assertThisInitialized","self","ReferenceError","_setPrototypeOf","o","p","setPrototypeOf","__proto__","_inheritsLoose","subClass","superClass","create","constructor","safeIsNaN","Number","isNaN","value","areInputsEqual","newInputs","lastInputs","first","second","memoizeOne","resultFn","isEqual","lastThis","lastResult","lastArgs","calledOnce","newArgs","_i","now","performance","Date","cancelTimeout","timeoutID","cancelAnimationFrame","id","requestTimeout","callback","delay","start","requestAnimationFrame","tick","size","getScrollbarSize","recalculate","div","document","createElement","style","width","height","overflow","body","appendChild","offsetWidth","clientWidth","removeChild","cachedRTLResult","getRTLOffsetType","outerDiv","outerStyle","direction","innerDiv","innerStyle","scrollLeft","defaultItemKey","columnIndex","data","rowIndex","devWarningsOverscanCount","devWarningsOverscanRowsColumnsCount","devWarningsTagName","createGridComponent","getColumnOffset","getColumnStartIndexForOffset","getColumnStopIndexForStartIndex","getColumnWidth","getEstimatedTotalHeight","getEstimatedTotalWidth","getOffsetForColumnAndAlignment","getOffsetForRowAndAlignment","getRowHeight","getRowOffset","getRowStartIndexForOffset","getRowStopIndexForStartIndex","initInstanceProps","shouldResetStyleCacheOnItemSizeChange","validateProps","props","_instanceProps","_this","_resetIsScrollingTimeoutId","_outerRef","state","instance","isScrolling","horizontalScrollDirection","initialScrollLeft","scrollTop","initialScrollTop","scrollUpdateWasRequested","verticalScrollDirection","_callOnItemsRendered","overscanColumnStartIndex","overscanColumnStopIndex","overscanRowStartIndex","overscanRowStopIndex","visibleColumnStartIndex","visibleColumnStopIndex","visibleRowStartIndex","visibleRowStopIndex","onItemsRendered","_callOnScroll","onScroll","_getItemStyle","columnWidth","rowHeight","itemStyleCache","_getItemStyleCache","offset","isRtl","position","left","undefined","right","top","_","__","___","_onScroll","event","currentTarget","clientHeight","scrollHeight","scrollWidth","setState","prevState","calculatedScrollLeft","Math","max","min","calculatedScrollTop","_resetIsScrollingDebounced","_outerRefSetter","ref","outerRef","current","_resetIsScrolling","getDerivedStateFromProps","nextProps","validateSharedProps","scrollTo","scrollToItem","align","columnCount","rowCount","scrollbarSize","estimatedTotalHeight","horizontalScrollbarSize","verticalScrollbarSize","componentDidMount","_callPropsCallbacks","componentDidUpdate","componentWillUnmount","render","children","className","innerRef","innerElementType","innerTagName","itemData","itemKey","outerElementType","outerTagName","useIsScrolling","disableColVirtualized","disableRowVirtualized","_getHorizontalRangeToRender","columnStartIndex","columnStopIndex","_getVerticalRangeToRender","rowStartIndex","rowStopIndex","items","push","estimatedTotalWidth","WebkitOverflowScrolling","willChange","pointerEvents","overscanColumnCount","overscanColumnsCount","overscanCount","overscanCountResolved","startIndex","stopIndex","overscanBackward","overscanForward","overscanRowCount","overscanRowsCount","PureComponent","defaultProps","window","WeakSet","has","add","console","warn","Error","rowMetadataMap","estimatedRowHeight","lastMeasuredRowIndex","totalSizeOfMeasuredRows","itemMetadata","columnMetadataMap","estimatedColumnWidth","lastMeasuredColumnIndex","getItemMetadata","itemType","index","instanceProps","itemMetadataMap","itemSize","lastMeasuredIndex","findNearestItem","findNearestItemBinarySearch","findNearestItemExponentialSearch","high","low","middle","floor","currentOffset","itemCount","interval","getOffsetForIndexAndAlignment","scrollOffset","estimatedTotalSize","maxOffset","minOffset","round","VariableSizeGrid","resetAfterColumnIndex","shouldForceUpdate","resetAfterIndices","resetAfterRowIndex","forceUpdate","devWarningsDirection","createListComponent","getItemOffset","getEstimatedTotalSize","getItemSize","getStartIndexForOffset","getStopIndexForStartIndex","scrollDirection","initialScrollOffset","overscanStartIndex","overscanStopIndex","visibleStartIndex","visibleStopIndex","layout","isHorizontal","offsetHorizontal","_onScrollHorizontal","_onScrollVertical","_getRangeToRender","estimatedItemSize","totalSizeOfMeasuredItems","VariableSizeList","resetAfterIndex","FixedSizeGrid","lastColumnOffset","middleOffset","ceil","lastRowOffset","numVisibleColumns","numVisibleRows","FixedSizeList","lastItemOffset","numVisibleItems","_objectWithoutPropertiesLoose","excluded","sourceKeys","keys","indexOf","shallowDiffers","prev","next","attribute","areEqual","prevProps","prevStyle","prevRest","nextStyle","nextRest","nextState"],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/react-window/dist/index-prod.umd.js b/node_modules/react-window/dist/index-prod.umd.js
index 3306269..468c2ff 100644
--- a/node_modules/react-window/dist/index-prod.umd.js
+++ b/node_modules/react-window/dist/index-prod.umd.js
@@ -1,2 +1,2 @@
-!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("react")):"function"==typeof define&&define.amd?define(["exports","react"],e):e((t=t||self).ReactWindow={},t.React)}(this,function(t,e){"use strict";function o(){return(o=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var o=arguments[e];for(var r in o)Object.prototype.hasOwnProperty.call(o,r)&&(t[r]=o[r])}return t}).apply(this,arguments)}function r(t,e){t.prototype=Object.create(e.prototype),t.prototype.constructor=t,t.__proto__=e}function n(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}var i=function(t,e){return t.length===e.length&&t.every(function(t,o){return r=t,n=e[o],r===n;var r,n})};function a(t,e){var o;void 0===e&&(e=i);var r,n=[],a=!1;return function(){for(var i=arguments.length,l=new Array(i),s=0;s<i;s++)l[s]=arguments[s];return a&&o===this&&e(l,n)?r:(r=t.apply(this,l),a=!0,o=this,n=l,r)}}var l="object"==typeof performance&&"function"==typeof performance.now?function(){return performance.now()}:function(){return Date.now()};function s(t){cancelAnimationFrame(t.id)}function c(t,e){var o=l();var r={id:requestAnimationFrame(function n(){l()-o>=e?t.call(null):r.id=requestAnimationFrame(n)})};return r}var u=-1;var f=null;function d(t){if(void 0===t&&(t=!1),null===f||t){var e=document.createElement("div"),o=e.style;o.width="50px",o.height="50px",o.overflow="scroll",o.direction="rtl";var r=document.createElement("div"),n=r.style;return n.width="100px",n.height="100px",e.appendChild(r),document.body.appendChild(e),e.scrollLeft>0?f="positive-descending":(e.scrollLeft=1,f=0===e.scrollLeft?"negative":"positive-ascending"),document.body.removeChild(e),f}return f}var h=150,m=function(t){var e=t.columnIndex;t.data;return t.rowIndex+":"+e};function p(t){var i,l,f=t.getColumnOffset,p=t.getColumnStartIndexForOffset,g=t.getColumnStopIndexForStartIndex,S=t.getColumnWidth,I=t.getEstimatedTotalHeight,w=t.getEstimatedTotalWidth,M=t.getOffsetForColumnAndAlignment,x=t.getOffsetForRowAndAlignment,_=t.getRowHeight,C=t.getRowOffset,R=t.getRowStartIndexForOffset,y=t.getRowStopIndexForStartIndex,T=t.initInstanceProps,O=t.shouldResetStyleCacheOnItemSizeChange,z=t.validateProps;return l=i=function(t){function i(e){var o;return(o=t.call(this,e)||this)._instanceProps=T(o.props,n(n(o))),o._resetIsScrollingTimeoutId=null,o._outerRef=void 0,o.state={instance:n(n(o)),isScrolling:!1,horizontalScrollDirection:"forward",scrollLeft:"number"==typeof o.props.initialScrollLeft?o.props.initialScrollLeft:0,scrollTop:"number"==typeof o.props.initialScrollTop?o.props.initialScrollTop:0,scrollUpdateWasRequested:!1,verticalScrollDirection:"forward"},o._callOnItemsRendered=void 0,o._callOnItemsRendered=a(function(t,e,r,n,i,a,l,s){return o.props.onItemsRendered({overscanColumnStartIndex:t,overscanColumnStopIndex:e,overscanRowStartIndex:r,overscanRowStopIndex:n,visibleColumnStartIndex:i,visibleColumnStopIndex:a,visibleRowStartIndex:l,visibleRowStopIndex:s})}),o._callOnScroll=void 0,o._callOnScroll=a(function(t,e,r,n,i){return o.props.onScroll({horizontalScrollDirection:r,scrollLeft:t,scrollTop:e,verticalScrollDirection:n,scrollUpdateWasRequested:i})}),o._getItemStyle=void 0,o._getItemStyle=function(t,e){var r,n=o.props,i=n.columnWidth,a=n.direction,l=n.rowHeight,s=o._getItemStyleCache(O&&i,O&&a,O&&l),c=t+":"+e;if(s.hasOwnProperty(c))r=s[c];else{var u=f(o.props,e,o._instanceProps),d="rtl"===a;s[c]=r={position:"absolute",left:d?void 0:u,right:d?u:void 0,top:C(o.props,t,o._instanceProps),height:_(o.props,t,o._instanceProps),width:S(o.props,e,o._instanceProps)}}return r},o._getItemStyleCache=void 0,o._getItemStyleCache=a(function(t,e,o){return{}}),o._onScroll=function(t){var e=t.currentTarget,r=e.clientHeight,n=e.clientWidth,i=e.scrollLeft,a=e.scrollTop,l=e.scrollHeight,s=e.scrollWidth;o.setState(function(t){if(t.scrollLeft===i&&t.scrollTop===a)return null;var e=o.props.direction,c=i;if("rtl"===e)switch(d()){case"negative":c=-i;break;case"positive-descending":c=s-n-i}c=Math.max(0,Math.min(c,s-n));var u=Math.max(0,Math.min(a,l-r));return{isScrolling:!0,horizontalScrollDirection:t.scrollLeft<i?"forward":"backward",scrollLeft:c,scrollTop:u,verticalScrollDirection:t.scrollTop<a?"forward":"backward",scrollUpdateWasRequested:!1}},o._resetIsScrollingDebounced)},o._outerRefSetter=function(t){var e=o.props.outerRef;o._outerRef=t,"function"==typeof e?e(t):null!=e&&"object"==typeof e&&e.hasOwnProperty("current")&&(e.current=t)},o._resetIsScrollingDebounced=function(){null!==o._resetIsScrollingTimeoutId&&s(o._resetIsScrollingTimeoutId),o._resetIsScrollingTimeoutId=c(o._resetIsScrolling,h)},o._resetIsScrolling=function(){o._resetIsScrollingTimeoutId=null,o.setState({isScrolling:!1},function(){o._getItemStyleCache(-1)})},o}r(i,t),i.getDerivedStateFromProps=function(t,e){return v(t,e),z(t),null};var l=i.prototype;return l.scrollTo=function(t){var e=t.scrollLeft,o=t.scrollTop;void 0!==e&&(e=Math.max(0,e)),void 0!==o&&(o=Math.max(0,o)),this.setState(function(t){return void 0===e&&(e=t.scrollLeft),void 0===o&&(o=t.scrollTop),t.scrollLeft===e&&t.scrollTop===o?null:{horizontalScrollDirection:t.scrollLeft<e?"forward":"backward",scrollLeft:e,scrollTop:o,scrollUpdateWasRequested:!0,verticalScrollDirection:t.scrollTop<o?"forward":"backward"}},this._resetIsScrollingDebounced)},l.scrollToItem=function(t){var e=t.align,o=void 0===e?"auto":e,r=t.columnIndex,n=t.rowIndex,i=this.props,a=i.columnCount,l=i.height,s=i.rowCount,c=i.width,f=this.state,d=f.scrollLeft,h=f.scrollTop,m=function(t){if(void 0===t&&(t=!1),-1===u||t){var e=document.createElement("div"),o=e.style;o.width="50px",o.height="50px",o.overflow="scroll",document.body.appendChild(e),u=e.offsetWidth-e.clientWidth,document.body.removeChild(e)}return u}();void 0!==r&&(r=Math.max(0,Math.min(r,a-1))),void 0!==n&&(n=Math.max(0,Math.min(n,s-1)));var p=I(this.props,this._instanceProps),v=w(this.props,this._instanceProps)>c?m:0,g=p>l?m:0;this.scrollTo({scrollLeft:void 0!==r?M(this.props,r,o,d,this._instanceProps,g):d,scrollTop:void 0!==n?x(this.props,n,o,h,this._instanceProps,v):h})},l.componentDidMount=function(){var t=this.props,e=t.initialScrollLeft,o=t.initialScrollTop;if(null!=this._outerRef){var r=this._outerRef;"number"==typeof e&&(r.scrollLeft=e),"number"==typeof o&&(r.scrollTop=o)}this._callPropsCallbacks()},l.componentDidUpdate=function(){var t=this.props.direction,e=this.state,o=e.scrollLeft,r=e.scrollTop;if(e.scrollUpdateWasRequested&&null!=this._outerRef){var n=this._outerRef;if("rtl"===t)switch(d()){case"negative":n.scrollLeft=-o;break;case"positive-ascending":n.scrollLeft=o;break;default:var i=n.clientWidth,a=n.scrollWidth;n.scrollLeft=a-i-o}else n.scrollLeft=Math.max(0,o);n.scrollTop=Math.max(0,r)}this._callPropsCallbacks()},l.componentWillUnmount=function(){null!==this._resetIsScrollingTimeoutId&&s(this._resetIsScrollingTimeoutId)},l.render=function(){var t=this.props,r=t.children,n=t.className,i=t.columnCount,a=t.direction,l=t.height,s=t.innerRef,c=t.innerElementType,u=t.innerTagName,f=t.itemData,d=t.itemKey,h=void 0===d?m:d,p=t.outerElementType,v=t.outerTagName,g=t.rowCount,S=t.style,M=t.useIsScrolling,x=t.width,_=this.state.isScrolling,C=this._getHorizontalRangeToRender(),R=C[0],y=C[1],T=this._getVerticalRangeToRender(),O=T[0],z=T[1],b=[];if(i>0&&g)for(var P=O;P<=z;P++)for(var W=R;W<=y;W++)b.push(e.createElement(r,{columnIndex:W,data:f,isScrolling:M?_:void 0,key:h({columnIndex:W,data:f,rowIndex:P}),rowIndex:P,style:this._getItemStyle(P,W)}));var D=I(this.props,this._instanceProps),F=w(this.props,this._instanceProps);return e.createElement(p||v||"div",{className:n,onScroll:this._onScroll,ref:this._outerRefSetter,style:o({position:"relative",height:l,width:x,overflow:"auto",WebkitOverflowScrolling:"touch",willChange:"transform",direction:a},S)},e.createElement(c||u||"div",{children:b,ref:s,style:{height:D,pointerEvents:_?"none":void 0,width:F}}))},l._callPropsCallbacks=function(){var t=this.props,e=t.columnCount,o=t.onItemsRendered,r=t.onScroll,n=t.rowCount;if("function"==typeof o&&e>0&&n>0){var i=this._getHorizontalRangeToRender(),a=i[0],l=i[1],s=i[2],c=i[3],u=this._getVerticalRangeToRender(),f=u[0],d=u[1],h=u[2],m=u[3];this._callOnItemsRendered(a,l,f,d,s,c,h,m)}if("function"==typeof r){var p=this.state,v=p.horizontalScrollDirection,g=p.scrollLeft,S=p.scrollTop,I=p.scrollUpdateWasRequested,w=p.verticalScrollDirection;this._callOnScroll(g,S,v,w,I)}},l._getHorizontalRangeToRender=function(){var t=this.props,e=t.columnCount,o=t.overscanColumnCount,r=t.overscanColumnsCount,n=t.overscanCount,i=t.rowCount,a=this.state,l=a.horizontalScrollDirection,s=a.isScrolling,c=a.scrollLeft,u=o||r||n||1;if(0===e||0===i)return[0,0,0,0];var f=p(this.props,c,this._instanceProps),d=g(this.props,f,c,this._instanceProps),h=s&&"backward"!==l?1:Math.max(1,u),m=s&&"forward"!==l?1:Math.max(1,u);return[Math.max(0,f-h),Math.max(0,Math.min(e-1,d+m)),f,d]},l._getVerticalRangeToRender=function(){var t=this.props,e=t.columnCount,o=t.overscanCount,r=t.overscanRowCount,n=t.overscanRowsCount,i=t.rowCount,a=this.state,l=a.isScrolling,s=a.verticalScrollDirection,c=a.scrollTop,u=r||n||o||1;if(0===e||0===i)return[0,0,0,0];var f=R(this.props,c,this._instanceProps),d=y(this.props,f,c,this._instanceProps),h=l&&"backward"!==s?1:Math.max(1,u),m=l&&"forward"!==s?1:Math.max(1,u);return[Math.max(0,f-h),Math.max(0,Math.min(i-1,d+m)),f,d]},i}(e.PureComponent),i.defaultProps={direction:"ltr",itemData:void 0,useIsScrolling:!1},l}var v=function(t,e){t.children,t.direction,t.height,t.innerTagName,t.outerTagName,t.overscanColumnsCount,t.overscanCount,t.overscanRowsCount,t.width,e.instance},g=function(t,e){var o=t.rowCount,r=e.rowMetadataMap,n=e.estimatedRowHeight,i=e.lastMeasuredRowIndex,a=0;if(i>=o&&(i=o-1),i>=0){var l=r[i];a=l.offset+l.size}return a+(o-i-1)*n},S=function(t,e){var o=t.columnCount,r=e.columnMetadataMap,n=e.estimatedColumnWidth,i=e.lastMeasuredColumnIndex,a=0;if(i>=o&&(i=o-1),i>=0){var l=r[i];a=l.offset+l.size}return a+(o-i-1)*n},I=function(t,e,o,r){var n,i,a;if("column"===t?(n=r.columnMetadataMap,i=e.columnWidth,a=r.lastMeasuredColumnIndex):(n=r.rowMetadataMap,i=e.rowHeight,a=r.lastMeasuredRowIndex),o>a){var l=0;if(a>=0){var s=n[a];l=s.offset+s.size}for(var c=a+1;c<=o;c++){var u=i(c);n[c]={offset:l,size:u},l+=u}"column"===t?r.lastMeasuredColumnIndex=o:r.lastMeasuredRowIndex=o}return n[o]},w=function(t,e,o,r){var n,i;return"column"===t?(n=o.columnMetadataMap,i=o.lastMeasuredColumnIndex):(n=o.rowMetadataMap,i=o.lastMeasuredRowIndex),(i>0?n[i].offset:0)>=r?M(t,e,o,i,0,r):x(t,e,o,Math.max(0,i),r)},M=function(t,e,o,r,n,i){for(;n<=r;){var a=n+Math.floor((r-n)/2),l=I(t,e,a,o).offset;if(l===i)return a;l<i?n=a+1:l>i&&(r=a-1)}return n>0?n-1:0},x=function(t,e,o,r,n){for(var i="column"===t?e.columnCount:e.rowCount,a=1;r<i&&I(t,e,r,o).offset<n;)r+=a,a*=2;return M(t,e,o,Math.min(r,i-1),Math.floor(r/2),n)},_=function(t,e,o,r,n,i,a){var l="column"===t?e.width:e.height,s=I(t,e,o,i),c="column"===t?S(e,i):g(e,i),u=Math.max(0,Math.min(c-l,s.offset)),f=Math.max(0,s.offset-l+a+s.size);switch("smart"===r&&(r=n>=f-l&&n<=u+l?"auto":"center"),r){case"start":return u;case"end":return f;case"center":return Math.round(f+(u-f)/2);case"auto":default:return n>=f&&n<=u?n:f>u?f:n<f?f:u}},C=p({getColumnOffset:function(t,e,o){return I("column",t,e,o).offset},getColumnStartIndexForOffset:function(t,e,o){return w("column",t,o,e)},getColumnStopIndexForStartIndex:function(t,e,o,r){for(var n=t.columnCount,i=t.width,a=I("column",t,e,r),l=o+i,s=a.offset+a.size,c=e;c<n-1&&s<l;)s+=I("column",t,++c,r).size;return c},getColumnWidth:function(t,e,o){return o.columnMetadataMap[e].size},getEstimatedTotalHeight:g,getEstimatedTotalWidth:S,getOffsetForColumnAndAlignment:function(t,e,o,r,n,i){return _("column",t,e,o,r,n,i)},getOffsetForRowAndAlignment:function(t,e,o,r,n,i){return _("row",t,e,o,r,n,i)},getRowOffset:function(t,e,o){return I("row",t,e,o).offset},getRowHeight:function(t,e,o){return o.rowMetadataMap[e].size},getRowStartIndexForOffset:function(t,e,o){return w("row",t,o,e)},getRowStopIndexForStartIndex:function(t,e,o,r){for(var n=t.rowCount,i=t.height,a=I("row",t,e,r),l=o+i,s=a.offset+a.size,c=e;c<n-1&&s<l;)s+=I("row",t,++c,r).size;return c},initInstanceProps:function(t,e){var o=t,r={columnMetadataMap:{},estimatedColumnWidth:o.estimatedColumnWidth||50,estimatedRowHeight:o.estimatedRowHeight||50,lastMeasuredColumnIndex:-1,lastMeasuredRowIndex:-1,rowMetadataMap:{}};return e.resetAfterColumnIndex=function(t,o){void 0===o&&(o=!0),e.resetAfterIndices({columnIndex:t,shouldForceUpdate:o})},e.resetAfterRowIndex=function(t,o){void 0===o&&(o=!0),e.resetAfterIndices({rowIndex:t,shouldForceUpdate:o})},e.resetAfterIndices=function(t){var o=t.columnIndex,n=t.rowIndex,i=t.shouldForceUpdate,a=void 0===i||i;"number"==typeof o&&(r.lastMeasuredColumnIndex=Math.min(r.lastMeasuredColumnIndex,o-1)),"number"==typeof n&&(r.lastMeasuredRowIndex=Math.min(r.lastMeasuredRowIndex,n-1)),e._getItemStyleCache(-1),a&&e.forceUpdate()},r},shouldResetStyleCacheOnItemSizeChange:!1,validateProps:function(t){t.columnWidth,t.rowHeight}}),R=150,y=function(t,e){return t};function T(t){var i,l,u=t.getItemOffset,f=t.getEstimatedTotalSize,h=t.getItemSize,m=t.getOffsetForIndexAndAlignment,p=t.getStartIndexForOffset,v=t.getStopIndexForStartIndex,g=t.initInstanceProps,S=t.shouldResetStyleCacheOnItemSizeChange,I=t.validateProps;return l=i=function(t){function i(e){var o;return(o=t.call(this,e)||this)._instanceProps=g(o.props,n(n(o))),o._outerRef=void 0,o._resetIsScrollingTimeoutId=null,o.state={instance:n(n(o)),isScrolling:!1,scrollDirection:"forward",scrollOffset:"number"==typeof o.props.initialScrollOffset?o.props.initialScrollOffset:0,scrollUpdateWasRequested:!1},o._callOnItemsRendered=void 0,o._callOnItemsRendered=a(function(t,e,r,n){return o.props.onItemsRendered({overscanStartIndex:t,overscanStopIndex:e,visibleStartIndex:r,visibleStopIndex:n})}),o._callOnScroll=void 0,o._callOnScroll=a(function(t,e,r){return o.props.onScroll({scrollDirection:t,scrollOffset:e,scrollUpdateWasRequested:r})}),o._getItemStyle=void 0,o._getItemStyle=function(t){var e,r=o.props,n=r.direction,i=r.itemSize,a=r.layout,l=o._getItemStyleCache(S&&i,S&&a,S&&n);if(l.hasOwnProperty(t))e=l[t];else{var s=u(o.props,t,o._instanceProps),c=h(o.props,t,o._instanceProps),f="horizontal"===n||"horizontal"===a,d="rtl"===n,m=f?s:0;l[t]=e={position:"absolute",left:d?void 0:m,right:d?m:void 0,top:f?0:s,height:f?"100%":c,width:f?c:"100%"}}return e},o._getItemStyleCache=void 0,o._getItemStyleCache=a(function(t,e,o){return{}}),o._onScrollHorizontal=function(t){var e=t.currentTarget,r=e.clientWidth,n=e.scrollLeft,i=e.scrollWidth;o.setState(function(t){if(t.scrollOffset===n)return null;var e=o.props.direction,a=n;if("rtl"===e)switch(d()){case"negative":a=-n;break;case"positive-descending":a=i-r-n}return a=Math.max(0,Math.min(a,i-r)),{isScrolling:!0,scrollDirection:t.scrollOffset<n?"forward":"backward",scrollOffset:a,scrollUpdateWasRequested:!1}},o._resetIsScrollingDebounced)},o._onScrollVertical=function(t){var e=t.currentTarget,r=e.clientHeight,n=e.scrollHeight,i=e.scrollTop;o.setState(function(t){if(t.scrollOffset===i)return null;var e=Math.max(0,Math.min(i,n-r));return{isScrolling:!0,scrollDirection:t.scrollOffset<e?"forward":"backward",scrollOffset:e,scrollUpdateWasRequested:!1}},o._resetIsScrollingDebounced)},o._outerRefSetter=function(t){var e=o.props.outerRef;o._outerRef=t,"function"==typeof e?e(t):null!=e&&"object"==typeof e&&e.hasOwnProperty("current")&&(e.current=t)},o._resetIsScrollingDebounced=function(){null!==o._resetIsScrollingTimeoutId&&s(o._resetIsScrollingTimeoutId),o._resetIsScrollingTimeoutId=c(o._resetIsScrolling,R)},o._resetIsScrolling=function(){o._resetIsScrollingTimeoutId=null,o.setState({isScrolling:!1},function(){o._getItemStyleCache(-1,null)})},o}r(i,t),i.getDerivedStateFromProps=function(t,e){return O(t,e),I(t),null};var l=i.prototype;return l.scrollTo=function(t){t=Math.max(0,t),this.setState(function(e){return e.scrollOffset===t?null:{scrollDirection:e.scrollOffset<t?"forward":"backward",scrollOffset:t,scrollUpdateWasRequested:!0}},this._resetIsScrollingDebounced)},l.scrollToItem=function(t,e){void 0===e&&(e="auto");var o=this.props.itemCount,r=this.state.scrollOffset;t=Math.max(0,Math.min(t,o-1)),this.scrollTo(m(this.props,t,e,r,this._instanceProps))},l.componentDidMount=function(){var t=this.props,e=t.direction,o=t.initialScrollOffset,r=t.layout;if("number"==typeof o&&null!=this._outerRef){var n=this._outerRef;"horizontal"===e||"horizontal"===r?n.scrollLeft=o:n.scrollTop=o}this._callPropsCallbacks()},l.componentDidUpdate=function(){var t=this.props,e=t.direction,o=t.layout,r=this.state,n=r.scrollOffset;if(r.scrollUpdateWasRequested&&null!=this._outerRef){var i=this._outerRef;if("horizontal"===e||"horizontal"===o)if("rtl"===e)switch(d()){case"negative":i.scrollLeft=-n;break;case"positive-ascending":i.scrollLeft=n;break;default:var a=i.clientWidth,l=i.scrollWidth;i.scrollLeft=l-a-n}else i.scrollLeft=n;else i.scrollTop=n}this._callPropsCallbacks()},l.componentWillUnmount=function(){null!==this._resetIsScrollingTimeoutId&&s(this._resetIsScrollingTimeoutId)},l.render=function(){var t=this.props,r=t.children,n=t.className,i=t.direction,a=t.height,l=t.innerRef,s=t.innerElementType,c=t.innerTagName,u=t.itemCount,d=t.itemData,h=t.itemKey,m=void 0===h?y:h,p=t.layout,v=t.outerElementType,g=t.outerTagName,S=t.style,I=t.useIsScrolling,w=t.width,M=this.state.isScrolling,x="horizontal"===i||"horizontal"===p,_=x?this._onScrollHorizontal:this._onScrollVertical,C=this._getRangeToRender(),R=C[0],T=C[1],O=[];if(u>0)for(var z=R;z<=T;z++)O.push(e.createElement(r,{data:d,key:m(z,d),index:z,isScrolling:I?M:void 0,style:this._getItemStyle(z)}));var b=f(this.props,this._instanceProps);return e.createElement(v||g||"div",{className:n,onScroll:_,ref:this._outerRefSetter,style:o({position:"relative",height:a,width:w,overflow:"auto",WebkitOverflowScrolling:"touch",willChange:"transform",direction:i},S)},e.createElement(s||c||"div",{children:O,ref:l,style:{height:x?"100%":b,pointerEvents:M?"none":void 0,width:x?b:"100%"}}))},l._callPropsCallbacks=function(){if("function"==typeof this.props.onItemsRendered&&this.props.itemCount>0){var t=this._getRangeToRender(),e=t[0],o=t[1],r=t[2],n=t[3];this._callOnItemsRendered(e,o,r,n)}if("function"==typeof this.props.onScroll){var i=this.state,a=i.scrollDirection,l=i.scrollOffset,s=i.scrollUpdateWasRequested;this._callOnScroll(a,l,s)}},l._getRangeToRender=function(){var t=this.props,e=t.itemCount,o=t.overscanCount,r=this.state,n=r.isScrolling,i=r.scrollDirection,a=r.scrollOffset;if(0===e)return[0,0,0,0];var l=p(this.props,a,this._instanceProps),s=v(this.props,l,a,this._instanceProps),c=n&&"backward"!==i?1:Math.max(1,o),u=n&&"forward"!==i?1:Math.max(1,o);return[Math.max(0,l-c),Math.max(0,Math.min(e-1,s+u)),l,s]},i}(e.PureComponent),i.defaultProps={direction:"ltr",itemData:void 0,layout:"vertical",overscanCount:2,useIsScrolling:!1},l}var O=function(t,e){t.children,t.direction,t.height,t.layout,t.innerTagName,t.outerTagName,t.width,e.instance},z=function(t,e,o){var r=t.itemSize,n=o.itemMetadataMap,i=o.lastMeasuredIndex;if(e>i){var a=0;if(i>=0){var l=n[i];a=l.offset+l.size}for(var s=i+1;s<=e;s++){var c=r(s);n[s]={offset:a,size:c},a+=c}o.lastMeasuredIndex=e}return n[e]},b=function(t,e,o,r,n){for(;r<=o;){var i=r+Math.floor((o-r)/2),a=z(t,i,e).offset;if(a===n)return i;a<n?r=i+1:a>n&&(o=i-1)}return r>0?r-1:0},P=function(t,e,o,r){for(var n=t.itemCount,i=1;o<n&&z(t,o,e).offset<r;)o+=i,i*=2;return b(t,e,Math.min(o,n-1),Math.floor(o/2),r)},W=function(t,e){var o=t.itemCount,r=e.itemMetadataMap,n=e.estimatedItemSize,i=e.lastMeasuredIndex,a=0;if(i>=o&&(i=o-1),i>=0){var l=r[i];a=l.offset+l.size}return a+(o-i-1)*n},D=T({getItemOffset:function(t,e,o){return z(t,e,o).offset},getItemSize:function(t,e,o){return o.itemMetadataMap[e].size},getEstimatedTotalSize:W,getOffsetForIndexAndAlignment:function(t,e,o,r,n){var i=t.direction,a=t.height,l=t.layout,s=t.width,c="horizontal"===i||"horizontal"===l?s:a,u=z(t,e,n),f=W(t,n),d=Math.max(0,Math.min(f-c,u.offset)),h=Math.max(0,u.offset-c+u.size);switch("smart"===o&&(o=r>=h-c&&r<=d+c?"auto":"center"),o){case"start":return d;case"end":return h;case"center":return Math.round(h+(d-h)/2);case"auto":default:return r>=h&&r<=d?r:r<h?h:d}},getStartIndexForOffset:function(t,e,o){return function(t,e,o){var r=e.itemMetadataMap,n=e.lastMeasuredIndex;return(n>0?r[n].offset:0)>=o?b(t,e,n,0,o):P(t,e,Math.max(0,n),o)}(t,o,e)},getStopIndexForStartIndex:function(t,e,o,r){for(var n=t.direction,i=t.height,a=t.itemCount,l=t.layout,s=t.width,c="horizontal"===n||"horizontal"===l?s:i,u=z(t,e,r),f=o+c,d=u.offset+u.size,h=e;h<a-1&&d<f;)d+=z(t,++h,r).size;return h},initInstanceProps:function(t,e){var o={itemMetadataMap:{},estimatedItemSize:t.estimatedItemSize||50,lastMeasuredIndex:-1};return e.resetAfterIndex=function(t,r){void 0===r&&(r=!0),o.lastMeasuredIndex=Math.min(o.lastMeasuredIndex,t-1),e._getItemStyleCache(-1),r&&e.forceUpdate()},o},shouldResetStyleCacheOnItemSizeChange:!1,validateProps:function(t){t.itemSize}}),F=p({getColumnOffset:function(t,e){return e*t.columnWidth},getColumnWidth:function(t,e){return t.columnWidth},getRowOffset:function(t,e){return e*t.rowHeight},getRowHeight:function(t,e){return t.rowHeight},getEstimatedTotalHeight:function(t){var e=t.rowCount;return t.rowHeight*e},getEstimatedTotalWidth:function(t){var e=t.columnCount;return t.columnWidth*e},getOffsetForColumnAndAlignment:function(t,e,o,r,n,i){var a=t.columnCount,l=t.columnWidth,s=t.width,c=Math.max(0,a*l-s),u=Math.min(c,e*l),f=Math.max(0,e*l-s+i+l);switch("smart"===o&&(o=r>=f-s&&r<=u+s?"auto":"center"),o){case"start":return u;case"end":return f;case"center":var d=Math.round(f+(u-f)/2);return d<Math.ceil(s/2)?0:d>c+Math.floor(s/2)?c:d;case"auto":default:return r>=f&&r<=u?r:f>u?f:r<f?f:u}},getOffsetForRowAndAlignment:function(t,e,o,r,n,i){var a=t.rowHeight,l=t.height,s=t.rowCount,c=Math.max(0,s*a-l),u=Math.min(c,e*a),f=Math.max(0,e*a-l+i+a);switch("smart"===o&&(o=r>=f-l&&r<=u+l?"auto":"center"),o){case"start":return u;case"end":return f;case"center":var d=Math.round(f+(u-f)/2);return d<Math.ceil(l/2)?0:d>c+Math.floor(l/2)?c:d;case"auto":default:return r>=f&&r<=u?r:f>u?f:r<f?f:u}},getColumnStartIndexForOffset:function(t,e){var o=t.columnWidth,r=t.columnCount;return Math.max(0,Math.min(r-1,Math.floor(e/o)))},getColumnStopIndexForStartIndex:function(t,e,o){var r=t.columnWidth,n=t.columnCount,i=t.width,a=e*r,l=Math.ceil((i+o-a)/r);return Math.max(0,Math.min(n-1,e+l-1))},getRowStartIndexForOffset:function(t,e){var o=t.rowHeight,r=t.rowCount;return Math.max(0,Math.min(r-1,Math.floor(e/o)))},getRowStopIndexForStartIndex:function(t,e,o){var r=t.rowHeight,n=t.rowCount,i=t.height,a=e*r,l=Math.ceil((i+o-a)/r);return Math.max(0,Math.min(n-1,e+l-1))},initInstanceProps:function(t){},shouldResetStyleCacheOnItemSizeChange:!0,validateProps:function(t){t.columnWidth,t.rowHeight}}),L=T({getItemOffset:function(t,e){return e*t.itemSize},getItemSize:function(t,e){return t.itemSize},getEstimatedTotalSize:function(t){var e=t.itemCount;return t.itemSize*e},getOffsetForIndexAndAlignment:function(t,e,o,r){var n=t.direction,i=t.height,a=t.itemCount,l=t.itemSize,s=t.layout,c=t.width,u="horizontal"===n||"horizontal"===s?c:i,f=Math.max(0,a*l-u),d=Math.min(f,e*l),h=Math.max(0,e*l-u+l);switch("smart"===o&&(o=r>=h-u&&r<=d+u?"auto":"center"),o){case"start":return d;case"end":return h;case"center":var m=Math.round(h+(d-h)/2);return m<Math.ceil(u/2)?0:m>f+Math.floor(u/2)?f:m;case"auto":default:return r>=h&&r<=d?r:r<h?h:d}},getStartIndexForOffset:function(t,e){var o=t.itemCount,r=t.itemSize;return Math.max(0,Math.min(o-1,Math.floor(e/r)))},getStopIndexForStartIndex:function(t,e,o){var r=t.direction,n=t.height,i=t.itemCount,a=t.itemSize,l=t.layout,s=t.width,c=e*a,u="horizontal"===r||"horizontal"===l?s:n,f=Math.ceil((u+o-c)/a);return Math.max(0,Math.min(i-1,e+f-1))},initInstanceProps:function(t){},shouldResetStyleCacheOnItemSizeChange:!0,validateProps:function(t){t.itemSize}});function A(t,e){if(null==t)return{};var o,r,n={},i=Object.keys(t);for(r=0;r<i.length;r++)o=i[r],e.indexOf(o)>=0||(n[o]=t[o]);return n}function H(t,e){for(var o in t)if(!(o in e))return!0;for(var r in e)if(t[r]!==e[r])return!0;return!1}function k(t,e){var o=t.style,r=A(t,["style"]),n=e.style,i=A(e,["style"]);return!H(o,n)&&!H(r,i)}t.VariableSizeGrid=C,t.VariableSizeList=D,t.FixedSizeGrid=F,t.FixedSizeList=L,t.areEqual=k,t.shouldComponentUpdate=function(t,e){return!k(this.props,t)||H(this.state,e)},Object.defineProperty(t,"__esModule",{value:!0})});
+!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("react")):"function"==typeof define&&define.amd?define(["exports","react"],e):e((t=t||self).ReactWindow={},t.React)}(this,(function(t,e){"use strict";function r(){return(r=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var r=arguments[e];for(var o in r)Object.prototype.hasOwnProperty.call(r,o)&&(t[o]=r[o])}return t}).apply(this,arguments)}function o(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function n(t,e){return(n=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function i(t,e){t.prototype=Object.create(e.prototype),t.prototype.constructor=t,n(t,e)}var a=Number.isNaN||function(t){return"number"==typeof t&&t!=t};function l(t,e){if(t.length!==e.length)return!1;for(var r=0;r<t.length;r++)if(o=t[r],n=e[r],!(o===n||a(o)&&a(n)))return!1;var o,n;return!0}function s(t,e){var r;void 0===e&&(e=l);var o,n=[],i=!1;return function(){for(var a=[],l=0;l<arguments.length;l++)a[l]=arguments[l];return i&&r===this&&e(a,n)||(o=t.apply(this,a),i=!0,r=this,n=a),o}}var c="object"==typeof performance&&"function"==typeof performance.now?function(){return performance.now()}:function(){return Date.now()};function u(t){cancelAnimationFrame(t.id)}function f(t,e){var r=c();var o={id:requestAnimationFrame((function n(){c()-r>=e?t.call(null):o.id=requestAnimationFrame(n)}))};return o}var d=-1;function h(t){if(void 0===t&&(t=!1),-1===d||t){var e=document.createElement("div"),r=e.style;r.width="50px",r.height="50px",r.overflow="scroll",document.body.appendChild(e),d=e.offsetWidth-e.clientWidth,document.body.removeChild(e)}return d}var m=null;function p(t){if(void 0===t&&(t=!1),null===m||t){var e=document.createElement("div"),r=e.style;r.width="50px",r.height="50px",r.overflow="scroll",r.direction="rtl";var o=document.createElement("div"),n=o.style;return n.width="100px",n.height="100px",e.appendChild(o),document.body.appendChild(e),e.scrollLeft>0?m="positive-descending":(e.scrollLeft=1,m=0===e.scrollLeft?"negative":"positive-ascending"),document.body.removeChild(e),m}return m}var v=function(t){var e=t.columnIndex;t.data;return t.rowIndex+":"+e};function g(t){var n,a=t.getColumnOffset,l=t.getColumnStartIndexForOffset,c=t.getColumnStopIndexForStartIndex,d=t.getColumnWidth,m=t.getEstimatedTotalHeight,g=t.getEstimatedTotalWidth,I=t.getOffsetForColumnAndAlignment,w=t.getOffsetForRowAndAlignment,M=t.getRowHeight,x=t.getRowOffset,_=t.getRowStartIndexForOffset,C=t.getRowStopIndexForStartIndex,R=t.initInstanceProps,y=t.shouldResetStyleCacheOnItemSizeChange,O=t.validateProps;return(n=function(t){function n(e){var r;return(r=t.call(this,e)||this)._instanceProps=R(r.props,o(r)),r._resetIsScrollingTimeoutId=null,r._outerRef=void 0,r.state={instance:o(r),isScrolling:!1,horizontalScrollDirection:"forward",scrollLeft:"number"==typeof r.props.initialScrollLeft?r.props.initialScrollLeft:0,scrollTop:"number"==typeof r.props.initialScrollTop?r.props.initialScrollTop:0,scrollUpdateWasRequested:!1,verticalScrollDirection:"forward"},r._callOnItemsRendered=void 0,r._callOnItemsRendered=s((function(t,e,o,n,i,a,l,s){return r.props.onItemsRendered({overscanColumnStartIndex:t,overscanColumnStopIndex:e,overscanRowStartIndex:o,overscanRowStopIndex:n,visibleColumnStartIndex:i,visibleColumnStopIndex:a,visibleRowStartIndex:l,visibleRowStopIndex:s})})),r._callOnScroll=void 0,r._callOnScroll=s((function(t,e,o,n,i){return r.props.onScroll({horizontalScrollDirection:o,scrollLeft:t,scrollTop:e,verticalScrollDirection:n,scrollUpdateWasRequested:i})})),r._getItemStyle=void 0,r._getItemStyle=function(t,e){var o,n=r.props,i=n.columnWidth,l=n.direction,s=n.rowHeight,c=r._getItemStyleCache(y&&i,y&&l,y&&s),u=t+":"+e;if(c.hasOwnProperty(u))o=c[u];else{var f=a(r.props,e,r._instanceProps),h="rtl"===l;c[u]=o={position:"absolute",left:h?void 0:f,right:h?f:void 0,top:x(r.props,t,r._instanceProps),height:M(r.props,t,r._instanceProps),width:d(r.props,e,r._instanceProps)}}return o},r._getItemStyleCache=void 0,r._getItemStyleCache=s((function(t,e,r){return{}})),r._onScroll=function(t){var e=t.currentTarget,o=e.clientHeight,n=e.clientWidth,i=e.scrollLeft,a=e.scrollTop,l=e.scrollHeight,s=e.scrollWidth;r.setState((function(t){if(t.scrollLeft===i&&t.scrollTop===a)return null;var e=r.props.direction,c=i;if("rtl"===e)switch(p()){case"negative":c=-i;break;case"positive-descending":c=s-n-i}c=Math.max(0,Math.min(c,s-n));var u=Math.max(0,Math.min(a,l-o));return{isScrolling:!0,horizontalScrollDirection:t.scrollLeft<i?"forward":"backward",scrollLeft:c,scrollTop:u,verticalScrollDirection:t.scrollTop<a?"forward":"backward",scrollUpdateWasRequested:!1}}),r._resetIsScrollingDebounced)},r._outerRefSetter=function(t){var e=r.props.outerRef;r._outerRef=t,"function"==typeof e?e(t):null!=e&&"object"==typeof e&&e.hasOwnProperty("current")&&(e.current=t)},r._resetIsScrollingDebounced=function(){null!==r._resetIsScrollingTimeoutId&&u(r._resetIsScrollingTimeoutId),r._resetIsScrollingTimeoutId=f(r._resetIsScrolling,150)},r._resetIsScrolling=function(){r._resetIsScrollingTimeoutId=null,r.setState({isScrolling:!1},(function(){r._getItemStyleCache(-1)}))},r}i(n,t),n.getDerivedStateFromProps=function(t,e){return S(t,e),O(t),null};var T=n.prototype;return T.scrollTo=function(t){var e=t.scrollLeft,r=t.scrollTop;void 0!==e&&(e=Math.max(0,e)),void 0!==r&&(r=Math.max(0,r)),this.setState((function(t){return void 0===e&&(e=t.scrollLeft),void 0===r&&(r=t.scrollTop),t.scrollLeft===e&&t.scrollTop===r?null:{horizontalScrollDirection:t.scrollLeft<e?"forward":"backward",scrollLeft:e,scrollTop:r,scrollUpdateWasRequested:!0,verticalScrollDirection:t.scrollTop<r?"forward":"backward"}}),this._resetIsScrollingDebounced)},T.scrollToItem=function(t){var e=t.align,r=void 0===e?"auto":e,o=t.columnIndex,n=t.rowIndex,i=this.props,a=i.columnCount,l=i.height,s=i.rowCount,c=i.width,u=this.state,f=u.scrollLeft,d=u.scrollTop,p=h();void 0!==o&&(o=Math.max(0,Math.min(o,a-1))),void 0!==n&&(n=Math.max(0,Math.min(n,s-1)));var v=m(this.props,this._instanceProps),S=g(this.props,this._instanceProps)>c?p:0,M=v>l?p:0;this.scrollTo({scrollLeft:void 0!==o?I(this.props,o,r,f,this._instanceProps,M):f,scrollTop:void 0!==n?w(this.props,n,r,d,this._instanceProps,S):d})},T.componentDidMount=function(){var t=this.props,e=t.initialScrollLeft,r=t.initialScrollTop;if(null!=this._outerRef){var o=this._outerRef;"number"==typeof e&&(o.scrollLeft=e),"number"==typeof r&&(o.scrollTop=r)}this._callPropsCallbacks()},T.componentDidUpdate=function(){var t=this.props.direction,e=this.state,r=e.scrollLeft,o=e.scrollTop;if(e.scrollUpdateWasRequested&&null!=this._outerRef){var n=this._outerRef;if("rtl"===t)switch(p()){case"negative":n.scrollLeft=-r;break;case"positive-ascending":n.scrollLeft=r;break;default:var i=n.clientWidth,a=n.scrollWidth;n.scrollLeft=a-i-r}else n.scrollLeft=Math.max(0,r);n.scrollTop=Math.max(0,o)}this._callPropsCallbacks()},T.componentWillUnmount=function(){null!==this._resetIsScrollingTimeoutId&&u(this._resetIsScrollingTimeoutId)},T.render=function(){var t=this.props,o=t.children,n=t.className,i=t.columnCount,a=t.direction,l=t.height,s=t.innerRef,c=t.innerElementType,u=t.innerTagName,f=t.itemData,d=t.itemKey,h=void 0===d?v:d,p=t.outerElementType,S=t.outerTagName,I=t.rowCount,w=t.style,M=t.useIsScrolling,x=t.width,_=t.disableColVirtualized,C=t.disableRowVirtualized,R=this.state.isScrolling,y=this._getHorizontalRangeToRender(),O=y[0],T=y[1],z=this._getVerticalRangeToRender(),b=z[0],P=z[1];_&&(O=0),C&&(b=0);var W=[];if(i>0&&I)for(var D=b;D<=P;D++)for(var F=O;F<=T;F++)W.push(e.createElement(o,{columnIndex:F,data:f,isScrolling:M?R:void 0,key:h({columnIndex:F,data:f,rowIndex:D}),rowIndex:D,style:this._getItemStyle(D,F)}));var L=m(this.props,this._instanceProps),H=g(this.props,this._instanceProps);return e.createElement(p||S||"div",{className:n,onScroll:this._onScroll,ref:this._outerRefSetter,style:r({position:"relative",height:l,width:x,overflow:"auto",WebkitOverflowScrolling:"touch",willChange:"transform",direction:a},w)},e.createElement(c||u||"div",{children:W,ref:s,style:{height:L,pointerEvents:R?"none":void 0,width:H}}))},T._callPropsCallbacks=function(){var t=this.props,e=t.columnCount,r=t.onItemsRendered,o=t.onScroll,n=t.rowCount;if("function"==typeof r&&e>0&&n>0){var i=this._getHorizontalRangeToRender(),a=i[0],l=i[1],s=i[2],c=i[3],u=this._getVerticalRangeToRender(),f=u[0],d=u[1],h=u[2],m=u[3];this._callOnItemsRendered(a,l,f,d,s,c,h,m)}if("function"==typeof o){var p=this.state,v=p.horizontalScrollDirection,g=p.scrollLeft,S=p.scrollTop,I=p.scrollUpdateWasRequested,w=p.verticalScrollDirection;this._callOnScroll(g,S,v,w,I)}},T._getHorizontalRangeToRender=function(){var t=this.props,e=t.columnCount,r=t.overscanColumnCount,o=t.overscanColumnsCount,n=t.overscanCount,i=t.rowCount,a=this.state,s=a.horizontalScrollDirection,u=a.isScrolling,f=a.scrollLeft,d=r||o||n||1;if(0===e||0===i)return[0,0,0,0];var h=l(this.props,f,this._instanceProps),m=c(this.props,h,f,this._instanceProps),p=u&&"backward"!==s?1:Math.max(1,d),v=u&&"forward"!==s?1:Math.max(1,d);return[Math.max(0,h-p),Math.max(0,Math.min(e-1,m+v)),h,m]},T._getVerticalRangeToRender=function(){var t=this.props,e=t.columnCount,r=t.overscanCount,o=t.overscanRowCount,n=t.overscanRowsCount,i=t.rowCount,a=this.state,l=a.isScrolling,s=a.verticalScrollDirection,c=a.scrollTop,u=o||n||r||1;if(0===e||0===i)return[0,0,0,0];var f=_(this.props,c,this._instanceProps),d=C(this.props,f,c,this._instanceProps),h=l&&"backward"!==s?1:Math.max(1,u),m=l&&"forward"!==s?1:Math.max(1,u);return[Math.max(0,f-h),Math.max(0,Math.min(i-1,d+m)),f,d]},n}(e.PureComponent)).defaultProps={direction:"ltr",itemData:void 0,useIsScrolling:!1},n}var S=function(t,e){t.children,t.direction,t.height,t.innerTagName,t.outerTagName,t.overscanColumnsCount,t.overscanCount,t.overscanRowsCount,t.width,e.instance},I=function(t,e){var r=t.rowCount,o=e.rowMetadataMap,n=e.estimatedRowHeight,i=e.lastMeasuredRowIndex,a=0;if(i>=r&&(i=r-1),i>=0){var l=o[i];a=l.offset+l.size}return a+(r-i-1)*n},w=function(t,e){var r=t.columnCount,o=e.columnMetadataMap,n=e.estimatedColumnWidth,i=e.lastMeasuredColumnIndex,a=0;if(i>=r&&(i=r-1),i>=0){var l=o[i];a=l.offset+l.size}return a+(r-i-1)*n},M=function(t,e,r,o){var n,i,a;if("column"===t?(n=o.columnMetadataMap,i=e.columnWidth,a=o.lastMeasuredColumnIndex):(n=o.rowMetadataMap,i=e.rowHeight,a=o.lastMeasuredRowIndex),r>a){var l=0;if(a>=0){var s=n[a];l=s.offset+s.size}for(var c=a+1;c<=r;c++){var u=i(c);n[c]={offset:l,size:u},l+=u}"column"===t?o.lastMeasuredColumnIndex=r:o.lastMeasuredRowIndex=r}return n[r]},x=function(t,e,r,o){var n,i;return"column"===t?(n=r.columnMetadataMap,i=r.lastMeasuredColumnIndex):(n=r.rowMetadataMap,i=r.lastMeasuredRowIndex),(i>0?n[i].offset:0)>=o?_(t,e,r,i,0,o):C(t,e,r,Math.max(0,i),o)},_=function(t,e,r,o,n,i){for(;n<=o;){var a=n+Math.floor((o-n)/2),l=M(t,e,a,r).offset;if(l===i)return a;l<i?n=a+1:l>i&&(o=a-1)}return n>0?n-1:0},C=function(t,e,r,o,n){for(var i="column"===t?e.columnCount:e.rowCount,a=1;o<i&&M(t,e,o,r).offset<n;)o+=a,a*=2;return _(t,e,r,Math.min(o,i-1),Math.floor(o/2),n)},R=function(t,e,r,o,n,i,a){var l="column"===t?e.width:e.height,s=M(t,e,r,i),c="column"===t?w(e,i):I(e,i),u=Math.max(0,Math.min(c-l,s.offset)),f=Math.max(0,s.offset-l+a+s.size);switch("smart"===o&&(o=n>=f-l&&n<=u+l?"auto":"center"),o){case"start":return u;case"end":return f;case"center":return Math.round(f+(u-f)/2);case"auto":default:return n>=f&&n<=u?n:f>u||n<f?f:u}},y=g({getColumnOffset:function(t,e,r){return M("column",t,e,r).offset},getColumnStartIndexForOffset:function(t,e,r){return x("column",t,r,e)},getColumnStopIndexForStartIndex:function(t,e,r,o){for(var n=t.columnCount,i=t.width,a=M("column",t,e,o),l=r+i,s=a.offset+a.size,c=e;c<n-1&&s<l;)c++,s+=M("column",t,c,o).size;return c},getColumnWidth:function(t,e,r){return r.columnMetadataMap[e].size},getEstimatedTotalHeight:I,getEstimatedTotalWidth:w,getOffsetForColumnAndAlignment:function(t,e,r,o,n,i){return R("column",t,e,r,o,n,i)},getOffsetForRowAndAlignment:function(t,e,r,o,n,i){return R("row",t,e,r,o,n,i)},getRowOffset:function(t,e,r){return M("row",t,e,r).offset},getRowHeight:function(t,e,r){return r.rowMetadataMap[e].size},getRowStartIndexForOffset:function(t,e,r){return x("row",t,r,e)},getRowStopIndexForStartIndex:function(t,e,r,o){for(var n=t.rowCount,i=t.height,a=M("row",t,e,o),l=r+i,s=a.offset+a.size,c=e;c<n-1&&s<l;)c++,s+=M("row",t,c,o).size;return c},initInstanceProps:function(t,e){var r=t,o={columnMetadataMap:{},estimatedColumnWidth:r.estimatedColumnWidth||50,estimatedRowHeight:r.estimatedRowHeight||50,lastMeasuredColumnIndex:-1,lastMeasuredRowIndex:-1,rowMetadataMap:{}};return e.resetAfterColumnIndex=function(t,r){void 0===r&&(r=!0),e.resetAfterIndices({columnIndex:t,shouldForceUpdate:r})},e.resetAfterRowIndex=function(t,r){void 0===r&&(r=!0),e.resetAfterIndices({rowIndex:t,shouldForceUpdate:r})},e.resetAfterIndices=function(t){var r=t.columnIndex,n=t.rowIndex,i=t.shouldForceUpdate,a=void 0===i||i;"number"==typeof r&&(o.lastMeasuredColumnIndex=Math.min(o.lastMeasuredColumnIndex,r-1)),"number"==typeof n&&(o.lastMeasuredRowIndex=Math.min(o.lastMeasuredRowIndex,n-1)),e._getItemStyleCache(-1),a&&e.forceUpdate()},o},shouldResetStyleCacheOnItemSizeChange:!1,validateProps:function(t){t.columnWidth,t.rowHeight}}),O=function(t,e){return t};function T(t){var n,a=t.getItemOffset,l=t.getEstimatedTotalSize,c=t.getItemSize,d=t.getOffsetForIndexAndAlignment,m=t.getStartIndexForOffset,v=t.getStopIndexForStartIndex,g=t.initInstanceProps,S=t.shouldResetStyleCacheOnItemSizeChange,I=t.validateProps;return(n=function(t){function n(e){var r;return(r=t.call(this,e)||this)._instanceProps=g(r.props,o(r)),r._outerRef=void 0,r._resetIsScrollingTimeoutId=null,r.state={instance:o(r),isScrolling:!1,scrollDirection:"forward",scrollOffset:"number"==typeof r.props.initialScrollOffset?r.props.initialScrollOffset:0,scrollUpdateWasRequested:!1},r._callOnItemsRendered=void 0,r._callOnItemsRendered=s((function(t,e,o,n){return r.props.onItemsRendered({overscanStartIndex:t,overscanStopIndex:e,visibleStartIndex:o,visibleStopIndex:n})})),r._callOnScroll=void 0,r._callOnScroll=s((function(t,e,o){return r.props.onScroll({scrollDirection:t,scrollOffset:e,scrollUpdateWasRequested:o})})),r._getItemStyle=void 0,r._getItemStyle=function(t){var e,o=r.props,n=o.direction,i=o.itemSize,l=o.layout,s=r._getItemStyleCache(S&&i,S&&l,S&&n);if(s.hasOwnProperty(t))e=s[t];else{var u=a(r.props,t,r._instanceProps),f=c(r.props,t,r._instanceProps),d="horizontal"===n||"horizontal"===l,h="rtl"===n,m=d?u:0;s[t]=e={position:"absolute",left:h?void 0:m,right:h?m:void 0,top:d?0:u,height:d?"100%":f,width:d?f:"100%"}}return e},r._getItemStyleCache=void 0,r._getItemStyleCache=s((function(t,e,r){return{}})),r._onScrollHorizontal=function(t){var e=t.currentTarget,o=e.clientWidth,n=e.scrollLeft,i=e.scrollWidth;r.setState((function(t){if(t.scrollOffset===n)return null;var e=r.props.direction,a=n;if("rtl"===e)switch(p()){case"negative":a=-n;break;case"positive-descending":a=i-o-n}return a=Math.max(0,Math.min(a,i-o)),{isScrolling:!0,scrollDirection:t.scrollOffset<n?"forward":"backward",scrollOffset:a,scrollUpdateWasRequested:!1}}),r._resetIsScrollingDebounced)},r._onScrollVertical=function(t){var e=t.currentTarget,o=e.clientHeight,n=e.scrollHeight,i=e.scrollTop;r.setState((function(t){if(t.scrollOffset===i)return null;var e=Math.max(0,Math.min(i,n-o));return{isScrolling:!0,scrollDirection:t.scrollOffset<e?"forward":"backward",scrollOffset:e,scrollUpdateWasRequested:!1}}),r._resetIsScrollingDebounced)},r._outerRefSetter=function(t){var e=r.props.outerRef;r._outerRef=t,"function"==typeof e?e(t):null!=e&&"object"==typeof e&&e.hasOwnProperty("current")&&(e.current=t)},r._resetIsScrollingDebounced=function(){null!==r._resetIsScrollingTimeoutId&&u(r._resetIsScrollingTimeoutId),r._resetIsScrollingTimeoutId=f(r._resetIsScrolling,150)},r._resetIsScrolling=function(){r._resetIsScrollingTimeoutId=null,r.setState({isScrolling:!1},(function(){r._getItemStyleCache(-1,null)}))},r}i(n,t),n.getDerivedStateFromProps=function(t,e){return z(t,e),I(t),null};var w=n.prototype;return w.scrollTo=function(t){t=Math.max(0,t),this.setState((function(e){return e.scrollOffset===t?null:{scrollDirection:e.scrollOffset<t?"forward":"backward",scrollOffset:t,scrollUpdateWasRequested:!0}}),this._resetIsScrollingDebounced)},w.scrollToItem=function(t,e){void 0===e&&(e="auto");var r=this.props,o=r.itemCount,n=r.layout,i=this.state.scrollOffset;t=Math.max(0,Math.min(t,o-1));var a=0;if(this._outerRef){var l=this._outerRef;a="vertical"===n?l.scrollWidth>l.clientWidth?h():0:l.scrollHeight>l.clientHeight?h():0}this.scrollTo(d(this.props,t,e,i,this._instanceProps,a))},w.componentDidMount=function(){var t=this.props,e=t.direction,r=t.initialScrollOffset,o=t.layout;if("number"==typeof r&&null!=this._outerRef){var n=this._outerRef;"horizontal"===e||"horizontal"===o?n.scrollLeft=r:n.scrollTop=r}this._callPropsCallbacks()},w.componentDidUpdate=function(){var t=this.props,e=t.direction,r=t.layout,o=this.state,n=o.scrollOffset;if(o.scrollUpdateWasRequested&&null!=this._outerRef){var i=this._outerRef;if("horizontal"===e||"horizontal"===r)if("rtl"===e)switch(p()){case"negative":i.scrollLeft=-n;break;case"positive-ascending":i.scrollLeft=n;break;default:var a=i.clientWidth,l=i.scrollWidth;i.scrollLeft=l-a-n}else i.scrollLeft=n;else i.scrollTop=n}this._callPropsCallbacks()},w.componentWillUnmount=function(){null!==this._resetIsScrollingTimeoutId&&u(this._resetIsScrollingTimeoutId)},w.render=function(){var t=this.props,o=t.children,n=t.className,i=t.direction,a=t.height,s=t.innerRef,c=t.innerElementType,u=t.innerTagName,f=t.itemCount,d=t.itemData,h=t.itemKey,m=void 0===h?O:h,p=t.layout,v=t.outerElementType,g=t.outerTagName,S=t.style,I=t.useIsScrolling,w=t.width,M=this.state.isScrolling,x="horizontal"===i||"horizontal"===p,_=x?this._onScrollHorizontal:this._onScrollVertical,C=this._getRangeToRender(),R=C[0],y=C[1],T=[];if(f>0)for(var z=R;z<=y;z++)T.push(e.createElement(o,{data:d,key:m(z,d),index:z,isScrolling:I?M:void 0,style:this._getItemStyle(z)}));var b=l(this.props,this._instanceProps);return e.createElement(v||g||"div",{className:n,onScroll:_,ref:this._outerRefSetter,style:r({position:"relative",height:a,width:w,overflow:"auto",WebkitOverflowScrolling:"touch",willChange:"transform",direction:i},S)},e.createElement(c||u||"div",{children:T,ref:s,style:{height:x?"100%":b,pointerEvents:M?"none":void 0,width:x?b:"100%"}}))},w._callPropsCallbacks=function(){if("function"==typeof this.props.onItemsRendered&&this.props.itemCount>0){var t=this._getRangeToRender(),e=t[0],r=t[1],o=t[2],n=t[3];this._callOnItemsRendered(e,r,o,n)}if("function"==typeof this.props.onScroll){var i=this.state,a=i.scrollDirection,l=i.scrollOffset,s=i.scrollUpdateWasRequested;this._callOnScroll(a,l,s)}},w._getRangeToRender=function(){var t=this.props,e=t.itemCount,r=t.overscanCount,o=this.state,n=o.isScrolling,i=o.scrollDirection,a=o.scrollOffset;if(0===e)return[0,0,0,0];var l=m(this.props,a,this._instanceProps),s=v(this.props,l,a,this._instanceProps),c=n&&"backward"!==i?1:Math.max(1,r),u=n&&"forward"!==i?1:Math.max(1,r);return[Math.max(0,l-c),Math.max(0,Math.min(e-1,s+u)),l,s]},n}(e.PureComponent)).defaultProps={direction:"ltr",itemData:void 0,layout:"vertical",overscanCount:2,useIsScrolling:!1},n}var z=function(t,e){t.children,t.direction,t.height,t.layout,t.innerTagName,t.outerTagName,t.width,e.instance},b=function(t,e,r){var o=t.itemSize,n=r.itemMetadataMap,i=r.lastMeasuredIndex;if(e>i){var a=0;if(i>=0){var l=n[i];a=l.offset+l.size}for(var s=i+1;s<=e;s++){var c=o(s);n[s]={offset:a,size:c},a+=c}r.lastMeasuredIndex=e}return n[e]},P=function(t,e,r,o,n){for(;o<=r;){var i=o+Math.floor((r-o)/2),a=b(t,i,e).offset;if(a===n)return i;a<n?o=i+1:a>n&&(r=i-1)}return o>0?o-1:0},W=function(t,e,r,o){for(var n=t.itemCount,i=1;r<n&&b(t,r,e).offset<o;)r+=i,i*=2;return P(t,e,Math.min(r,n-1),Math.floor(r/2),o)},D=function(t,e){var r=t.itemCount,o=e.itemMetadataMap,n=e.estimatedItemSize,i=e.lastMeasuredIndex,a=0;if(i>=r&&(i=r-1),i>=0){var l=o[i];a=l.offset+l.size}return a+(r-i-1)*n},F=T({getItemOffset:function(t,e,r){return b(t,e,r).offset},getItemSize:function(t,e,r){return r.itemMetadataMap[e].size},getEstimatedTotalSize:D,getOffsetForIndexAndAlignment:function(t,e,r,o,n,i){var a=t.direction,l=t.height,s=t.layout,c=t.width,u="horizontal"===a||"horizontal"===s?c:l,f=b(t,e,n),d=D(t,n),h=Math.max(0,Math.min(d-u,f.offset)),m=Math.max(0,f.offset-u+f.size+i);switch("smart"===r&&(r=o>=m-u&&o<=h+u?"auto":"center"),r){case"start":return h;case"end":return m;case"center":return Math.round(m+(h-m)/2);case"auto":default:return o>=m&&o<=h?o:o<m?m:h}},getStartIndexForOffset:function(t,e,r){return function(t,e,r){var o=e.itemMetadataMap,n=e.lastMeasuredIndex;return(n>0?o[n].offset:0)>=r?P(t,e,n,0,r):W(t,e,Math.max(0,n),r)}(t,r,e)},getStopIndexForStartIndex:function(t,e,r,o){for(var n=t.direction,i=t.height,a=t.itemCount,l=t.layout,s=t.width,c="horizontal"===n||"horizontal"===l?s:i,u=b(t,e,o),f=r+c,d=u.offset+u.size,h=e;h<a-1&&d<f;)h++,d+=b(t,h,o).size;return h},initInstanceProps:function(t,e){var r={itemMetadataMap:{},estimatedItemSize:t.estimatedItemSize||50,lastMeasuredIndex:-1};return e.resetAfterIndex=function(t,o){void 0===o&&(o=!0),r.lastMeasuredIndex=Math.min(r.lastMeasuredIndex,t-1),e._getItemStyleCache(-1),o&&e.forceUpdate()},r},shouldResetStyleCacheOnItemSizeChange:!1,validateProps:function(t){t.itemSize}}),L=g({getColumnOffset:function(t,e){return e*t.columnWidth},getColumnWidth:function(t,e){return t.columnWidth},getRowOffset:function(t,e){return e*t.rowHeight},getRowHeight:function(t,e){return t.rowHeight},getEstimatedTotalHeight:function(t){var e=t.rowCount;return t.rowHeight*e},getEstimatedTotalWidth:function(t){var e=t.columnCount;return t.columnWidth*e},getOffsetForColumnAndAlignment:function(t,e,r,o,n,i){var a=t.columnCount,l=t.columnWidth,s=t.width,c=Math.max(0,a*l-s),u=Math.min(c,e*l),f=Math.max(0,e*l-s+i+l);switch("smart"===r&&(r=o>=f-s&&o<=u+s?"auto":"center"),r){case"start":return u;case"end":return f;case"center":var d=Math.round(f+(u-f)/2);return d<Math.ceil(s/2)?0:d>c+Math.floor(s/2)?c:d;case"auto":default:return o>=f&&o<=u?o:f>u||o<f?f:u}},getOffsetForRowAndAlignment:function(t,e,r,o,n,i){var a=t.rowHeight,l=t.height,s=t.rowCount,c=Math.max(0,s*a-l),u=Math.min(c,e*a),f=Math.max(0,e*a-l+i+a);switch("smart"===r&&(r=o>=f-l&&o<=u+l?"auto":"center"),r){case"start":return u;case"end":return f;case"center":var d=Math.round(f+(u-f)/2);return d<Math.ceil(l/2)?0:d>c+Math.floor(l/2)?c:d;case"auto":default:return o>=f&&o<=u?o:f>u||o<f?f:u}},getColumnStartIndexForOffset:function(t,e){var r=t.columnWidth,o=t.columnCount;return Math.max(0,Math.min(o-1,Math.floor(e/r)))},getColumnStopIndexForStartIndex:function(t,e,r){var o=t.columnWidth,n=t.columnCount,i=t.width,a=e*o,l=Math.ceil((i+r-a)/o);return Math.max(0,Math.min(n-1,e+l-1))},getRowStartIndexForOffset:function(t,e){var r=t.rowHeight,o=t.rowCount;return Math.max(0,Math.min(o-1,Math.floor(e/r)))},getRowStopIndexForStartIndex:function(t,e,r){var o=t.rowHeight,n=t.rowCount,i=t.height,a=e*o,l=Math.ceil((i+r-a)/o);return Math.max(0,Math.min(n-1,e+l-1))},initInstanceProps:function(t){},shouldResetStyleCacheOnItemSizeChange:!0,validateProps:function(t){t.columnWidth,t.rowHeight}}),H=T({getItemOffset:function(t,e){return e*t.itemSize},getItemSize:function(t,e){return t.itemSize},getEstimatedTotalSize:function(t){var e=t.itemCount;return t.itemSize*e},getOffsetForIndexAndAlignment:function(t,e,r,o,n,i){var a=t.direction,l=t.height,s=t.itemCount,c=t.itemSize,u=t.layout,f=t.width,d="horizontal"===a||"horizontal"===u?f:l,h=Math.max(0,s*c-d),m=Math.min(h,e*c),p=Math.max(0,e*c-d+c+i);switch("smart"===r&&(r=o>=p-d&&o<=m+d?"auto":"center"),r){case"start":return m;case"end":return p;case"center":var v=Math.round(p+(m-p)/2);return v<Math.ceil(d/2)?0:v>h+Math.floor(d/2)?h:v;case"auto":default:return o>=p&&o<=m?o:o<p?p:m}},getStartIndexForOffset:function(t,e){var r=t.itemCount,o=t.itemSize;return Math.max(0,Math.min(r-1,Math.floor(e/o)))},getStopIndexForStartIndex:function(t,e,r){var o=t.direction,n=t.height,i=t.itemCount,a=t.itemSize,l=t.layout,s=t.width,c=e*a,u="horizontal"===o||"horizontal"===l?s:n,f=Math.ceil((u+r-c)/a);return Math.max(0,Math.min(i-1,e+f-1))},initInstanceProps:function(t){},shouldResetStyleCacheOnItemSizeChange:!0,validateProps:function(t){t.itemSize}});function k(t,e){if(null==t)return{};var r,o,n={},i=Object.keys(t);for(o=0;o<i.length;o++)r=i[o],e.indexOf(r)>=0||(n[r]=t[r]);return n}function A(t,e){for(var r in t)if(!(r in e))return!0;for(var o in e)if(t[o]!==e[o])return!0;return!1}var E=["style"],U=["style"];function q(t,e){var r=t.style,o=k(t,E),n=e.style,i=k(e,U);return!A(r,n)&&!A(o,i)}t.FixedSizeGrid=L,t.FixedSizeList=H,t.VariableSizeGrid=y,t.VariableSizeList=F,t.areEqual=q,t.shouldComponentUpdate=function(t,e){return!q(this.props,t)||A(this.state,e)},Object.defineProperty(t,"__esModule",{value:!0})}));
 //# sourceMappingURL=index-prod.umd.js.map
diff --git a/node_modules/react-window/dist/index-prod.umd.js.map b/node_modules/react-window/dist/index-prod.umd.js.map
index aa9661f..0163293 100644
--- a/node_modules/react-window/dist/index-prod.umd.js.map
+++ b/node_modules/react-window/dist/index-prod.umd.js.map
@@ -1 +1 @@
-{"version":3,"file":"index-prod.umd.js","sources":["../node_modules/@babel/runtime/helpers/esm/extends.js","../node_modules/@babel/runtime/helpers/esm/inheritsLoose.js","../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","../node_modules/memoize-one/dist/memoize-one.esm.js","../src/timer.js","../src/domHelpers.js","../src/createGridComponent.js","../src/VariableSizeGrid.js","../src/createListComponent.js","../src/VariableSizeList.js","../src/FixedSizeGrid.js","../src/FixedSizeList.js","../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js","../src/shallowDiffers.js","../src/areEqual.js","../src/shouldComponentUpdate.js"],"sourcesContent":["export default function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}","export default function _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}","export default function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}","var shallowEqual = function shallowEqual(newValue, oldValue) {\n  return newValue === oldValue;\n};\n\nvar simpleIsEqual = function simpleIsEqual(newArgs, lastArgs) {\n  return newArgs.length === lastArgs.length && newArgs.every(function (newArg, index) {\n    return shallowEqual(newArg, lastArgs[index]);\n  });\n};\n\nfunction index (resultFn, isEqual) {\n  if (isEqual === void 0) {\n    isEqual = simpleIsEqual;\n  }\n\n  var lastThis;\n  var lastArgs = [];\n  var lastResult;\n  var calledOnce = false;\n\n  var result = function result() {\n    for (var _len = arguments.length, newArgs = new Array(_len), _key = 0; _key < _len; _key++) {\n      newArgs[_key] = arguments[_key];\n    }\n\n    if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {\n      return lastResult;\n    }\n\n    lastResult = resultFn.apply(this, newArgs);\n    calledOnce = true;\n    lastThis = this;\n    lastArgs = newArgs;\n    return lastResult;\n  };\n\n  return result;\n}\n\nexport default index;\n","// @flow\n\n// Animation frame based implementation of setTimeout.\n// Inspired by Joe Lambert, https://gist.github.com/joelambert/1002116#file-requesttimeout-js\n\nconst hasNativePerformanceNow =\n  typeof performance === 'object' && typeof performance.now === 'function';\n\nconst now = hasNativePerformanceNow\n  ? () => performance.now()\n  : () => Date.now();\n\nexport type TimeoutID = {|\n  id: AnimationFrameID,\n|};\n\nexport function cancelTimeout(timeoutID: TimeoutID) {\n  cancelAnimationFrame(timeoutID.id);\n}\n\nexport function requestTimeout(callback: Function, delay: number): TimeoutID {\n  const start = now();\n\n  function tick() {\n    if (now() - start >= delay) {\n      callback.call(null);\n    } else {\n      timeoutID.id = requestAnimationFrame(tick);\n    }\n  }\n\n  const timeoutID: TimeoutID = {\n    id: requestAnimationFrame(tick),\n  };\n\n  return timeoutID;\n}\n","// @flow\n\nlet size: number = -1;\n\n// This utility copied from \"dom-helpers\" package.\nexport function getScrollbarSize(recalculate?: boolean = false): number {\n  if (size === -1 || recalculate) {\n    const div = document.createElement('div');\n    const style = div.style;\n    style.width = '50px';\n    style.height = '50px';\n    style.overflow = 'scroll';\n\n    ((document.body: any): HTMLBodyElement).appendChild(div);\n\n    size = div.offsetWidth - div.clientWidth;\n\n    ((document.body: any): HTMLBodyElement).removeChild(div);\n  }\n\n  return size;\n}\n\nexport type RTLOffsetType =\n  | 'negative'\n  | 'positive-descending'\n  | 'positive-ascending';\n\nlet cachedRTLResult: RTLOffsetType | null = null;\n\n// TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n// Chrome does not seem to adhere; its scrollLeft values are positive (measured relative to the left).\n// Safari's elastic bounce makes detecting this even more complicated wrt potential false positives.\n// The safest way to check this is to intentionally set a negative offset,\n// and then verify that the subsequent \"scroll\" event matches the negative offset.\n// If it does not match, then we can assume a non-standard RTL scroll implementation.\nexport function getRTLOffsetType(recalculate?: boolean = false): RTLOffsetType {\n  if (cachedRTLResult === null || recalculate) {\n    const outerDiv = document.createElement('div');\n    const outerStyle = outerDiv.style;\n    outerStyle.width = '50px';\n    outerStyle.height = '50px';\n    outerStyle.overflow = 'scroll';\n    outerStyle.direction = 'rtl';\n\n    const innerDiv = document.createElement('div');\n    const innerStyle = innerDiv.style;\n    innerStyle.width = '100px';\n    innerStyle.height = '100px';\n\n    outerDiv.appendChild(innerDiv);\n\n    ((document.body: any): HTMLBodyElement).appendChild(outerDiv);\n\n    if (outerDiv.scrollLeft > 0) {\n      cachedRTLResult = 'positive-descending';\n    } else {\n      outerDiv.scrollLeft = 1;\n      if (outerDiv.scrollLeft === 0) {\n        cachedRTLResult = 'negative';\n      } else {\n        cachedRTLResult = 'positive-ascending';\n      }\n    }\n\n    ((document.body: any): HTMLBodyElement).removeChild(outerDiv);\n\n    return cachedRTLResult;\n  }\n\n  return cachedRTLResult;\n}\n","// @flow\n\nimport memoizeOne from 'memoize-one';\nimport { createElement, PureComponent } from 'react';\nimport { cancelTimeout, requestTimeout } from './timer';\nimport { getScrollbarSize, getRTLOffsetType } from './domHelpers';\n\nimport type { TimeoutID } from './timer';\n\ntype Direction = 'ltr' | 'rtl';\nexport type ScrollToAlign = 'auto' | 'smart' | 'center' | 'start' | 'end';\n\ntype itemSize = number | ((index: number) => number);\n\ntype RenderComponentProps<T> = {|\n  columnIndex: number,\n  data: T,\n  isScrolling?: boolean,\n  rowIndex: number,\n  style: Object,\n|};\nexport type RenderComponent<T> = React$ComponentType<\n  $Shape<RenderComponentProps<T>>\n>;\n\ntype ScrollDirection = 'forward' | 'backward';\n\ntype OnItemsRenderedCallback = ({\n  overscanColumnStartIndex: number,\n  overscanColumnStopIndex: number,\n  overscanRowStartIndex: number,\n  overscanRowStopIndex: number,\n  visibleColumnStartIndex: number,\n  visibleColumnStopIndex: number,\n  visibleRowStartIndex: number,\n  visibleRowStopIndex: number,\n}) => void;\ntype OnScrollCallback = ({\n  horizontalScrollDirection: ScrollDirection,\n  scrollLeft: number,\n  scrollTop: number,\n  scrollUpdateWasRequested: boolean,\n  verticalScrollDirection: ScrollDirection,\n}) => void;\n\ntype ScrollEvent = SyntheticEvent<HTMLDivElement>;\ntype ItemStyleCache = { [key: string]: Object };\n\ntype OuterProps = {|\n  children: React$Node,\n  className: string | void,\n  onScroll: ScrollEvent => void,\n  style: {\n    [string]: mixed,\n  },\n|};\n\ntype InnerProps = {|\n  children: React$Node,\n  style: {\n    [string]: mixed,\n  },\n|};\n\nexport type Props<T> = {|\n  children: RenderComponent<T>,\n  className?: string,\n  columnCount: number,\n  columnWidth: itemSize,\n  direction: Direction,\n  height: number,\n  initialScrollLeft?: number,\n  initialScrollTop?: number,\n  innerRef?: any,\n  innerElementType?: string | React$AbstractComponent<InnerProps, any>,\n  innerTagName?: string, // deprecated\n  itemData: T,\n  itemKey?: (params: {|\n    columnIndex: number,\n    data: T,\n    rowIndex: number,\n  |}) => any,\n  onItemsRendered?: OnItemsRenderedCallback,\n  onScroll?: OnScrollCallback,\n  outerRef?: any,\n  outerElementType?: string | React$AbstractComponent<OuterProps, any>,\n  outerTagName?: string, // deprecated\n  overscanColumnCount?: number,\n  overscanColumnsCount?: number, // deprecated\n  overscanCount?: number, // deprecated\n  overscanRowCount?: number,\n  overscanRowsCount?: number, // deprecated\n  rowCount: number,\n  rowHeight: itemSize,\n  style?: Object,\n  useIsScrolling: boolean,\n  width: number,\n|};\n\ntype State = {|\n  instance: any,\n  isScrolling: boolean,\n  horizontalScrollDirection: ScrollDirection,\n  scrollLeft: number,\n  scrollTop: number,\n  scrollUpdateWasRequested: boolean,\n  verticalScrollDirection: ScrollDirection,\n|};\n\ntype getItemOffset = (\n  props: Props<any>,\n  index: number,\n  instanceProps: any\n) => number;\ntype getItemSize = (\n  props: Props<any>,\n  index: number,\n  instanceProps: any\n) => number;\ntype getEstimatedTotalSize = (props: Props<any>, instanceProps: any) => number;\ntype GetOffsetForItemAndAlignment = (\n  props: Props<any>,\n  index: number,\n  align: ScrollToAlign,\n  scrollOffset: number,\n  instanceProps: any,\n  scrollbarSize: number\n) => number;\ntype GetStartIndexForOffset = (\n  props: Props<any>,\n  offset: number,\n  instanceProps: any\n) => number;\ntype GetStopIndexForStartIndex = (\n  props: Props<any>,\n  startIndex: number,\n  scrollOffset: number,\n  instanceProps: any\n) => number;\ntype InitInstanceProps = (props: Props<any>, instance: any) => any;\ntype ValidateProps = (props: Props<any>) => void;\n\nconst IS_SCROLLING_DEBOUNCE_INTERVAL = 150;\n\nconst defaultItemKey = ({ columnIndex, data, rowIndex }) =>\n  `${rowIndex}:${columnIndex}`;\n\n// In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\nlet devWarningsOverscanCount = null;\nlet devWarningsOverscanRowsColumnsCount = null;\nlet devWarningsTagName = null;\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsOverscanCount = new WeakSet();\n    devWarningsOverscanRowsColumnsCount = new WeakSet();\n    devWarningsTagName = new WeakSet();\n  }\n}\n\nexport default function createGridComponent({\n  getColumnOffset,\n  getColumnStartIndexForOffset,\n  getColumnStopIndexForStartIndex,\n  getColumnWidth,\n  getEstimatedTotalHeight,\n  getEstimatedTotalWidth,\n  getOffsetForColumnAndAlignment,\n  getOffsetForRowAndAlignment,\n  getRowHeight,\n  getRowOffset,\n  getRowStartIndexForOffset,\n  getRowStopIndexForStartIndex,\n  initInstanceProps,\n  shouldResetStyleCacheOnItemSizeChange,\n  validateProps,\n}: {|\n  getColumnOffset: getItemOffset,\n  getColumnStartIndexForOffset: GetStartIndexForOffset,\n  getColumnStopIndexForStartIndex: GetStopIndexForStartIndex,\n  getColumnWidth: getItemSize,\n  getEstimatedTotalHeight: getEstimatedTotalSize,\n  getEstimatedTotalWidth: getEstimatedTotalSize,\n  getOffsetForColumnAndAlignment: GetOffsetForItemAndAlignment,\n  getOffsetForRowAndAlignment: GetOffsetForItemAndAlignment,\n  getRowOffset: getItemOffset,\n  getRowHeight: getItemSize,\n  getRowStartIndexForOffset: GetStartIndexForOffset,\n  getRowStopIndexForStartIndex: GetStopIndexForStartIndex,\n  initInstanceProps: InitInstanceProps,\n  shouldResetStyleCacheOnItemSizeChange: boolean,\n  validateProps: ValidateProps,\n|}) {\n  return class Grid<T> extends PureComponent<Props<T>, State> {\n    _instanceProps: any = initInstanceProps(this.props, this);\n    _resetIsScrollingTimeoutId: TimeoutID | null = null;\n    _outerRef: ?HTMLDivElement;\n\n    static defaultProps = {\n      direction: 'ltr',\n      itemData: undefined,\n      useIsScrolling: false,\n    };\n\n    state: State = {\n      instance: this,\n      isScrolling: false,\n      horizontalScrollDirection: 'forward',\n      scrollLeft:\n        typeof this.props.initialScrollLeft === 'number'\n          ? this.props.initialScrollLeft\n          : 0,\n      scrollTop:\n        typeof this.props.initialScrollTop === 'number'\n          ? this.props.initialScrollTop\n          : 0,\n      scrollUpdateWasRequested: false,\n      verticalScrollDirection: 'forward',\n    };\n\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    constructor(props: Props<T>) {\n      super(props);\n    }\n\n    static getDerivedStateFromProps(\n      nextProps: Props<T>,\n      prevState: State\n    ): $Shape<State> | null {\n      validateSharedProps(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    }\n\n    scrollTo({\n      scrollLeft,\n      scrollTop,\n    }: {\n      scrollLeft: number,\n      scrollTop: number,\n    }): void {\n      if (scrollLeft !== undefined) {\n        scrollLeft = Math.max(0, scrollLeft);\n      }\n      if (scrollTop !== undefined) {\n        scrollTop = Math.max(0, scrollTop);\n      }\n\n      this.setState(prevState => {\n        if (scrollLeft === undefined) {\n          scrollLeft = prevState.scrollLeft;\n        }\n        if (scrollTop === undefined) {\n          scrollTop = prevState.scrollTop;\n        }\n\n        if (\n          prevState.scrollLeft === scrollLeft &&\n          prevState.scrollTop === scrollTop\n        ) {\n          return null;\n        }\n\n        return {\n          horizontalScrollDirection:\n            prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          scrollUpdateWasRequested: true,\n          verticalScrollDirection:\n            prevState.scrollTop < scrollTop ? 'forward' : 'backward',\n        };\n      }, this._resetIsScrollingDebounced);\n    }\n\n    scrollToItem({\n      align = 'auto',\n      columnIndex,\n      rowIndex,\n    }: {\n      align: ScrollToAlign,\n      columnIndex?: number,\n      rowIndex?: number,\n    }): void {\n      const { columnCount, height, rowCount, width } = this.props;\n      const { scrollLeft, scrollTop } = this.state;\n      const scrollbarSize = getScrollbarSize();\n\n      if (columnIndex !== undefined) {\n        columnIndex = Math.max(0, Math.min(columnIndex, columnCount - 1));\n      }\n      if (rowIndex !== undefined) {\n        rowIndex = Math.max(0, Math.min(rowIndex, rowCount - 1));\n      }\n\n      const estimatedTotalHeight = getEstimatedTotalHeight(\n        this.props,\n        this._instanceProps\n      );\n      const estimatedTotalWidth = getEstimatedTotalWidth(\n        this.props,\n        this._instanceProps\n      );\n\n      // The scrollbar size should be considered when scrolling an item into view,\n      // to ensure it's fully visible.\n      // But we only need to account for its size when it's actually visible.\n      const horizontalScrollbarSize =\n        estimatedTotalWidth > width ? scrollbarSize : 0;\n      const verticalScrollbarSize =\n        estimatedTotalHeight > height ? scrollbarSize : 0;\n\n      this.scrollTo({\n        scrollLeft:\n          columnIndex !== undefined\n            ? getOffsetForColumnAndAlignment(\n                this.props,\n                columnIndex,\n                align,\n                scrollLeft,\n                this._instanceProps,\n                verticalScrollbarSize\n              )\n            : scrollLeft,\n        scrollTop:\n          rowIndex !== undefined\n            ? getOffsetForRowAndAlignment(\n                this.props,\n                rowIndex,\n                align,\n                scrollTop,\n                this._instanceProps,\n                horizontalScrollbarSize\n              )\n            : scrollTop,\n      });\n    }\n\n    componentDidMount() {\n      const { initialScrollLeft, initialScrollTop } = this.props;\n\n      if (this._outerRef != null) {\n        const outerRef = ((this._outerRef: any): HTMLElement);\n        if (typeof initialScrollLeft === 'number') {\n          outerRef.scrollLeft = initialScrollLeft;\n        }\n        if (typeof initialScrollTop === 'number') {\n          outerRef.scrollTop = initialScrollTop;\n        }\n      }\n\n      this._callPropsCallbacks();\n    }\n\n    componentDidUpdate() {\n      const { direction } = this.props;\n      const { scrollLeft, scrollTop, scrollUpdateWasRequested } = this.state;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n        // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n        // So we need to determine which browser behavior we're dealing with, and mimic it.\n        const outerRef = ((this._outerRef: any): HTMLElement);\n        if (direction === 'rtl') {\n          switch (getRTLOffsetType()) {\n            case 'negative':\n              outerRef.scrollLeft = -scrollLeft;\n              break;\n            case 'positive-ascending':\n              outerRef.scrollLeft = scrollLeft;\n              break;\n            default:\n              const { clientWidth, scrollWidth } = outerRef;\n              outerRef.scrollLeft = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        } else {\n          outerRef.scrollLeft = Math.max(0, scrollLeft);\n        }\n\n        outerRef.scrollTop = Math.max(0, scrollTop);\n      }\n\n      this._callPropsCallbacks();\n    }\n\n    componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    }\n\n    render() {\n      const {\n        children,\n        className,\n        columnCount,\n        direction,\n        height,\n        innerRef,\n        innerElementType,\n        innerTagName,\n        itemData,\n        itemKey = defaultItemKey,\n        outerElementType,\n        outerTagName,\n        rowCount,\n        style,\n        useIsScrolling,\n        width,\n      } = this.props;\n      const { isScrolling } = this.state;\n\n      const [\n        columnStartIndex,\n        columnStopIndex,\n      ] = this._getHorizontalRangeToRender();\n      const [rowStartIndex, rowStopIndex] = this._getVerticalRangeToRender();\n\n      const items = [];\n      if (columnCount > 0 && rowCount) {\n        for (\n          let rowIndex = rowStartIndex;\n          rowIndex <= rowStopIndex;\n          rowIndex++\n        ) {\n          for (\n            let columnIndex = columnStartIndex;\n            columnIndex <= columnStopIndex;\n            columnIndex++\n          ) {\n            items.push(\n              createElement(children, {\n                columnIndex,\n                data: itemData,\n                isScrolling: useIsScrolling ? isScrolling : undefined,\n                key: itemKey({ columnIndex, data: itemData, rowIndex }),\n                rowIndex,\n                style: this._getItemStyle(rowIndex, columnIndex),\n              })\n            );\n          }\n        }\n      }\n\n      // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n      const estimatedTotalHeight = getEstimatedTotalHeight(\n        this.props,\n        this._instanceProps\n      );\n      const estimatedTotalWidth = getEstimatedTotalWidth(\n        this.props,\n        this._instanceProps\n      );\n\n      return createElement(\n        outerElementType || outerTagName || 'div',\n        {\n          className,\n          onScroll: this._onScroll,\n          ref: this._outerRefSetter,\n          style: {\n            position: 'relative',\n            height,\n            width,\n            overflow: 'auto',\n            WebkitOverflowScrolling: 'touch',\n            willChange: 'transform',\n            direction,\n            ...style,\n          },\n        },\n        createElement(innerElementType || innerTagName || 'div', {\n          children: items,\n          ref: innerRef,\n          style: {\n            height: estimatedTotalHeight,\n            pointerEvents: isScrolling ? 'none' : undefined,\n            width: estimatedTotalWidth,\n          },\n        })\n      );\n    }\n\n    _callOnItemsRendered: (\n      overscanColumnStartIndex: number,\n      overscanColumnStopIndex: number,\n      overscanRowStartIndex: number,\n      overscanRowStopIndex: number,\n      visibleColumnStartIndex: number,\n      visibleColumnStopIndex: number,\n      visibleRowStartIndex: number,\n      visibleRowStopIndex: number\n    ) => void;\n    _callOnItemsRendered = memoizeOne(\n      (\n        overscanColumnStartIndex: number,\n        overscanColumnStopIndex: number,\n        overscanRowStartIndex: number,\n        overscanRowStopIndex: number,\n        visibleColumnStartIndex: number,\n        visibleColumnStopIndex: number,\n        visibleRowStartIndex: number,\n        visibleRowStopIndex: number\n      ) =>\n        ((this.props.onItemsRendered: any): OnItemsRenderedCallback)({\n          overscanColumnStartIndex,\n          overscanColumnStopIndex,\n          overscanRowStartIndex,\n          overscanRowStopIndex,\n          visibleColumnStartIndex,\n          visibleColumnStopIndex,\n          visibleRowStartIndex,\n          visibleRowStopIndex,\n        })\n    );\n\n    _callOnScroll: (\n      scrollLeft: number,\n      scrollTop: number,\n      horizontalScrollDirection: ScrollDirection,\n      verticalScrollDirection: ScrollDirection,\n      scrollUpdateWasRequested: boolean\n    ) => void;\n    _callOnScroll = memoizeOne(\n      (\n        scrollLeft: number,\n        scrollTop: number,\n        horizontalScrollDirection: ScrollDirection,\n        verticalScrollDirection: ScrollDirection,\n        scrollUpdateWasRequested: boolean\n      ) =>\n        ((this.props.onScroll: any): OnScrollCallback)({\n          horizontalScrollDirection,\n          scrollLeft,\n          scrollTop,\n          verticalScrollDirection,\n          scrollUpdateWasRequested,\n        })\n    );\n\n    _callPropsCallbacks() {\n      const { columnCount, onItemsRendered, onScroll, rowCount } = this.props;\n\n      if (typeof onItemsRendered === 'function') {\n        if (columnCount > 0 && rowCount > 0) {\n          const [\n            overscanColumnStartIndex,\n            overscanColumnStopIndex,\n            visibleColumnStartIndex,\n            visibleColumnStopIndex,\n          ] = this._getHorizontalRangeToRender();\n          const [\n            overscanRowStartIndex,\n            overscanRowStopIndex,\n            visibleRowStartIndex,\n            visibleRowStopIndex,\n          ] = this._getVerticalRangeToRender();\n          this._callOnItemsRendered(\n            overscanColumnStartIndex,\n            overscanColumnStopIndex,\n            overscanRowStartIndex,\n            overscanRowStopIndex,\n            visibleColumnStartIndex,\n            visibleColumnStopIndex,\n            visibleRowStartIndex,\n            visibleRowStopIndex\n          );\n        }\n      }\n\n      if (typeof onScroll === 'function') {\n        const {\n          horizontalScrollDirection,\n          scrollLeft,\n          scrollTop,\n          scrollUpdateWasRequested,\n          verticalScrollDirection,\n        } = this.state;\n        this._callOnScroll(\n          scrollLeft,\n          scrollTop,\n          horizontalScrollDirection,\n          verticalScrollDirection,\n          scrollUpdateWasRequested\n        );\n      }\n    }\n\n    // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n    _getItemStyle: (rowIndex: number, columnIndex: number) => Object;\n    _getItemStyle = (rowIndex: number, columnIndex: number): Object => {\n      const { columnWidth, direction, rowHeight } = this.props;\n\n      const itemStyleCache = this._getItemStyleCache(\n        shouldResetStyleCacheOnItemSizeChange && columnWidth,\n        shouldResetStyleCacheOnItemSizeChange && direction,\n        shouldResetStyleCacheOnItemSizeChange && rowHeight\n      );\n\n      const key = `${rowIndex}:${columnIndex}`;\n\n      let style;\n      if (itemStyleCache.hasOwnProperty(key)) {\n        style = itemStyleCache[key];\n      } else {\n        const offset = getColumnOffset(\n          this.props,\n          columnIndex,\n          this._instanceProps\n        );\n        const isRtl = direction === 'rtl';\n        itemStyleCache[key] = style = {\n          position: 'absolute',\n          left: isRtl ? undefined : offset,\n          right: isRtl ? offset : undefined,\n          top: getRowOffset(this.props, rowIndex, this._instanceProps),\n          height: getRowHeight(this.props, rowIndex, this._instanceProps),\n          width: getColumnWidth(this.props, columnIndex, this._instanceProps),\n        };\n      }\n\n      return style;\n    };\n\n    _getItemStyleCache: (_: any, __: any, ___: any) => ItemStyleCache;\n    _getItemStyleCache = memoizeOne((_: any, __: any, ___: any) => ({}));\n\n    _getHorizontalRangeToRender(): [number, number, number, number] {\n      const {\n        columnCount,\n        overscanColumnCount,\n        overscanColumnsCount,\n        overscanCount,\n        rowCount,\n      } = this.props;\n      const { horizontalScrollDirection, isScrolling, scrollLeft } = this.state;\n\n      const overscanCountResolved: number =\n        overscanColumnCount || overscanColumnsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      const startIndex = getColumnStartIndexForOffset(\n        this.props,\n        scrollLeft,\n        this._instanceProps\n      );\n      const stopIndex = getColumnStopIndexForStartIndex(\n        this.props,\n        startIndex,\n        scrollLeft,\n        this._instanceProps\n      );\n\n      // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n      const overscanBackward =\n        !isScrolling || horizontalScrollDirection === 'backward'\n          ? Math.max(1, overscanCountResolved)\n          : 1;\n      const overscanForward =\n        !isScrolling || horizontalScrollDirection === 'forward'\n          ? Math.max(1, overscanCountResolved)\n          : 1;\n\n      return [\n        Math.max(0, startIndex - overscanBackward),\n        Math.max(0, Math.min(columnCount - 1, stopIndex + overscanForward)),\n        startIndex,\n        stopIndex,\n      ];\n    }\n\n    _getVerticalRangeToRender(): [number, number, number, number] {\n      const {\n        columnCount,\n        overscanCount,\n        overscanRowCount,\n        overscanRowsCount,\n        rowCount,\n      } = this.props;\n      const { isScrolling, verticalScrollDirection, scrollTop } = this.state;\n\n      const overscanCountResolved: number =\n        overscanRowCount || overscanRowsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      const startIndex = getRowStartIndexForOffset(\n        this.props,\n        scrollTop,\n        this._instanceProps\n      );\n      const stopIndex = getRowStopIndexForStartIndex(\n        this.props,\n        startIndex,\n        scrollTop,\n        this._instanceProps\n      );\n\n      // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n      const overscanBackward =\n        !isScrolling || verticalScrollDirection === 'backward'\n          ? Math.max(1, overscanCountResolved)\n          : 1;\n      const overscanForward =\n        !isScrolling || verticalScrollDirection === 'forward'\n          ? Math.max(1, overscanCountResolved)\n          : 1;\n\n      return [\n        Math.max(0, startIndex - overscanBackward),\n        Math.max(0, Math.min(rowCount - 1, stopIndex + overscanForward)),\n        startIndex,\n        stopIndex,\n      ];\n    }\n\n    _onScroll = (event: ScrollEvent): void => {\n      const {\n        clientHeight,\n        clientWidth,\n        scrollLeft,\n        scrollTop,\n        scrollHeight,\n        scrollWidth,\n      } = event.currentTarget;\n      this.setState(prevState => {\n        if (\n          prevState.scrollLeft === scrollLeft &&\n          prevState.scrollTop === scrollTop\n        ) {\n          // Scroll position may have been updated by cDM/cDU,\n          // In which case we don't need to trigger another render,\n          // And we don't want to update state.isScrolling.\n          return null;\n        }\n\n        const { direction } = this.props;\n\n        // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n        // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n        // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n        // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n        let calculatedScrollLeft = scrollLeft;\n        if (direction === 'rtl') {\n          switch (getRTLOffsetType()) {\n            case 'negative':\n              calculatedScrollLeft = -scrollLeft;\n              break;\n            case 'positive-descending':\n              calculatedScrollLeft = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        }\n\n        // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n        calculatedScrollLeft = Math.max(\n          0,\n          Math.min(calculatedScrollLeft, scrollWidth - clientWidth)\n        );\n        const calculatedScrollTop = Math.max(\n          0,\n          Math.min(scrollTop, scrollHeight - clientHeight)\n        );\n\n        return {\n          isScrolling: true,\n          horizontalScrollDirection:\n            prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n          scrollLeft: calculatedScrollLeft,\n          scrollTop: calculatedScrollTop,\n          verticalScrollDirection:\n            prevState.scrollTop < scrollTop ? 'forward' : 'backward',\n          scrollUpdateWasRequested: false,\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _outerRefSetter = (ref: any): void => {\n      const { outerRef } = this.props;\n\n      this._outerRef = ((ref: any): HTMLDivElement);\n\n      if (typeof outerRef === 'function') {\n        outerRef(ref);\n      } else if (\n        outerRef != null &&\n        typeof outerRef === 'object' &&\n        outerRef.hasOwnProperty('current')\n      ) {\n        outerRef.current = ref;\n      }\n    };\n\n    _resetIsScrollingDebounced = () => {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n\n      this._resetIsScrollingTimeoutId = requestTimeout(\n        this._resetIsScrolling,\n        IS_SCROLLING_DEBOUNCE_INTERVAL\n      );\n    };\n\n    _resetIsScrolling = () => {\n      this._resetIsScrollingTimeoutId = null;\n\n      this.setState({ isScrolling: false }, () => {\n        // Clear style cache after state update has been committed.\n        // This way we don't break pure sCU for items that don't use isScrolling param.\n        this._getItemStyleCache(-1);\n      });\n    };\n  };\n}\n\nconst validateSharedProps = (\n  {\n    children,\n    direction,\n    height,\n    innerTagName,\n    outerTagName,\n    overscanColumnsCount,\n    overscanCount,\n    overscanRowsCount,\n    width,\n  }: Props<any>,\n  { instance }: State\n): void => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof overscanCount === 'number') {\n      if (devWarningsOverscanCount && !devWarningsOverscanCount.has(instance)) {\n        devWarningsOverscanCount.add(instance);\n        console.warn(\n          'The overscanCount prop has been deprecated. ' +\n            'Please use the overscanColumnCount and overscanRowCount props instead.'\n        );\n      }\n    }\n\n    if (\n      typeof overscanColumnsCount === 'number' ||\n      typeof overscanRowsCount === 'number'\n    ) {\n      if (\n        devWarningsOverscanRowsColumnsCount &&\n        !devWarningsOverscanRowsColumnsCount.has(instance)\n      ) {\n        devWarningsOverscanRowsColumnsCount.add(instance);\n        console.warn(\n          'The overscanColumnsCount and overscanRowsCount props have been deprecated. ' +\n            'Please use the overscanColumnCount and overscanRowCount props instead.'\n        );\n      }\n    }\n\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName && !devWarningsTagName.has(instance)) {\n        devWarningsTagName.add(instance);\n        console.warn(\n          'The innerTagName and outerTagName props have been deprecated. ' +\n            'Please use the innerElementType and outerElementType props instead.'\n        );\n      }\n    }\n\n    if (children == null) {\n      throw Error(\n        'An invalid \"children\" prop has been specified. ' +\n          'Value should be a React component. ' +\n          `\"${children === null ? 'null' : typeof children}\" was specified.`\n      );\n    }\n\n    switch (direction) {\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n      default:\n        throw Error(\n          'An invalid \"direction\" prop has been specified. ' +\n            'Value should be either \"ltr\" or \"rtl\". ' +\n            `\"${direction}\" was specified.`\n        );\n    }\n\n    if (typeof width !== 'number') {\n      throw Error(\n        'An invalid \"width\" prop has been specified. ' +\n          'Grids must specify a number for width. ' +\n          `\"${width === null ? 'null' : typeof width}\" was specified.`\n      );\n    }\n\n    if (typeof height !== 'number') {\n      throw Error(\n        'An invalid \"height\" prop has been specified. ' +\n          'Grids must specify a number for height. ' +\n          `\"${height === null ? 'null' : typeof height}\" was specified.`\n      );\n    }\n  }\n};\n","// @flow\n\nimport createGridComponent from './createGridComponent';\n\nimport type { Props, ScrollToAlign } from './createGridComponent';\n\nconst DEFAULT_ESTIMATED_ITEM_SIZE = 50;\n\ntype VariableSizeProps = {|\n  estimatedColumnWidth: number,\n  estimatedRowHeight: number,\n  ...Props<any>,\n|};\n\ntype itemSizeGetter = (index: number) => number;\ntype ItemType = 'column' | 'row';\n\ntype ItemMetadata = {|\n  offset: number,\n  size: number,\n|};\ntype ItemMetadataMap = { [index: number]: ItemMetadata };\ntype InstanceProps = {|\n  columnMetadataMap: ItemMetadataMap,\n  estimatedColumnWidth: number,\n  estimatedRowHeight: number,\n  lastMeasuredColumnIndex: number,\n  lastMeasuredRowIndex: number,\n  rowMetadataMap: ItemMetadataMap,\n|};\n\nconst getEstimatedTotalHeight = (\n  { rowCount }: Props<any>,\n  { rowMetadataMap, estimatedRowHeight, lastMeasuredRowIndex }: InstanceProps\n) => {\n  let totalSizeOfMeasuredRows = 0;\n\n  // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n  if (lastMeasuredRowIndex >= rowCount) {\n    lastMeasuredRowIndex = rowCount - 1;\n  }\n\n  if (lastMeasuredRowIndex >= 0) {\n    const itemMetadata = rowMetadataMap[lastMeasuredRowIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  const numUnmeasuredItems = rowCount - lastMeasuredRowIndex - 1;\n  const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedRowHeight;\n\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nconst getEstimatedTotalWidth = (\n  { columnCount }: Props<any>,\n  {\n    columnMetadataMap,\n    estimatedColumnWidth,\n    lastMeasuredColumnIndex,\n  }: InstanceProps\n) => {\n  let totalSizeOfMeasuredRows = 0;\n\n  // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n  if (lastMeasuredColumnIndex >= columnCount) {\n    lastMeasuredColumnIndex = columnCount - 1;\n  }\n\n  if (lastMeasuredColumnIndex >= 0) {\n    const itemMetadata = columnMetadataMap[lastMeasuredColumnIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  const numUnmeasuredItems = columnCount - lastMeasuredColumnIndex - 1;\n  const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedColumnWidth;\n\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nconst getItemMetadata = (\n  itemType: ItemType,\n  props: Props<any>,\n  index: number,\n  instanceProps: InstanceProps\n): ItemMetadata => {\n  let itemMetadataMap, itemSize, lastMeasuredIndex;\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    itemSize = ((props.columnWidth: any): itemSizeGetter);\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    itemSize = ((props.rowHeight: any): itemSizeGetter);\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  if (index > lastMeasuredIndex) {\n    let offset = 0;\n    if (lastMeasuredIndex >= 0) {\n      const itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (let i = lastMeasuredIndex + 1; i <= index; i++) {\n      let size = itemSize(i);\n\n      itemMetadataMap[i] = {\n        offset,\n        size,\n      };\n\n      offset += size;\n    }\n\n    if (itemType === 'column') {\n      instanceProps.lastMeasuredColumnIndex = index;\n    } else {\n      instanceProps.lastMeasuredRowIndex = index;\n    }\n  }\n\n  return itemMetadataMap[index];\n};\n\nconst findNearestItem = (\n  itemType: ItemType,\n  props: Props<any>,\n  instanceProps: InstanceProps,\n  offset: number\n) => {\n  let itemMetadataMap, lastMeasuredIndex;\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  const lastMeasuredItemOffset =\n    lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch(\n      itemType,\n      props,\n      instanceProps,\n      lastMeasuredIndex,\n      0,\n      offset\n    );\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch(\n      itemType,\n      props,\n      instanceProps,\n      Math.max(0, lastMeasuredIndex),\n      offset\n    );\n  }\n};\n\nconst findNearestItemBinarySearch = (\n  itemType: ItemType,\n  props: Props<any>,\n  instanceProps: InstanceProps,\n  high: number,\n  low: number,\n  offset: number\n): number => {\n  while (low <= high) {\n    const middle = low + Math.floor((high - low) / 2);\n    const currentOffset = getItemMetadata(\n      itemType,\n      props,\n      middle,\n      instanceProps\n    ).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nconst findNearestItemExponentialSearch = (\n  itemType: ItemType,\n  props: Props<any>,\n  instanceProps: InstanceProps,\n  index: number,\n  offset: number\n): number => {\n  const itemCount = itemType === 'column' ? props.columnCount : props.rowCount;\n  let interval = 1;\n\n  while (\n    index < itemCount &&\n    getItemMetadata(itemType, props, index, instanceProps).offset < offset\n  ) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch(\n    itemType,\n    props,\n    instanceProps,\n    Math.min(index, itemCount - 1),\n    Math.floor(index / 2),\n    offset\n  );\n};\n\nconst getOffsetForIndexAndAlignment = (\n  itemType: ItemType,\n  props: Props<any>,\n  index: number,\n  align: ScrollToAlign,\n  scrollOffset: number,\n  instanceProps: InstanceProps,\n  scrollbarSize: number\n): number => {\n  const size = itemType === 'column' ? props.width : props.height;\n  const itemMetadata = getItemMetadata(itemType, props, index, instanceProps);\n\n  // Get estimated total size after ItemMetadata is computed,\n  // To ensure it reflects actual measurements instead of just estimates.\n  const estimatedTotalSize =\n    itemType === 'column'\n      ? getEstimatedTotalWidth(props, instanceProps)\n      : getEstimatedTotalHeight(props, instanceProps);\n\n  const maxOffset = Math.max(\n    0,\n    Math.min(estimatedTotalSize - size, itemMetadata.offset)\n  );\n  const minOffset = Math.max(\n    0,\n    itemMetadata.offset - size + scrollbarSize + itemMetadata.size\n  );\n\n  if (align === 'smart') {\n    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n      align = 'auto';\n    } else {\n      align = 'center';\n    }\n  }\n\n  switch (align) {\n    case 'start':\n      return maxOffset;\n    case 'end':\n      return minOffset;\n    case 'center':\n      return Math.round(minOffset + (maxOffset - minOffset) / 2);\n    case 'auto':\n    default:\n      if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n        return scrollOffset;\n      } else if (minOffset > maxOffset) {\n        // Because we only take into account the scrollbar size when calculating minOffset\n        // this value can be larger than maxOffset when at the end of the list\n        return minOffset;\n      } else if (scrollOffset < minOffset) {\n        return minOffset;\n      } else {\n        return maxOffset;\n      }\n  }\n};\n\nconst VariableSizeGrid = createGridComponent({\n  getColumnOffset: (\n    props: Props<any>,\n    index: number,\n    instanceProps: InstanceProps\n  ): number => getItemMetadata('column', props, index, instanceProps).offset,\n\n  getColumnStartIndexForOffset: (\n    props: Props<any>,\n    scrollLeft: number,\n    instanceProps: InstanceProps\n  ): number => findNearestItem('column', props, instanceProps, scrollLeft),\n\n  getColumnStopIndexForStartIndex: (\n    props: Props<any>,\n    startIndex: number,\n    scrollLeft: number,\n    instanceProps: InstanceProps\n  ): number => {\n    const { columnCount, width } = props;\n\n    const itemMetadata = getItemMetadata(\n      'column',\n      props,\n      startIndex,\n      instanceProps\n    );\n    const maxOffset = scrollLeft + width;\n\n    let offset = itemMetadata.offset + itemMetadata.size;\n    let stopIndex = startIndex;\n\n    while (stopIndex < columnCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata('column', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n\n  getColumnWidth: (\n    props: Props<any>,\n    index: number,\n    instanceProps: InstanceProps\n  ): number => instanceProps.columnMetadataMap[index].size,\n\n  getEstimatedTotalHeight,\n  getEstimatedTotalWidth,\n\n  getOffsetForColumnAndAlignment: (\n    props: Props<any>,\n    index: number,\n    align: ScrollToAlign,\n    scrollOffset: number,\n    instanceProps: InstanceProps,\n    scrollbarSize: number\n  ): number =>\n    getOffsetForIndexAndAlignment(\n      'column',\n      props,\n      index,\n      align,\n      scrollOffset,\n      instanceProps,\n      scrollbarSize\n    ),\n\n  getOffsetForRowAndAlignment: (\n    props: Props<any>,\n    index: number,\n    align: ScrollToAlign,\n    scrollOffset: number,\n    instanceProps: InstanceProps,\n    scrollbarSize: number\n  ): number =>\n    getOffsetForIndexAndAlignment(\n      'row',\n      props,\n      index,\n      align,\n      scrollOffset,\n      instanceProps,\n      scrollbarSize\n    ),\n\n  getRowOffset: (\n    props: Props<any>,\n    index: number,\n    instanceProps: InstanceProps\n  ): number => getItemMetadata('row', props, index, instanceProps).offset,\n\n  getRowHeight: (\n    props: Props<any>,\n    index: number,\n    instanceProps: InstanceProps\n  ): number => instanceProps.rowMetadataMap[index].size,\n\n  getRowStartIndexForOffset: (\n    props: Props<any>,\n    scrollTop: number,\n    instanceProps: InstanceProps\n  ): number => findNearestItem('row', props, instanceProps, scrollTop),\n\n  getRowStopIndexForStartIndex: (\n    props: Props<any>,\n    startIndex: number,\n    scrollTop: number,\n    instanceProps: InstanceProps\n  ): number => {\n    const { rowCount, height } = props;\n\n    const itemMetadata = getItemMetadata(\n      'row',\n      props,\n      startIndex,\n      instanceProps\n    );\n    const maxOffset = scrollTop + height;\n\n    let offset = itemMetadata.offset + itemMetadata.size;\n    let stopIndex = startIndex;\n\n    while (stopIndex < rowCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata('row', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n\n  initInstanceProps(props: Props<any>, instance: any): InstanceProps {\n    const {\n      estimatedColumnWidth,\n      estimatedRowHeight,\n    } = ((props: any): VariableSizeProps);\n\n    const instanceProps = {\n      columnMetadataMap: {},\n      estimatedColumnWidth: estimatedColumnWidth || DEFAULT_ESTIMATED_ITEM_SIZE,\n      estimatedRowHeight: estimatedRowHeight || DEFAULT_ESTIMATED_ITEM_SIZE,\n      lastMeasuredColumnIndex: -1,\n      lastMeasuredRowIndex: -1,\n      rowMetadataMap: {},\n    };\n\n    instance.resetAfterColumnIndex = (\n      columnIndex: number,\n      shouldForceUpdate?: boolean = true\n    ) => {\n      instance.resetAfterIndices({ columnIndex, shouldForceUpdate });\n    };\n\n    instance.resetAfterRowIndex = (\n      rowIndex: number,\n      shouldForceUpdate?: boolean = true\n    ) => {\n      instance.resetAfterIndices({ rowIndex, shouldForceUpdate });\n    };\n\n    instance.resetAfterIndices = ({\n      columnIndex,\n      rowIndex,\n      shouldForceUpdate = true,\n    }: {\n      columnIndex?: number,\n      rowIndex?: number,\n      shouldForceUpdate: boolean,\n    }) => {\n      if (typeof columnIndex === 'number') {\n        instanceProps.lastMeasuredColumnIndex = Math.min(\n          instanceProps.lastMeasuredColumnIndex,\n          columnIndex - 1\n        );\n      }\n      if (typeof rowIndex === 'number') {\n        instanceProps.lastMeasuredRowIndex = Math.min(\n          instanceProps.lastMeasuredRowIndex,\n          rowIndex - 1\n        );\n      }\n\n      // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n\n  shouldResetStyleCacheOnItemSizeChange: false,\n\n  validateProps: ({ columnWidth, rowHeight }: Props<any>): void => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'function') {\n        throw Error(\n          'An invalid \"columnWidth\" prop has been specified. ' +\n            'Value should be a function. ' +\n            `\"${\n              columnWidth === null ? 'null' : typeof columnWidth\n            }\" was specified.`\n        );\n      } else if (typeof rowHeight !== 'function') {\n        throw Error(\n          'An invalid \"rowHeight\" prop has been specified. ' +\n            'Value should be a function. ' +\n            `\"${rowHeight === null ? 'null' : typeof rowHeight}\" was specified.`\n        );\n      }\n    }\n  },\n});\n\nexport default VariableSizeGrid;\n","// @flow\n\nimport memoizeOne from 'memoize-one';\nimport { createElement, PureComponent } from 'react';\nimport { cancelTimeout, requestTimeout } from './timer';\nimport { getRTLOffsetType } from './domHelpers';\n\nimport type { TimeoutID } from './timer';\n\nexport type ScrollToAlign = 'auto' | 'smart' | 'center' | 'start' | 'end';\n\ntype itemSize = number | ((index: number) => number);\n// TODO Deprecate directions \"horizontal\" and \"vertical\"\ntype Direction = 'ltr' | 'rtl' | 'horizontal' | 'vertical';\ntype Layout = 'horizontal' | 'vertical';\n\ntype RenderComponentProps<T> = {|\n  data: T,\n  index: number,\n  isScrolling?: boolean,\n  style: Object,\n|};\ntype RenderComponent<T> = React$ComponentType<$Shape<RenderComponentProps<T>>>;\n\ntype ScrollDirection = 'forward' | 'backward';\n\ntype onItemsRenderedCallback = ({\n  overscanStartIndex: number,\n  overscanStopIndex: number,\n  visibleStartIndex: number,\n  visibleStopIndex: number,\n}) => void;\ntype onScrollCallback = ({\n  scrollDirection: ScrollDirection,\n  scrollOffset: number,\n  scrollUpdateWasRequested: boolean,\n}) => void;\n\ntype ScrollEvent = SyntheticEvent<HTMLDivElement>;\ntype ItemStyleCache = { [index: number]: Object };\n\ntype OuterProps = {|\n  children: React$Node,\n  className: string | void,\n  onScroll: ScrollEvent => void,\n  style: {\n    [string]: mixed,\n  },\n|};\n\ntype InnerProps = {|\n  children: React$Node,\n  style: {\n    [string]: mixed,\n  },\n|};\n\nexport type Props<T> = {|\n  children: RenderComponent<T>,\n  className?: string,\n  direction: Direction,\n  height: number | string,\n  initialScrollOffset?: number,\n  innerRef?: any,\n  innerElementType?: string | React$AbstractComponent<InnerProps, any>,\n  innerTagName?: string, // deprecated\n  itemCount: number,\n  itemData: T,\n  itemKey?: (index: number, data: T) => any,\n  itemSize: itemSize,\n  layout: Layout,\n  onItemsRendered?: onItemsRenderedCallback,\n  onScroll?: onScrollCallback,\n  outerRef?: any,\n  outerElementType?: string | React$AbstractComponent<OuterProps, any>,\n  outerTagName?: string, // deprecated\n  overscanCount: number,\n  style?: Object,\n  useIsScrolling: boolean,\n  width: number | string,\n|};\n\ntype State = {|\n  instance: any,\n  isScrolling: boolean,\n  scrollDirection: ScrollDirection,\n  scrollOffset: number,\n  scrollUpdateWasRequested: boolean,\n|};\n\ntype GetItemOffset = (\n  props: Props<any>,\n  index: number,\n  instanceProps: any\n) => number;\ntype GetItemSize = (\n  props: Props<any>,\n  index: number,\n  instanceProps: any\n) => number;\ntype GetEstimatedTotalSize = (props: Props<any>, instanceProps: any) => number;\ntype GetOffsetForIndexAndAlignment = (\n  props: Props<any>,\n  index: number,\n  align: ScrollToAlign,\n  scrollOffset: number,\n  instanceProps: any\n) => number;\ntype GetStartIndexForOffset = (\n  props: Props<any>,\n  offset: number,\n  instanceProps: any\n) => number;\ntype GetStopIndexForStartIndex = (\n  props: Props<any>,\n  startIndex: number,\n  scrollOffset: number,\n  instanceProps: any\n) => number;\ntype InitInstanceProps = (props: Props<any>, instance: any) => any;\ntype ValidateProps = (props: Props<any>) => void;\n\nconst IS_SCROLLING_DEBOUNCE_INTERVAL = 150;\n\nconst defaultItemKey = (index: number, data: any) => index;\n\n// In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\nlet devWarningsDirection = null;\nlet devWarningsTagName = null;\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsDirection = new WeakSet();\n    devWarningsTagName = new WeakSet();\n  }\n}\n\nexport default function createListComponent({\n  getItemOffset,\n  getEstimatedTotalSize,\n  getItemSize,\n  getOffsetForIndexAndAlignment,\n  getStartIndexForOffset,\n  getStopIndexForStartIndex,\n  initInstanceProps,\n  shouldResetStyleCacheOnItemSizeChange,\n  validateProps,\n}: {|\n  getItemOffset: GetItemOffset,\n  getEstimatedTotalSize: GetEstimatedTotalSize,\n  getItemSize: GetItemSize,\n  getOffsetForIndexAndAlignment: GetOffsetForIndexAndAlignment,\n  getStartIndexForOffset: GetStartIndexForOffset,\n  getStopIndexForStartIndex: GetStopIndexForStartIndex,\n  initInstanceProps: InitInstanceProps,\n  shouldResetStyleCacheOnItemSizeChange: boolean,\n  validateProps: ValidateProps,\n|}) {\n  return class List<T> extends PureComponent<Props<T>, State> {\n    _instanceProps: any = initInstanceProps(this.props, this);\n    _outerRef: ?HTMLDivElement;\n    _resetIsScrollingTimeoutId: TimeoutID | null = null;\n\n    static defaultProps = {\n      direction: 'ltr',\n      itemData: undefined,\n      layout: 'vertical',\n      overscanCount: 2,\n      useIsScrolling: false,\n    };\n\n    state: State = {\n      instance: this,\n      isScrolling: false,\n      scrollDirection: 'forward',\n      scrollOffset:\n        typeof this.props.initialScrollOffset === 'number'\n          ? this.props.initialScrollOffset\n          : 0,\n      scrollUpdateWasRequested: false,\n    };\n\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    constructor(props: Props<T>) {\n      super(props);\n    }\n\n    static getDerivedStateFromProps(\n      nextProps: Props<T>,\n      prevState: State\n    ): $Shape<State> | null {\n      validateSharedProps(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    }\n\n    scrollTo(scrollOffset: number): void {\n      scrollOffset = Math.max(0, scrollOffset);\n\n      this.setState(prevState => {\n        if (prevState.scrollOffset === scrollOffset) {\n          return null;\n        }\n        return {\n          scrollDirection:\n            prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n          scrollOffset: scrollOffset,\n          scrollUpdateWasRequested: true,\n        };\n      }, this._resetIsScrollingDebounced);\n    }\n\n    scrollToItem(index: number, align: ScrollToAlign = 'auto'): void {\n      const { itemCount } = this.props;\n      const { scrollOffset } = this.state;\n\n      index = Math.max(0, Math.min(index, itemCount - 1));\n\n      this.scrollTo(\n        getOffsetForIndexAndAlignment(\n          this.props,\n          index,\n          align,\n          scrollOffset,\n          this._instanceProps\n        )\n      );\n    }\n\n    componentDidMount() {\n      const { direction, initialScrollOffset, layout } = this.props;\n\n      if (typeof initialScrollOffset === 'number' && this._outerRef != null) {\n        const outerRef = ((this._outerRef: any): HTMLElement);\n        // TODO Deprecate direction \"horizontal\"\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          outerRef.scrollLeft = initialScrollOffset;\n        } else {\n          outerRef.scrollTop = initialScrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    }\n\n    componentDidUpdate() {\n      const { direction, layout } = this.props;\n      const { scrollOffset, scrollUpdateWasRequested } = this.state;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        const outerRef = ((this._outerRef: any): HTMLElement);\n\n        // TODO Deprecate direction \"horizontal\"\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          if (direction === 'rtl') {\n            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n            // So we need to determine which browser behavior we're dealing with, and mimic it.\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                outerRef.scrollLeft = -scrollOffset;\n                break;\n              case 'positive-ascending':\n                outerRef.scrollLeft = scrollOffset;\n                break;\n              default:\n                const { clientWidth, scrollWidth } = outerRef;\n                outerRef.scrollLeft = scrollWidth - clientWidth - scrollOffset;\n                break;\n            }\n          } else {\n            outerRef.scrollLeft = scrollOffset;\n          }\n        } else {\n          outerRef.scrollTop = scrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    }\n\n    componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    }\n\n    render() {\n      const {\n        children,\n        className,\n        direction,\n        height,\n        innerRef,\n        innerElementType,\n        innerTagName,\n        itemCount,\n        itemData,\n        itemKey = defaultItemKey,\n        layout,\n        outerElementType,\n        outerTagName,\n        style,\n        useIsScrolling,\n        width,\n      } = this.props;\n      const { isScrolling } = this.state;\n\n      // TODO Deprecate direction \"horizontal\"\n      const isHorizontal =\n        direction === 'horizontal' || layout === 'horizontal';\n\n      const onScroll = isHorizontal\n        ? this._onScrollHorizontal\n        : this._onScrollVertical;\n\n      const [startIndex, stopIndex] = this._getRangeToRender();\n\n      const items = [];\n      if (itemCount > 0) {\n        for (let index = startIndex; index <= stopIndex; index++) {\n          items.push(\n            createElement(children, {\n              data: itemData,\n              key: itemKey(index, itemData),\n              index,\n              isScrolling: useIsScrolling ? isScrolling : undefined,\n              style: this._getItemStyle(index),\n            })\n          );\n        }\n      }\n\n      // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n      const estimatedTotalSize = getEstimatedTotalSize(\n        this.props,\n        this._instanceProps\n      );\n\n      return createElement(\n        outerElementType || outerTagName || 'div',\n        {\n          className,\n          onScroll,\n          ref: this._outerRefSetter,\n          style: {\n            position: 'relative',\n            height,\n            width,\n            overflow: 'auto',\n            WebkitOverflowScrolling: 'touch',\n            willChange: 'transform',\n            direction,\n            ...style,\n          },\n        },\n        createElement(innerElementType || innerTagName || 'div', {\n          children: items,\n          ref: innerRef,\n          style: {\n            height: isHorizontal ? '100%' : estimatedTotalSize,\n            pointerEvents: isScrolling ? 'none' : undefined,\n            width: isHorizontal ? estimatedTotalSize : '100%',\n          },\n        })\n      );\n    }\n\n    _callOnItemsRendered: (\n      overscanStartIndex: number,\n      overscanStopIndex: number,\n      visibleStartIndex: number,\n      visibleStopIndex: number\n    ) => void;\n    _callOnItemsRendered = memoizeOne(\n      (\n        overscanStartIndex: number,\n        overscanStopIndex: number,\n        visibleStartIndex: number,\n        visibleStopIndex: number\n      ) =>\n        ((this.props.onItemsRendered: any): onItemsRenderedCallback)({\n          overscanStartIndex,\n          overscanStopIndex,\n          visibleStartIndex,\n          visibleStopIndex,\n        })\n    );\n\n    _callOnScroll: (\n      scrollDirection: ScrollDirection,\n      scrollOffset: number,\n      scrollUpdateWasRequested: boolean\n    ) => void;\n    _callOnScroll = memoizeOne(\n      (\n        scrollDirection: ScrollDirection,\n        scrollOffset: number,\n        scrollUpdateWasRequested: boolean\n      ) =>\n        ((this.props.onScroll: any): onScrollCallback)({\n          scrollDirection,\n          scrollOffset,\n          scrollUpdateWasRequested,\n        })\n    );\n\n    _callPropsCallbacks() {\n      if (typeof this.props.onItemsRendered === 'function') {\n        const { itemCount } = this.props;\n        if (itemCount > 0) {\n          const [\n            overscanStartIndex,\n            overscanStopIndex,\n            visibleStartIndex,\n            visibleStopIndex,\n          ] = this._getRangeToRender();\n          this._callOnItemsRendered(\n            overscanStartIndex,\n            overscanStopIndex,\n            visibleStartIndex,\n            visibleStopIndex\n          );\n        }\n      }\n\n      if (typeof this.props.onScroll === 'function') {\n        const {\n          scrollDirection,\n          scrollOffset,\n          scrollUpdateWasRequested,\n        } = this.state;\n        this._callOnScroll(\n          scrollDirection,\n          scrollOffset,\n          scrollUpdateWasRequested\n        );\n      }\n    }\n\n    // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n    _getItemStyle: (index: number) => Object;\n    _getItemStyle = (index: number): Object => {\n      const { direction, itemSize, layout } = this.props;\n\n      const itemStyleCache = this._getItemStyleCache(\n        shouldResetStyleCacheOnItemSizeChange && itemSize,\n        shouldResetStyleCacheOnItemSizeChange && layout,\n        shouldResetStyleCacheOnItemSizeChange && direction\n      );\n\n      let style;\n      if (itemStyleCache.hasOwnProperty(index)) {\n        style = itemStyleCache[index];\n      } else {\n        const offset = getItemOffset(this.props, index, this._instanceProps);\n        const size = getItemSize(this.props, index, this._instanceProps);\n\n        // TODO Deprecate direction \"horizontal\"\n        const isHorizontal =\n          direction === 'horizontal' || layout === 'horizontal';\n\n        const isRtl = direction === 'rtl';\n        const offsetHorizontal = isHorizontal ? offset : 0;\n        itemStyleCache[index] = style = {\n          position: 'absolute',\n          left: isRtl ? undefined : offsetHorizontal,\n          right: isRtl ? offsetHorizontal : undefined,\n          top: !isHorizontal ? offset : 0,\n          height: !isHorizontal ? size : '100%',\n          width: isHorizontal ? size : '100%',\n        };\n      }\n\n      return style;\n    };\n\n    _getItemStyleCache: (_: any, __: any, ___: any) => ItemStyleCache;\n    _getItemStyleCache = memoizeOne((_: any, __: any, ___: any) => ({}));\n\n    _getRangeToRender(): [number, number, number, number] {\n      const { itemCount, overscanCount } = this.props;\n      const { isScrolling, scrollDirection, scrollOffset } = this.state;\n\n      if (itemCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      const startIndex = getStartIndexForOffset(\n        this.props,\n        scrollOffset,\n        this._instanceProps\n      );\n      const stopIndex = getStopIndexForStartIndex(\n        this.props,\n        startIndex,\n        scrollOffset,\n        this._instanceProps\n      );\n\n      // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n      const overscanBackward =\n        !isScrolling || scrollDirection === 'backward'\n          ? Math.max(1, overscanCount)\n          : 1;\n      const overscanForward =\n        !isScrolling || scrollDirection === 'forward'\n          ? Math.max(1, overscanCount)\n          : 1;\n\n      return [\n        Math.max(0, startIndex - overscanBackward),\n        Math.max(0, Math.min(itemCount - 1, stopIndex + overscanForward)),\n        startIndex,\n        stopIndex,\n      ];\n    }\n\n    _onScrollHorizontal = (event: ScrollEvent): void => {\n      const { clientWidth, scrollLeft, scrollWidth } = event.currentTarget;\n      this.setState(prevState => {\n        if (prevState.scrollOffset === scrollLeft) {\n          // Scroll position may have been updated by cDM/cDU,\n          // In which case we don't need to trigger another render,\n          // And we don't want to update state.isScrolling.\n          return null;\n        }\n\n        const { direction } = this.props;\n\n        let scrollOffset = scrollLeft;\n        if (direction === 'rtl') {\n          // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n          // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n          // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n          // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n          switch (getRTLOffsetType()) {\n            case 'negative':\n              scrollOffset = -scrollLeft;\n              break;\n            case 'positive-descending':\n              scrollOffset = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        }\n\n        // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n        scrollOffset = Math.max(\n          0,\n          Math.min(scrollOffset, scrollWidth - clientWidth)\n        );\n\n        return {\n          isScrolling: true,\n          scrollDirection:\n            prevState.scrollOffset < scrollLeft ? 'forward' : 'backward',\n          scrollOffset,\n          scrollUpdateWasRequested: false,\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _onScrollVertical = (event: ScrollEvent): void => {\n      const { clientHeight, scrollHeight, scrollTop } = event.currentTarget;\n      this.setState(prevState => {\n        if (prevState.scrollOffset === scrollTop) {\n          // Scroll position may have been updated by cDM/cDU,\n          // In which case we don't need to trigger another render,\n          // And we don't want to update state.isScrolling.\n          return null;\n        }\n\n        // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n        const scrollOffset = Math.max(\n          0,\n          Math.min(scrollTop, scrollHeight - clientHeight)\n        );\n\n        return {\n          isScrolling: true,\n          scrollDirection:\n            prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n          scrollOffset,\n          scrollUpdateWasRequested: false,\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _outerRefSetter = (ref: any): void => {\n      const { outerRef } = this.props;\n\n      this._outerRef = ((ref: any): HTMLDivElement);\n\n      if (typeof outerRef === 'function') {\n        outerRef(ref);\n      } else if (\n        outerRef != null &&\n        typeof outerRef === 'object' &&\n        outerRef.hasOwnProperty('current')\n      ) {\n        outerRef.current = ref;\n      }\n    };\n\n    _resetIsScrollingDebounced = () => {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n\n      this._resetIsScrollingTimeoutId = requestTimeout(\n        this._resetIsScrolling,\n        IS_SCROLLING_DEBOUNCE_INTERVAL\n      );\n    };\n\n    _resetIsScrolling = () => {\n      this._resetIsScrollingTimeoutId = null;\n\n      this.setState({ isScrolling: false }, () => {\n        // Clear style cache after state update has been committed.\n        // This way we don't break pure sCU for items that don't use isScrolling param.\n        this._getItemStyleCache(-1, null);\n      });\n    };\n  };\n}\n\n// NOTE: I considered further wrapping individual items with a pure ListItem component.\n// This would avoid ever calling the render function for the same index more than once,\n// But it would also add the overhead of a lot of components/fibers.\n// I assume people already do this (render function returning a class component),\n// So my doing it would just unnecessarily double the wrappers.\n\nconst validateSharedProps = (\n  {\n    children,\n    direction,\n    height,\n    layout,\n    innerTagName,\n    outerTagName,\n    width,\n  }: Props<any>,\n  { instance }: State\n): void => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName && !devWarningsTagName.has(instance)) {\n        devWarningsTagName.add(instance);\n        console.warn(\n          'The innerTagName and outerTagName props have been deprecated. ' +\n            'Please use the innerElementType and outerElementType props instead.'\n        );\n      }\n    }\n\n    // TODO Deprecate direction \"horizontal\"\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n\n    switch (direction) {\n      case 'horizontal':\n      case 'vertical':\n        if (devWarningsDirection && !devWarningsDirection.has(instance)) {\n          devWarningsDirection.add(instance);\n          console.warn(\n            'The direction prop should be either \"ltr\" (default) or \"rtl\". ' +\n              'Please use the layout prop to specify \"vertical\" (default) or \"horizontal\" orientation.'\n          );\n        }\n        break;\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n      default:\n        throw Error(\n          'An invalid \"direction\" prop has been specified. ' +\n            'Value should be either \"ltr\" or \"rtl\". ' +\n            `\"${direction}\" was specified.`\n        );\n    }\n\n    switch (layout) {\n      case 'horizontal':\n      case 'vertical':\n        // Valid values\n        break;\n      default:\n        throw Error(\n          'An invalid \"layout\" prop has been specified. ' +\n            'Value should be either \"horizontal\" or \"vertical\". ' +\n            `\"${layout}\" was specified.`\n        );\n    }\n\n    if (children == null) {\n      throw Error(\n        'An invalid \"children\" prop has been specified. ' +\n          'Value should be a React component. ' +\n          `\"${children === null ? 'null' : typeof children}\" was specified.`\n      );\n    }\n\n    if (isHorizontal && typeof width !== 'number') {\n      throw Error(\n        'An invalid \"width\" prop has been specified. ' +\n          'Horizontal lists must specify a number for width. ' +\n          `\"${width === null ? 'null' : typeof width}\" was specified.`\n      );\n    } else if (!isHorizontal && typeof height !== 'number') {\n      throw Error(\n        'An invalid \"height\" prop has been specified. ' +\n          'Vertical lists must specify a number for height. ' +\n          `\"${height === null ? 'null' : typeof height}\" was specified.`\n      );\n    }\n  }\n};\n","// @flow\n\nimport createListComponent from './createListComponent';\n\nimport type { Props, ScrollToAlign } from './createListComponent';\n\nconst DEFAULT_ESTIMATED_ITEM_SIZE = 50;\n\ntype VariableSizeProps = {|\n  estimatedItemSize: number,\n  ...Props<any>,\n|};\n\ntype itemSizeGetter = (index: number) => number;\n\ntype ItemMetadata = {|\n  offset: number,\n  size: number,\n|};\ntype InstanceProps = {|\n  itemMetadataMap: { [index: number]: ItemMetadata },\n  estimatedItemSize: number,\n  lastMeasuredIndex: number,\n|};\n\nconst getItemMetadata = (\n  props: Props<any>,\n  index: number,\n  instanceProps: InstanceProps\n): ItemMetadata => {\n  const { itemSize } = ((props: any): VariableSizeProps);\n  const { itemMetadataMap, lastMeasuredIndex } = instanceProps;\n\n  if (index > lastMeasuredIndex) {\n    let offset = 0;\n    if (lastMeasuredIndex >= 0) {\n      const itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (let i = lastMeasuredIndex + 1; i <= index; i++) {\n      let size = ((itemSize: any): itemSizeGetter)(i);\n\n      itemMetadataMap[i] = {\n        offset,\n        size,\n      };\n\n      offset += size;\n    }\n\n    instanceProps.lastMeasuredIndex = index;\n  }\n\n  return itemMetadataMap[index];\n};\n\nconst findNearestItem = (\n  props: Props<any>,\n  instanceProps: InstanceProps,\n  offset: number\n) => {\n  const { itemMetadataMap, lastMeasuredIndex } = instanceProps;\n\n  const lastMeasuredItemOffset =\n    lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch(\n      props,\n      instanceProps,\n      lastMeasuredIndex,\n      0,\n      offset\n    );\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch(\n      props,\n      instanceProps,\n      Math.max(0, lastMeasuredIndex),\n      offset\n    );\n  }\n};\n\nconst findNearestItemBinarySearch = (\n  props: Props<any>,\n  instanceProps: InstanceProps,\n  high: number,\n  low: number,\n  offset: number\n): number => {\n  while (low <= high) {\n    const middle = low + Math.floor((high - low) / 2);\n    const currentOffset = getItemMetadata(props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nconst findNearestItemExponentialSearch = (\n  props: Props<any>,\n  instanceProps: InstanceProps,\n  index: number,\n  offset: number\n): number => {\n  const { itemCount } = props;\n  let interval = 1;\n\n  while (\n    index < itemCount &&\n    getItemMetadata(props, index, instanceProps).offset < offset\n  ) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch(\n    props,\n    instanceProps,\n    Math.min(index, itemCount - 1),\n    Math.floor(index / 2),\n    offset\n  );\n};\n\nconst getEstimatedTotalSize = (\n  { itemCount }: Props<any>,\n  { itemMetadataMap, estimatedItemSize, lastMeasuredIndex }: InstanceProps\n) => {\n  let totalSizeOfMeasuredItems = 0;\n\n  // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n  if (lastMeasuredIndex >= itemCount) {\n    lastMeasuredIndex = itemCount - 1;\n  }\n\n  if (lastMeasuredIndex >= 0) {\n    const itemMetadata = itemMetadataMap[lastMeasuredIndex];\n    totalSizeOfMeasuredItems = itemMetadata.offset + itemMetadata.size;\n  }\n\n  const numUnmeasuredItems = itemCount - lastMeasuredIndex - 1;\n  const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;\n\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;\n};\n\nconst VariableSizeList = createListComponent({\n  getItemOffset: (\n    props: Props<any>,\n    index: number,\n    instanceProps: InstanceProps\n  ): number => getItemMetadata(props, index, instanceProps).offset,\n\n  getItemSize: (\n    props: Props<any>,\n    index: number,\n    instanceProps: InstanceProps\n  ): number => instanceProps.itemMetadataMap[index].size,\n\n  getEstimatedTotalSize,\n\n  getOffsetForIndexAndAlignment: (\n    props: Props<any>,\n    index: number,\n    align: ScrollToAlign,\n    scrollOffset: number,\n    instanceProps: InstanceProps\n  ): number => {\n    const { direction, height, layout, width } = props;\n\n    // TODO Deprecate direction \"horizontal\"\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    const size = (((isHorizontal ? width : height): any): number);\n    const itemMetadata = getItemMetadata(props, index, instanceProps);\n\n    // Get estimated total size after ItemMetadata is computed,\n    // To ensure it reflects actual measurements instead of just estimates.\n    const estimatedTotalSize = getEstimatedTotalSize(props, instanceProps);\n\n    const maxOffset = Math.max(\n      0,\n      Math.min(estimatedTotalSize - size, itemMetadata.offset)\n    );\n    const minOffset = Math.max(\n      0,\n      itemMetadata.offset - size + itemMetadata.size\n    );\n\n    if (align === 'smart') {\n      if (\n        scrollOffset >= minOffset - size &&\n        scrollOffset <= maxOffset + size\n      ) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n      case 'end':\n        return minOffset;\n      case 'center':\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n    }\n  },\n\n  getStartIndexForOffset: (\n    props: Props<any>,\n    offset: number,\n    instanceProps: InstanceProps\n  ): number => findNearestItem(props, instanceProps, offset),\n\n  getStopIndexForStartIndex: (\n    props: Props<any>,\n    startIndex: number,\n    scrollOffset: number,\n    instanceProps: InstanceProps\n  ): number => {\n    const { direction, height, itemCount, layout, width } = props;\n\n    // TODO Deprecate direction \"horizontal\"\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    const size = (((isHorizontal ? width : height): any): number);\n    const itemMetadata = getItemMetadata(props, startIndex, instanceProps);\n    const maxOffset = scrollOffset + size;\n\n    let offset = itemMetadata.offset + itemMetadata.size;\n    let stopIndex = startIndex;\n\n    while (stopIndex < itemCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata(props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n\n  initInstanceProps(props: Props<any>, instance: any): InstanceProps {\n    const { estimatedItemSize } = ((props: any): VariableSizeProps);\n\n    const instanceProps = {\n      itemMetadataMap: {},\n      estimatedItemSize: estimatedItemSize || DEFAULT_ESTIMATED_ITEM_SIZE,\n      lastMeasuredIndex: -1,\n    };\n\n    instance.resetAfterIndex = (\n      index: number,\n      shouldForceUpdate?: boolean = true\n    ) => {\n      instanceProps.lastMeasuredIndex = Math.min(\n        instanceProps.lastMeasuredIndex,\n        index - 1\n      );\n\n      // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n\n  shouldResetStyleCacheOnItemSizeChange: false,\n\n  validateProps: ({ itemSize }: Props<any>): void => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'function') {\n        throw Error(\n          'An invalid \"itemSize\" prop has been specified. ' +\n            'Value should be a function. ' +\n            `\"${itemSize === null ? 'null' : typeof itemSize}\" was specified.`\n        );\n      }\n    }\n  },\n});\n\nexport default VariableSizeList;\n","// @flow\n\nimport createGridComponent from './createGridComponent';\n\nimport type { Props, ScrollToAlign } from './createGridComponent';\n\nconst FixedSizeGrid = createGridComponent({\n  getColumnOffset: ({ columnWidth }: Props<any>, index: number): number =>\n    index * ((columnWidth: any): number),\n\n  getColumnWidth: ({ columnWidth }: Props<any>, index: number): number =>\n    ((columnWidth: any): number),\n\n  getRowOffset: ({ rowHeight }: Props<any>, index: number): number =>\n    index * ((rowHeight: any): number),\n\n  getRowHeight: ({ rowHeight }: Props<any>, index: number): number =>\n    ((rowHeight: any): number),\n\n  getEstimatedTotalHeight: ({ rowCount, rowHeight }: Props<any>) =>\n    ((rowHeight: any): number) * rowCount,\n\n  getEstimatedTotalWidth: ({ columnCount, columnWidth }: Props<any>) =>\n    ((columnWidth: any): number) * columnCount,\n\n  getOffsetForColumnAndAlignment: (\n    { columnCount, columnWidth, width }: Props<any>,\n    columnIndex: number,\n    align: ScrollToAlign,\n    scrollLeft: number,\n    instanceProps: typeof undefined,\n    scrollbarSize: number\n  ): number => {\n    const lastColumnOffset = Math.max(\n      0,\n      columnCount * ((columnWidth: any): number) - width\n    );\n    const maxOffset = Math.min(\n      lastColumnOffset,\n      columnIndex * ((columnWidth: any): number)\n    );\n    const minOffset = Math.max(\n      0,\n      columnIndex * ((columnWidth: any): number) -\n        width +\n        scrollbarSize +\n        ((columnWidth: any): number)\n    );\n\n    if (align === 'smart') {\n      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n      case 'end':\n        return minOffset;\n      case 'center':\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        const middleOffset = Math.round(\n          minOffset + (maxOffset - minOffset) / 2\n        );\n        if (middleOffset < Math.ceil(width / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {\n          return lastColumnOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n      case 'auto':\n      default:\n        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {\n          return scrollLeft;\n        } else if (minOffset > maxOffset) {\n          // Because we only take into account the scrollbar size when calculating minOffset\n          // this value can be larger than maxOffset when at the end of the list\n          return minOffset;\n        } else if (scrollLeft < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n    }\n  },\n\n  getOffsetForRowAndAlignment: (\n    { rowHeight, height, rowCount }: Props<any>,\n    rowIndex: number,\n    align: ScrollToAlign,\n    scrollTop: number,\n    instanceProps: typeof undefined,\n    scrollbarSize: number\n  ): number => {\n    const lastRowOffset = Math.max(\n      0,\n      rowCount * ((rowHeight: any): number) - height\n    );\n    const maxOffset = Math.min(\n      lastRowOffset,\n      rowIndex * ((rowHeight: any): number)\n    );\n    const minOffset = Math.max(\n      0,\n      rowIndex * ((rowHeight: any): number) -\n        height +\n        scrollbarSize +\n        ((rowHeight: any): number)\n    );\n\n    if (align === 'smart') {\n      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n      case 'end':\n        return minOffset;\n      case 'center':\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        const middleOffset = Math.round(\n          minOffset + (maxOffset - minOffset) / 2\n        );\n        if (middleOffset < Math.ceil(height / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {\n          return lastRowOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n      case 'auto':\n      default:\n        if (scrollTop >= minOffset && scrollTop <= maxOffset) {\n          return scrollTop;\n        } else if (minOffset > maxOffset) {\n          // Because we only take into account the scrollbar size when calculating minOffset\n          // this value can be larger than maxOffset when at the end of the list\n          return minOffset;\n        } else if (scrollTop < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n    }\n  },\n\n  getColumnStartIndexForOffset: (\n    { columnWidth, columnCount }: Props<any>,\n    scrollLeft: number\n  ): number =>\n    Math.max(\n      0,\n      Math.min(\n        columnCount - 1,\n        Math.floor(scrollLeft / ((columnWidth: any): number))\n      )\n    ),\n\n  getColumnStopIndexForStartIndex: (\n    { columnWidth, columnCount, width }: Props<any>,\n    startIndex: number,\n    scrollLeft: number\n  ): number => {\n    const left = startIndex * ((columnWidth: any): number);\n    const numVisibleColumns = Math.ceil(\n      (width + scrollLeft - left) / ((columnWidth: any): number)\n    );\n    return Math.max(\n      0,\n      Math.min(\n        columnCount - 1,\n        startIndex + numVisibleColumns - 1 // -1 is because stop index is inclusive\n      )\n    );\n  },\n\n  getRowStartIndexForOffset: (\n    { rowHeight, rowCount }: Props<any>,\n    scrollTop: number\n  ): number =>\n    Math.max(\n      0,\n      Math.min(rowCount - 1, Math.floor(scrollTop / ((rowHeight: any): number)))\n    ),\n\n  getRowStopIndexForStartIndex: (\n    { rowHeight, rowCount, height }: Props<any>,\n    startIndex: number,\n    scrollTop: number\n  ): number => {\n    const top = startIndex * ((rowHeight: any): number);\n    const numVisibleRows = Math.ceil(\n      (height + scrollTop - top) / ((rowHeight: any): number)\n    );\n    return Math.max(\n      0,\n      Math.min(\n        rowCount - 1,\n        startIndex + numVisibleRows - 1 // -1 is because stop index is inclusive\n      )\n    );\n  },\n\n  initInstanceProps(props: Props<any>): any {\n    // Noop\n  },\n\n  shouldResetStyleCacheOnItemSizeChange: true,\n\n  validateProps: ({ columnWidth, rowHeight }: Props<any>): void => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'number') {\n        throw Error(\n          'An invalid \"columnWidth\" prop has been specified. ' +\n            'Value should be a number. ' +\n            `\"${\n              columnWidth === null ? 'null' : typeof columnWidth\n            }\" was specified.`\n        );\n      }\n\n      if (typeof rowHeight !== 'number') {\n        throw Error(\n          'An invalid \"rowHeight\" prop has been specified. ' +\n            'Value should be a number. ' +\n            `\"${rowHeight === null ? 'null' : typeof rowHeight}\" was specified.`\n        );\n      }\n    }\n  },\n});\n\nexport default FixedSizeGrid;\n","// @flow\n\nimport createListComponent from './createListComponent';\n\nimport type { Props, ScrollToAlign } from './createListComponent';\n\nconst FixedSizeList = createListComponent({\n  getItemOffset: ({ itemSize }: Props<any>, index: number): number =>\n    index * ((itemSize: any): number),\n\n  getItemSize: ({ itemSize }: Props<any>, index: number): number =>\n    ((itemSize: any): number),\n\n  getEstimatedTotalSize: ({ itemCount, itemSize }: Props<any>) =>\n    ((itemSize: any): number) * itemCount,\n\n  getOffsetForIndexAndAlignment: (\n    { direction, height, itemCount, itemSize, layout, width }: Props<any>,\n    index: number,\n    align: ScrollToAlign,\n    scrollOffset: number\n  ): number => {\n    // TODO Deprecate direction \"horizontal\"\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    const size = (((isHorizontal ? width : height): any): number);\n    const lastItemOffset = Math.max(\n      0,\n      itemCount * ((itemSize: any): number) - size\n    );\n    const maxOffset = Math.min(\n      lastItemOffset,\n      index * ((itemSize: any): number)\n    );\n    const minOffset = Math.max(\n      0,\n      index * ((itemSize: any): number) - size + ((itemSize: any): number)\n    );\n\n    if (align === 'smart') {\n      if (\n        scrollOffset >= minOffset - size &&\n        scrollOffset <= maxOffset + size\n      ) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n      case 'end':\n        return minOffset;\n      case 'center': {\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        const middleOffset = Math.round(\n          minOffset + (maxOffset - minOffset) / 2\n        );\n        if (middleOffset < Math.ceil(size / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {\n          return lastItemOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n      }\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n    }\n  },\n\n  getStartIndexForOffset: (\n    { itemCount, itemSize }: Props<any>,\n    offset: number\n  ): number =>\n    Math.max(\n      0,\n      Math.min(itemCount - 1, Math.floor(offset / ((itemSize: any): number)))\n    ),\n\n  getStopIndexForStartIndex: (\n    { direction, height, itemCount, itemSize, layout, width }: Props<any>,\n    startIndex: number,\n    scrollOffset: number\n  ): number => {\n    // TODO Deprecate direction \"horizontal\"\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    const offset = startIndex * ((itemSize: any): number);\n    const size = (((isHorizontal ? width : height): any): number);\n    const numVisibleItems = Math.ceil(\n      (size + scrollOffset - offset) / ((itemSize: any): number)\n    );\n    return Math.max(\n      0,\n      Math.min(\n        itemCount - 1,\n        startIndex + numVisibleItems - 1 // -1 is because stop index is inclusive\n      )\n    );\n  },\n\n  initInstanceProps(props: Props<any>): any {\n    // Noop\n  },\n\n  shouldResetStyleCacheOnItemSizeChange: true,\n\n  validateProps: ({ itemSize }: Props<any>): void => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'number') {\n        throw Error(\n          'An invalid \"itemSize\" prop has been specified. ' +\n            'Value should be a number. ' +\n            `\"${itemSize === null ? 'null' : typeof itemSize}\" was specified.`\n        );\n      }\n    }\n  },\n});\n\nexport default FixedSizeList;\n","export default function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}","// @flow\n\n// Pulled from react-compat\n// https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349\nexport default function shallowDiffers(prev: Object, next: Object): boolean {\n  for (let attribute in prev) {\n    if (!(attribute in next)) {\n      return true;\n    }\n  }\n  for (let attribute in next) {\n    if (prev[attribute] !== next[attribute]) {\n      return true;\n    }\n  }\n  return false;\n}\n","// @flow\n\nimport shallowDiffers from './shallowDiffers';\n\n// Custom comparison function for React.memo().\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-api.html#reactmemo\nexport default function areEqual(\n  prevProps: Object,\n  nextProps: Object\n): boolean {\n  const { style: prevStyle, ...prevRest } = prevProps;\n  const { style: nextStyle, ...nextRest } = nextProps;\n\n  return (\n    !shallowDiffers(prevStyle, nextStyle) && !shallowDiffers(prevRest, nextRest)\n  );\n}\n","// @flow\n\nimport areEqual from './areEqual';\nimport shallowDiffers from './shallowDiffers';\n\n// Custom shouldComponentUpdate for class components.\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-component.html#shouldcomponentupdate\nexport default function shouldComponentUpdate(\n  nextProps: Object,\n  nextState: Object\n): boolean {\n  return (\n    !areEqual(this.props, nextProps) || shallowDiffers(this.state, nextState)\n  );\n}\n"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","this","_inheritsLoose","subClass","superClass","create","constructor","__proto__","_assertThisInitialized","self","ReferenceError","simpleIsEqual","newArgs","lastArgs","every","newArg","index","newValue","oldValue","resultFn","isEqual","lastThis","lastResult","calledOnce","_len","Array","_key","now","performance","Date","cancelTimeout","timeoutID","cancelAnimationFrame","id","requestTimeout","callback","delay","start","requestAnimationFrame","tick","size","cachedRTLResult","getRTLOffsetType","recalculate","outerDiv","document","createElement","outerStyle","style","width","height","overflow","direction","innerDiv","innerStyle","appendChild","body","scrollLeft","removeChild","IS_SCROLLING_DEBOUNCE_INTERVAL","defaultItemKey","columnIndex","data","rowIndex","createGridComponent","getColumnOffset","getColumnStartIndexForOffset","getColumnStopIndexForStartIndex","getColumnWidth","getEstimatedTotalHeight","getEstimatedTotalWidth","getOffsetForColumnAndAlignment","getOffsetForRowAndAlignment","getRowHeight","getRowOffset","getRowStartIndexForOffset","getRowStopIndexForStartIndex","initInstanceProps","shouldResetStyleCacheOnItemSizeChange","validateProps","props","_instanceProps","_this","_resetIsScrollingTimeoutId","_outerRef","state","instance","isScrolling","horizontalScrollDirection","initialScrollLeft","scrollTop","initialScrollTop","scrollUpdateWasRequested","verticalScrollDirection","_callOnItemsRendered","memoizeOne","overscanColumnStartIndex","overscanColumnStopIndex","overscanRowStartIndex","overscanRowStopIndex","visibleColumnStartIndex","visibleColumnStopIndex","visibleRowStartIndex","visibleRowStopIndex","onItemsRendered","_callOnScroll","onScroll","_getItemStyle","columnWidth","rowHeight","itemStyleCache","_getItemStyleCache","offset","isRtl","position","left","undefined","right","top","_","__","___","_onScroll","event","currentTarget","clientHeight","clientWidth","scrollHeight","scrollWidth","setState","prevState","calculatedScrollLeft","Math","max","min","calculatedScrollTop","_resetIsScrollingDebounced","_outerRefSetter","ref","outerRef","current","_resetIsScrolling","getDerivedStateFromProps","nextProps","validateSharedProps","scrollTo","scrollToItem","align","columnCount","rowCount","scrollbarSize","div","offsetWidth","getScrollbarSize","estimatedTotalHeight","horizontalScrollbarSize","verticalScrollbarSize","componentDidMount","_callPropsCallbacks","componentDidUpdate","componentWillUnmount","render","children","className","innerRef","innerElementType","innerTagName","itemData","itemKey","outerElementType","outerTagName","useIsScrolling","_getHorizontalRangeToRender","columnStartIndex","columnStopIndex","_getVerticalRangeToRender","rowStartIndex","rowStopIndex","items","push","estimatedTotalWidth","WebkitOverflowScrolling","willChange","pointerEvents","overscanColumnCount","overscanColumnsCount","overscanCount","overscanCountResolved","startIndex","stopIndex","overscanBackward","overscanForward","overscanRowCount","overscanRowsCount","PureComponent","defaultProps","rowMetadataMap","estimatedRowHeight","lastMeasuredRowIndex","totalSizeOfMeasuredRows","itemMetadata","columnMetadataMap","estimatedColumnWidth","lastMeasuredColumnIndex","getItemMetadata","itemType","instanceProps","itemMetadataMap","itemSize","lastMeasuredIndex","findNearestItem","findNearestItemBinarySearch","findNearestItemExponentialSearch","high","low","middle","floor","currentOffset","itemCount","interval","getOffsetForIndexAndAlignment","scrollOffset","estimatedTotalSize","maxOffset","minOffset","round","VariableSizeGrid","resetAfterColumnIndex","shouldForceUpdate","resetAfterIndices","resetAfterRowIndex","forceUpdate","createListComponent","getItemOffset","getEstimatedTotalSize","getItemSize","getStartIndexForOffset","getStopIndexForStartIndex","scrollDirection","initialScrollOffset","overscanStartIndex","overscanStopIndex","visibleStartIndex","visibleStopIndex","layout","isHorizontal","offsetHorizontal","_onScrollHorizontal","_onScrollVertical","_getRangeToRender","estimatedItemSize","totalSizeOfMeasuredItems","VariableSizeList","resetAfterIndex","FixedSizeGrid","lastColumnOffset","middleOffset","ceil","lastRowOffset","numVisibleColumns","numVisibleRows","FixedSizeList","lastItemOffset","numVisibleItems","_objectWithoutPropertiesLoose","excluded","sourceKeys","keys","indexOf","shallowDiffers","prev","next","attribute","areEqual","prevProps","prevStyle","prevRest","nextStyle","nextRest","nextState"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"index-prod.umd.js","sources":["../node_modules/@babel/runtime/helpers/esm/extends.js","../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","../node_modules/@babel/runtime/helpers/esm/inheritsLoose.js","../node_modules/memoize-one/dist/memoize-one.esm.js","../src/timer.js","../src/domHelpers.js","../src/createGridComponent.js","../src/VariableSizeGrid.js","../src/createListComponent.js","../src/VariableSizeList.js","../src/FixedSizeGrid.js","../src/FixedSizeList.js","../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js","../src/shallowDiffers.js","../src/areEqual.js","../src/shouldComponentUpdate.js"],"sourcesContent":["export default function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}","export default function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}","export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}","import setPrototypeOf from \"./setPrototypeOf.js\";\nexport default function _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  setPrototypeOf(subClass, superClass);\n}","var safeIsNaN = Number.isNaN ||\n    function ponyfill(value) {\n        return typeof value === 'number' && value !== value;\n    };\nfunction isEqual(first, second) {\n    if (first === second) {\n        return true;\n    }\n    if (safeIsNaN(first) && safeIsNaN(second)) {\n        return true;\n    }\n    return false;\n}\nfunction areInputsEqual(newInputs, lastInputs) {\n    if (newInputs.length !== lastInputs.length) {\n        return false;\n    }\n    for (var i = 0; i < newInputs.length; i++) {\n        if (!isEqual(newInputs[i], lastInputs[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction memoizeOne(resultFn, isEqual) {\n    if (isEqual === void 0) { isEqual = areInputsEqual; }\n    var lastThis;\n    var lastArgs = [];\n    var lastResult;\n    var calledOnce = false;\n    function memoized() {\n        var newArgs = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            newArgs[_i] = arguments[_i];\n        }\n        if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {\n            return lastResult;\n        }\n        lastResult = resultFn.apply(this, newArgs);\n        calledOnce = true;\n        lastThis = this;\n        lastArgs = newArgs;\n        return lastResult;\n    }\n    return memoized;\n}\n\nexport default memoizeOne;\n","// @flow\r\n\r\n// Animation frame based implementation of setTimeout.\r\n// Inspired by Joe Lambert, https://gist.github.com/joelambert/1002116#file-requesttimeout-js\r\n\r\nconst hasNativePerformanceNow =\r\n  typeof performance === 'object' && typeof performance.now === 'function';\r\n\r\nconst now = hasNativePerformanceNow\r\n  ? () => performance.now()\r\n  : () => Date.now();\r\n\r\nexport type TimeoutID = {|\r\n  id: AnimationFrameID,\r\n|};\r\n\r\nexport function cancelTimeout(timeoutID: TimeoutID) {\r\n  cancelAnimationFrame(timeoutID.id);\r\n}\r\n\r\nexport function requestTimeout(callback: Function, delay: number): TimeoutID {\r\n  const start = now();\r\n\r\n  function tick() {\r\n    if (now() - start >= delay) {\r\n      callback.call(null);\r\n    } else {\r\n      timeoutID.id = requestAnimationFrame(tick);\r\n    }\r\n  }\r\n\r\n  const timeoutID: TimeoutID = {\r\n    id: requestAnimationFrame(tick),\r\n  };\r\n\r\n  return timeoutID;\r\n}\r\n","// @flow\r\n\r\nlet size: number = -1;\r\n\r\n// This utility copied from \"dom-helpers\" package.\r\nexport function getScrollbarSize(recalculate?: boolean = false): number {\r\n  if (size === -1 || recalculate) {\r\n    const div = document.createElement('div');\r\n    const style = div.style;\r\n    style.width = '50px';\r\n    style.height = '50px';\r\n    style.overflow = 'scroll';\r\n\r\n    ((document.body: any): HTMLBodyElement).appendChild(div);\r\n\r\n    size = div.offsetWidth - div.clientWidth;\r\n\r\n    ((document.body: any): HTMLBodyElement).removeChild(div);\r\n  }\r\n\r\n  return size;\r\n}\r\n\r\nexport type RTLOffsetType =\r\n  | 'negative'\r\n  | 'positive-descending'\r\n  | 'positive-ascending';\r\n\r\nlet cachedRTLResult: RTLOffsetType | null = null;\r\n\r\n// TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\r\n// Chrome does not seem to adhere; its scrollLeft values are positive (measured relative to the left).\r\n// Safari's elastic bounce makes detecting this even more complicated wrt potential false positives.\r\n// The safest way to check this is to intentionally set a negative offset,\r\n// and then verify that the subsequent \"scroll\" event matches the negative offset.\r\n// If it does not match, then we can assume a non-standard RTL scroll implementation.\r\nexport function getRTLOffsetType(recalculate?: boolean = false): RTLOffsetType {\r\n  if (cachedRTLResult === null || recalculate) {\r\n    const outerDiv = document.createElement('div');\r\n    const outerStyle = outerDiv.style;\r\n    outerStyle.width = '50px';\r\n    outerStyle.height = '50px';\r\n    outerStyle.overflow = 'scroll';\r\n    outerStyle.direction = 'rtl';\r\n\r\n    const innerDiv = document.createElement('div');\r\n    const innerStyle = innerDiv.style;\r\n    innerStyle.width = '100px';\r\n    innerStyle.height = '100px';\r\n\r\n    outerDiv.appendChild(innerDiv);\r\n\r\n    ((document.body: any): HTMLBodyElement).appendChild(outerDiv);\r\n\r\n    if (outerDiv.scrollLeft > 0) {\r\n      cachedRTLResult = 'positive-descending';\r\n    } else {\r\n      outerDiv.scrollLeft = 1;\r\n      if (outerDiv.scrollLeft === 0) {\r\n        cachedRTLResult = 'negative';\r\n      } else {\r\n        cachedRTLResult = 'positive-ascending';\r\n      }\r\n    }\r\n\r\n    ((document.body: any): HTMLBodyElement).removeChild(outerDiv);\r\n\r\n    return cachedRTLResult;\r\n  }\r\n\r\n  return cachedRTLResult;\r\n}\r\n","// @flow\r\n\r\nimport memoizeOne from 'memoize-one';\r\nimport { createElement, PureComponent } from 'react';\r\nimport { cancelTimeout, requestTimeout } from './timer';\r\nimport { getScrollbarSize, getRTLOffsetType } from './domHelpers';\r\n\r\nimport type { TimeoutID } from './timer';\r\n\r\ntype Direction = 'ltr' | 'rtl';\r\nexport type ScrollToAlign = 'auto' | 'smart' | 'center' | 'start' | 'end';\r\n\r\ntype itemSize = number | ((index: number) => number);\r\n\r\ntype RenderComponentProps<T> = {|\r\n  columnIndex: number,\r\n  data: T,\r\n  isScrolling?: boolean,\r\n  rowIndex: number,\r\n  style: Object,\r\n|};\r\nexport type RenderComponent<T> = React$ComponentType<\r\n  $Shape<RenderComponentProps<T>>\r\n>;\r\n\r\ntype ScrollDirection = 'forward' | 'backward';\r\n\r\ntype OnItemsRenderedCallback = ({\r\n  overscanColumnStartIndex: number,\r\n  overscanColumnStopIndex: number,\r\n  overscanRowStartIndex: number,\r\n  overscanRowStopIndex: number,\r\n  visibleColumnStartIndex: number,\r\n  visibleColumnStopIndex: number,\r\n  visibleRowStartIndex: number,\r\n  visibleRowStopIndex: number,\r\n}) => void;\r\ntype OnScrollCallback = ({\r\n  horizontalScrollDirection: ScrollDirection,\r\n  scrollLeft: number,\r\n  scrollTop: number,\r\n  scrollUpdateWasRequested: boolean,\r\n  verticalScrollDirection: ScrollDirection,\r\n}) => void;\r\n\r\ntype ScrollEvent = SyntheticEvent<HTMLDivElement>;\r\ntype ItemStyleCache = { [key: string]: Object };\r\n\r\ntype OuterProps = {|\r\n  children: React$Node,\r\n  className: string | void,\r\n  onScroll: ScrollEvent => void,\r\n  style: {\r\n    [string]: mixed,\r\n  },\r\n|};\r\n\r\ntype InnerProps = {|\r\n  children: React$Node,\r\n  style: {\r\n    [string]: mixed,\r\n  },\r\n|};\r\n\r\nexport type Props<T> = {|\r\n  children: RenderComponent<T>,\r\n  className?: string,\r\n  columnCount: number,\r\n  columnWidth: itemSize,\r\n  direction: Direction,\r\n  height: number,\r\n  initialScrollLeft?: number,\r\n  initialScrollTop?: number,\r\n  innerRef?: any,\r\n  innerElementType?: string | React$AbstractComponent<InnerProps, any>,\r\n  innerTagName?: string, // deprecated\r\n  itemData: T,\r\n  itemKey?: (params: {|\r\n    columnIndex: number,\r\n    data: T,\r\n    rowIndex: number,\r\n  |}) => any,\r\n  onItemsRendered?: OnItemsRenderedCallback,\r\n  onScroll?: OnScrollCallback,\r\n  outerRef?: any,\r\n  outerElementType?: string | React$AbstractComponent<OuterProps, any>,\r\n  outerTagName?: string, // deprecated\r\n  overscanColumnCount?: number,\r\n  overscanColumnsCount?: number, // deprecated\r\n  overscanCount?: number, // deprecated\r\n  overscanRowCount?: number,\r\n  overscanRowsCount?: number, // deprecated\r\n  rowCount: number,\r\n  rowHeight: itemSize,\r\n  style?: Object,\r\n  useIsScrolling: boolean,\r\n  width: number,\r\n|};\r\n\r\ntype State = {|\r\n  instance: any,\r\n  isScrolling: boolean,\r\n  horizontalScrollDirection: ScrollDirection,\r\n  scrollLeft: number,\r\n  scrollTop: number,\r\n  scrollUpdateWasRequested: boolean,\r\n  verticalScrollDirection: ScrollDirection,\r\n|};\r\n\r\ntype getItemOffset = (\r\n  props: Props<any>,\r\n  index: number,\r\n  instanceProps: any\r\n) => number;\r\ntype getItemSize = (\r\n  props: Props<any>,\r\n  index: number,\r\n  instanceProps: any\r\n) => number;\r\ntype getEstimatedTotalSize = (props: Props<any>, instanceProps: any) => number;\r\ntype GetOffsetForItemAndAlignment = (\r\n  props: Props<any>,\r\n  index: number,\r\n  align: ScrollToAlign,\r\n  scrollOffset: number,\r\n  instanceProps: any,\r\n  scrollbarSize: number\r\n) => number;\r\ntype GetStartIndexForOffset = (\r\n  props: Props<any>,\r\n  offset: number,\r\n  instanceProps: any\r\n) => number;\r\ntype GetStopIndexForStartIndex = (\r\n  props: Props<any>,\r\n  startIndex: number,\r\n  scrollOffset: number,\r\n  instanceProps: any\r\n) => number;\r\ntype InitInstanceProps = (props: Props<any>, instance: any) => any;\r\ntype ValidateProps = (props: Props<any>) => void;\r\n\r\nconst IS_SCROLLING_DEBOUNCE_INTERVAL = 150;\r\n\r\nconst defaultItemKey = ({ columnIndex, data, rowIndex }) =>\r\n  `${rowIndex}:${columnIndex}`;\r\n\r\n// In DEV mode, this Set helps us only log a warning once per component instance.\r\n// This avoids spamming the console every time a render happens.\r\nlet devWarningsOverscanCount = null;\r\nlet devWarningsOverscanRowsColumnsCount = null;\r\nlet devWarningsTagName = null;\r\nif (process.env.NODE_ENV !== 'production') {\r\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\r\n    devWarningsOverscanCount = new WeakSet();\r\n    devWarningsOverscanRowsColumnsCount = new WeakSet();\r\n    devWarningsTagName = new WeakSet();\r\n  }\r\n}\r\n\r\nexport default function createGridComponent({\r\n  getColumnOffset,\r\n  getColumnStartIndexForOffset,\r\n  getColumnStopIndexForStartIndex,\r\n  getColumnWidth,\r\n  getEstimatedTotalHeight,\r\n  getEstimatedTotalWidth,\r\n  getOffsetForColumnAndAlignment,\r\n  getOffsetForRowAndAlignment,\r\n  getRowHeight,\r\n  getRowOffset,\r\n  getRowStartIndexForOffset,\r\n  getRowStopIndexForStartIndex,\r\n  initInstanceProps,\r\n  shouldResetStyleCacheOnItemSizeChange,\r\n  validateProps,\r\n}: {|\r\n  getColumnOffset: getItemOffset,\r\n  getColumnStartIndexForOffset: GetStartIndexForOffset,\r\n  getColumnStopIndexForStartIndex: GetStopIndexForStartIndex,\r\n  getColumnWidth: getItemSize,\r\n  getEstimatedTotalHeight: getEstimatedTotalSize,\r\n  getEstimatedTotalWidth: getEstimatedTotalSize,\r\n  getOffsetForColumnAndAlignment: GetOffsetForItemAndAlignment,\r\n  getOffsetForRowAndAlignment: GetOffsetForItemAndAlignment,\r\n  getRowOffset: getItemOffset,\r\n  getRowHeight: getItemSize,\r\n  getRowStartIndexForOffset: GetStartIndexForOffset,\r\n  getRowStopIndexForStartIndex: GetStopIndexForStartIndex,\r\n  initInstanceProps: InitInstanceProps,\r\n  shouldResetStyleCacheOnItemSizeChange: boolean,\r\n  validateProps: ValidateProps,\r\n|}) {\r\n  return class Grid<T> extends PureComponent<Props<T>, State> {\r\n    _instanceProps: any = initInstanceProps(this.props, this);\r\n    _resetIsScrollingTimeoutId: TimeoutID | null = null;\r\n    _outerRef: ?HTMLDivElement;\r\n\r\n    static defaultProps = {\r\n      direction: 'ltr',\r\n      itemData: undefined,\r\n      useIsScrolling: false,\r\n    };\r\n\r\n    state: State = {\r\n      instance: this,\r\n      isScrolling: false,\r\n      horizontalScrollDirection: 'forward',\r\n      scrollLeft:\r\n        typeof this.props.initialScrollLeft === 'number'\r\n          ? this.props.initialScrollLeft\r\n          : 0,\r\n      scrollTop:\r\n        typeof this.props.initialScrollTop === 'number'\r\n          ? this.props.initialScrollTop\r\n          : 0,\r\n      scrollUpdateWasRequested: false,\r\n      verticalScrollDirection: 'forward',\r\n    };\r\n\r\n    // Always use explicit constructor for React components.\r\n    // It produces less code after transpilation. (#26)\r\n    // eslint-disable-next-line no-useless-constructor\r\n    constructor(props: Props<T>) {\r\n      super(props);\r\n    }\r\n\r\n    static getDerivedStateFromProps(\r\n      nextProps: Props<T>,\r\n      prevState: State\r\n    ): $Shape<State> | null {\r\n      validateSharedProps(nextProps, prevState);\r\n      validateProps(nextProps);\r\n      return null;\r\n    }\r\n\r\n    scrollTo({\r\n      scrollLeft,\r\n      scrollTop,\r\n    }: {\r\n      scrollLeft: number,\r\n      scrollTop: number,\r\n    }): void {\r\n      if (scrollLeft !== undefined) {\r\n        scrollLeft = Math.max(0, scrollLeft);\r\n      }\r\n      if (scrollTop !== undefined) {\r\n        scrollTop = Math.max(0, scrollTop);\r\n      }\r\n\r\n      this.setState(prevState => {\r\n        if (scrollLeft === undefined) {\r\n          scrollLeft = prevState.scrollLeft;\r\n        }\r\n        if (scrollTop === undefined) {\r\n          scrollTop = prevState.scrollTop;\r\n        }\r\n\r\n        if (\r\n          prevState.scrollLeft === scrollLeft &&\r\n          prevState.scrollTop === scrollTop\r\n        ) {\r\n          return null;\r\n        }\r\n\r\n        return {\r\n          horizontalScrollDirection:\r\n            prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\r\n          scrollLeft: scrollLeft,\r\n          scrollTop: scrollTop,\r\n          scrollUpdateWasRequested: true,\r\n          verticalScrollDirection:\r\n            prevState.scrollTop < scrollTop ? 'forward' : 'backward',\r\n        };\r\n      }, this._resetIsScrollingDebounced);\r\n    }\r\n\r\n    scrollToItem({\r\n      align = 'auto',\r\n      columnIndex,\r\n      rowIndex,\r\n    }: {\r\n      align: ScrollToAlign,\r\n      columnIndex?: number,\r\n      rowIndex?: number,\r\n    }): void {\r\n      const { columnCount, height, rowCount, width } = this.props;\r\n      const { scrollLeft, scrollTop } = this.state;\r\n      const scrollbarSize = getScrollbarSize();\r\n\r\n      if (columnIndex !== undefined) {\r\n        columnIndex = Math.max(0, Math.min(columnIndex, columnCount - 1));\r\n      }\r\n      if (rowIndex !== undefined) {\r\n        rowIndex = Math.max(0, Math.min(rowIndex, rowCount - 1));\r\n      }\r\n\r\n      const estimatedTotalHeight = getEstimatedTotalHeight(\r\n        this.props,\r\n        this._instanceProps\r\n      );\r\n      const estimatedTotalWidth = getEstimatedTotalWidth(\r\n        this.props,\r\n        this._instanceProps\r\n      );\r\n\r\n      // The scrollbar size should be considered when scrolling an item into view,\r\n      // to ensure it's fully visible.\r\n      // But we only need to account for its size when it's actually visible.\r\n      const horizontalScrollbarSize =\r\n        estimatedTotalWidth > width ? scrollbarSize : 0;\r\n      const verticalScrollbarSize =\r\n        estimatedTotalHeight > height ? scrollbarSize : 0;\r\n\r\n      this.scrollTo({\r\n        scrollLeft:\r\n          columnIndex !== undefined\r\n            ? getOffsetForColumnAndAlignment(\r\n                this.props,\r\n                columnIndex,\r\n                align,\r\n                scrollLeft,\r\n                this._instanceProps,\r\n                verticalScrollbarSize\r\n              )\r\n            : scrollLeft,\r\n        scrollTop:\r\n          rowIndex !== undefined\r\n            ? getOffsetForRowAndAlignment(\r\n                this.props,\r\n                rowIndex,\r\n                align,\r\n                scrollTop,\r\n                this._instanceProps,\r\n                horizontalScrollbarSize\r\n              )\r\n            : scrollTop,\r\n      });\r\n    }\r\n\r\n    componentDidMount() {\r\n      const { initialScrollLeft, initialScrollTop } = this.props;\r\n\r\n      if (this._outerRef != null) {\r\n        const outerRef = ((this._outerRef: any): HTMLElement);\r\n        if (typeof initialScrollLeft === 'number') {\r\n          outerRef.scrollLeft = initialScrollLeft;\r\n        }\r\n        if (typeof initialScrollTop === 'number') {\r\n          outerRef.scrollTop = initialScrollTop;\r\n        }\r\n      }\r\n\r\n      this._callPropsCallbacks();\r\n    }\r\n\r\n    componentDidUpdate() {\r\n      const { direction } = this.props;\r\n      const { scrollLeft, scrollTop, scrollUpdateWasRequested } = this.state;\r\n\r\n      if (scrollUpdateWasRequested && this._outerRef != null) {\r\n        // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\r\n        // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\r\n        // So we need to determine which browser behavior we're dealing with, and mimic it.\r\n        const outerRef = ((this._outerRef: any): HTMLElement);\r\n        if (direction === 'rtl') {\r\n          switch (getRTLOffsetType()) {\r\n            case 'negative':\r\n              outerRef.scrollLeft = -scrollLeft;\r\n              break;\r\n            case 'positive-ascending':\r\n              outerRef.scrollLeft = scrollLeft;\r\n              break;\r\n            default:\r\n              const { clientWidth, scrollWidth } = outerRef;\r\n              outerRef.scrollLeft = scrollWidth - clientWidth - scrollLeft;\r\n              break;\r\n          }\r\n        } else {\r\n          outerRef.scrollLeft = Math.max(0, scrollLeft);\r\n        }\r\n\r\n        outerRef.scrollTop = Math.max(0, scrollTop);\r\n      }\r\n\r\n      this._callPropsCallbacks();\r\n    }\r\n\r\n    componentWillUnmount() {\r\n      if (this._resetIsScrollingTimeoutId !== null) {\r\n        cancelTimeout(this._resetIsScrollingTimeoutId);\r\n      }\r\n    }\r\n\r\n    render() {\r\n      const {\r\n        children,\r\n        className,\r\n        columnCount,\r\n        direction,\r\n        height,\r\n        innerRef,\r\n        innerElementType,\r\n        innerTagName,\r\n        itemData,\r\n        itemKey = defaultItemKey,\r\n        outerElementType,\r\n        outerTagName,\r\n        rowCount,\r\n        style,\r\n        useIsScrolling,\r\n        width,\r\n        disableColVirtualized,\r\n        disableRowVirtualized\r\n      } = this.props;\r\n      const { isScrolling } = this.state;\r\n\r\n      let [\r\n        columnStartIndex,\r\n        columnStopIndex,\r\n      ] = this._getHorizontalRangeToRender();\r\n      let [rowStartIndex, rowStopIndex] = this._getVerticalRangeToRender();\r\n\r\n      if(disableColVirtualized) columnStartIndex = 0;\r\n      if(disableRowVirtualized) rowStartIndex = 0;\r\n      \r\n      const items = [];\r\n      if (columnCount > 0 && rowCount) {\r\n        for (\r\n          let rowIndex = rowStartIndex;\r\n          rowIndex <= rowStopIndex;\r\n          rowIndex++\r\n        ) {\r\n          for (\r\n            let columnIndex = columnStartIndex;\r\n            columnIndex <= columnStopIndex;\r\n            columnIndex++\r\n          ) {\r\n            items.push(\r\n              createElement(children, {\r\n                columnIndex,\r\n                data: itemData,\r\n                isScrolling: useIsScrolling ? isScrolling : undefined,\r\n                key: itemKey({ columnIndex, data: itemData, rowIndex }),\r\n                rowIndex,\r\n                style: this._getItemStyle(rowIndex, columnIndex),\r\n              })\r\n            );\r\n          }\r\n        }\r\n      }\r\n\r\n      // Read this value AFTER items have been created,\r\n      // So their actual sizes (if variable) are taken into consideration.\r\n      const estimatedTotalHeight = getEstimatedTotalHeight(\r\n        this.props,\r\n        this._instanceProps\r\n      );\r\n      const estimatedTotalWidth = getEstimatedTotalWidth(\r\n        this.props,\r\n        this._instanceProps\r\n      );\r\n\r\n      return createElement(\r\n        outerElementType || outerTagName || 'div',\r\n        {\r\n          className,\r\n          onScroll: this._onScroll,\r\n          ref: this._outerRefSetter,\r\n          style: {\r\n            position: 'relative',\r\n            height,\r\n            width,\r\n            overflow: 'auto',\r\n            WebkitOverflowScrolling: 'touch',\r\n            willChange: 'transform',\r\n            direction,\r\n            ...style,\r\n          },\r\n        },\r\n        createElement(innerElementType || innerTagName || 'div', {\r\n          children: items,\r\n          ref: innerRef,\r\n          style: {\r\n            height: estimatedTotalHeight,\r\n            pointerEvents: isScrolling ? 'none' : undefined,\r\n            width: estimatedTotalWidth,\r\n          },\r\n        })\r\n      );\r\n    }\r\n\r\n    _callOnItemsRendered: (\r\n      overscanColumnStartIndex: number,\r\n      overscanColumnStopIndex: number,\r\n      overscanRowStartIndex: number,\r\n      overscanRowStopIndex: number,\r\n      visibleColumnStartIndex: number,\r\n      visibleColumnStopIndex: number,\r\n      visibleRowStartIndex: number,\r\n      visibleRowStopIndex: number\r\n    ) => void;\r\n    _callOnItemsRendered = memoizeOne(\r\n      (\r\n        overscanColumnStartIndex: number,\r\n        overscanColumnStopIndex: number,\r\n        overscanRowStartIndex: number,\r\n        overscanRowStopIndex: number,\r\n        visibleColumnStartIndex: number,\r\n        visibleColumnStopIndex: number,\r\n        visibleRowStartIndex: number,\r\n        visibleRowStopIndex: number\r\n      ) =>\r\n        ((this.props.onItemsRendered: any): OnItemsRenderedCallback)({\r\n          overscanColumnStartIndex,\r\n          overscanColumnStopIndex,\r\n          overscanRowStartIndex,\r\n          overscanRowStopIndex,\r\n          visibleColumnStartIndex,\r\n          visibleColumnStopIndex,\r\n          visibleRowStartIndex,\r\n          visibleRowStopIndex,\r\n        })\r\n    );\r\n\r\n    _callOnScroll: (\r\n      scrollLeft: number,\r\n      scrollTop: number,\r\n      horizontalScrollDirection: ScrollDirection,\r\n      verticalScrollDirection: ScrollDirection,\r\n      scrollUpdateWasRequested: boolean\r\n    ) => void;\r\n    _callOnScroll = memoizeOne(\r\n      (\r\n        scrollLeft: number,\r\n        scrollTop: number,\r\n        horizontalScrollDirection: ScrollDirection,\r\n        verticalScrollDirection: ScrollDirection,\r\n        scrollUpdateWasRequested: boolean\r\n      ) =>\r\n        ((this.props.onScroll: any): OnScrollCallback)({\r\n          horizontalScrollDirection,\r\n          scrollLeft,\r\n          scrollTop,\r\n          verticalScrollDirection,\r\n          scrollUpdateWasRequested,\r\n        })\r\n    );\r\n\r\n    _callPropsCallbacks() {\r\n      const { columnCount, onItemsRendered, onScroll, rowCount } = this.props;\r\n\r\n      if (typeof onItemsRendered === 'function') {\r\n        if (columnCount > 0 && rowCount > 0) {\r\n          const [\r\n            overscanColumnStartIndex,\r\n            overscanColumnStopIndex,\r\n            visibleColumnStartIndex,\r\n            visibleColumnStopIndex,\r\n          ] = this._getHorizontalRangeToRender();\r\n          const [\r\n            overscanRowStartIndex,\r\n            overscanRowStopIndex,\r\n            visibleRowStartIndex,\r\n            visibleRowStopIndex,\r\n          ] = this._getVerticalRangeToRender();\r\n          this._callOnItemsRendered(\r\n            overscanColumnStartIndex,\r\n            overscanColumnStopIndex,\r\n            overscanRowStartIndex,\r\n            overscanRowStopIndex,\r\n            visibleColumnStartIndex,\r\n            visibleColumnStopIndex,\r\n            visibleRowStartIndex,\r\n            visibleRowStopIndex\r\n          );\r\n        }\r\n      }\r\n\r\n      if (typeof onScroll === 'function') {\r\n        const {\r\n          horizontalScrollDirection,\r\n          scrollLeft,\r\n          scrollTop,\r\n          scrollUpdateWasRequested,\r\n          verticalScrollDirection,\r\n        } = this.state;\r\n        this._callOnScroll(\r\n          scrollLeft,\r\n          scrollTop,\r\n          horizontalScrollDirection,\r\n          verticalScrollDirection,\r\n          scrollUpdateWasRequested\r\n        );\r\n      }\r\n    }\r\n\r\n    // Lazily create and cache item styles while scrolling,\r\n    // So that pure component sCU will prevent re-renders.\r\n    // We maintain this cache, and pass a style prop rather than index,\r\n    // So that List can clear cached styles and force item re-render if necessary.\r\n    _getItemStyle: (rowIndex: number, columnIndex: number) => Object;\r\n    _getItemStyle = (rowIndex: number, columnIndex: number): Object => {\r\n      const { columnWidth, direction, rowHeight } = this.props;\r\n\r\n      const itemStyleCache = this._getItemStyleCache(\r\n        shouldResetStyleCacheOnItemSizeChange && columnWidth,\r\n        shouldResetStyleCacheOnItemSizeChange && direction,\r\n        shouldResetStyleCacheOnItemSizeChange && rowHeight\r\n      );\r\n\r\n      const key = `${rowIndex}:${columnIndex}`;\r\n\r\n      let style;\r\n      if (itemStyleCache.hasOwnProperty(key)) {\r\n        style = itemStyleCache[key];\r\n      } else {\r\n        const offset = getColumnOffset(\r\n          this.props,\r\n          columnIndex,\r\n          this._instanceProps\r\n        );\r\n        const isRtl = direction === 'rtl';\r\n        itemStyleCache[key] = style = {\r\n          position: 'absolute',\r\n          left: isRtl ? undefined : offset,\r\n          right: isRtl ? offset : undefined,\r\n          top: getRowOffset(this.props, rowIndex, this._instanceProps),\r\n          height: getRowHeight(this.props, rowIndex, this._instanceProps),\r\n          width: getColumnWidth(this.props, columnIndex, this._instanceProps),\r\n        };\r\n      }\r\n\r\n      return style;\r\n    };\r\n\r\n    _getItemStyleCache: (_: any, __: any, ___: any) => ItemStyleCache;\r\n    _getItemStyleCache = memoizeOne((_: any, __: any, ___: any) => ({}));\r\n\r\n    _getHorizontalRangeToRender(): [number, number, number, number] {\r\n      const {\r\n        columnCount,\r\n        overscanColumnCount,\r\n        overscanColumnsCount,\r\n        overscanCount,\r\n        rowCount,\r\n      } = this.props;\r\n      const { horizontalScrollDirection, isScrolling, scrollLeft } = this.state;\r\n\r\n      const overscanCountResolved: number =\r\n        overscanColumnCount || overscanColumnsCount || overscanCount || 1;\r\n\r\n      if (columnCount === 0 || rowCount === 0) {\r\n        return [0, 0, 0, 0];\r\n      }\r\n\r\n      const startIndex = getColumnStartIndexForOffset(\r\n        this.props,\r\n        scrollLeft,\r\n        this._instanceProps\r\n      );\r\n      const stopIndex = getColumnStopIndexForStartIndex(\r\n        this.props,\r\n        startIndex,\r\n        scrollLeft,\r\n        this._instanceProps\r\n      );\r\n\r\n      // Overscan by one item in each direction so that tab/focus works.\r\n      // If there isn't at least one extra item, tab loops back around.\r\n      const overscanBackward =\r\n        !isScrolling || horizontalScrollDirection === 'backward'\r\n          ? Math.max(1, overscanCountResolved)\r\n          : 1;\r\n      const overscanForward =\r\n        !isScrolling || horizontalScrollDirection === 'forward'\r\n          ? Math.max(1, overscanCountResolved)\r\n          : 1;\r\n\r\n      return [\r\n        Math.max(0, startIndex - overscanBackward),\r\n        Math.max(0, Math.min(columnCount - 1, stopIndex + overscanForward)),\r\n        startIndex,\r\n        stopIndex,\r\n      ];\r\n    }\r\n\r\n    _getVerticalRangeToRender(): [number, number, number, number] {\r\n      const {\r\n        columnCount,\r\n        overscanCount,\r\n        overscanRowCount,\r\n        overscanRowsCount,\r\n        rowCount,\r\n      } = this.props;\r\n      const { isScrolling, verticalScrollDirection, scrollTop } = this.state;\r\n\r\n      const overscanCountResolved: number =\r\n        overscanRowCount || overscanRowsCount || overscanCount || 1;\r\n\r\n      if (columnCount === 0 || rowCount === 0) {\r\n        return [0, 0, 0, 0];\r\n      }\r\n\r\n      const startIndex = getRowStartIndexForOffset(\r\n        this.props,\r\n        scrollTop,\r\n        this._instanceProps\r\n      );\r\n      const stopIndex = getRowStopIndexForStartIndex(\r\n        this.props,\r\n        startIndex,\r\n        scrollTop,\r\n        this._instanceProps\r\n      );\r\n\r\n      // Overscan by one item in each direction so that tab/focus works.\r\n      // If there isn't at least one extra item, tab loops back around.\r\n      const overscanBackward =\r\n        !isScrolling || verticalScrollDirection === 'backward'\r\n          ? Math.max(1, overscanCountResolved)\r\n          : 1;\r\n      const overscanForward =\r\n        !isScrolling || verticalScrollDirection === 'forward'\r\n          ? Math.max(1, overscanCountResolved)\r\n          : 1;\r\n\r\n      return [\r\n        Math.max(0, startIndex - overscanBackward),\r\n        Math.max(0, Math.min(rowCount - 1, stopIndex + overscanForward)),\r\n        startIndex,\r\n        stopIndex,\r\n      ];\r\n    }\r\n\r\n    _onScroll = (event: ScrollEvent): void => {\r\n      const {\r\n        clientHeight,\r\n        clientWidth,\r\n        scrollLeft,\r\n        scrollTop,\r\n        scrollHeight,\r\n        scrollWidth,\r\n      } = event.currentTarget;\r\n      this.setState(prevState => {\r\n        if (\r\n          prevState.scrollLeft === scrollLeft &&\r\n          prevState.scrollTop === scrollTop\r\n        ) {\r\n          // Scroll position may have been updated by cDM/cDU,\r\n          // In which case we don't need to trigger another render,\r\n          // And we don't want to update state.isScrolling.\r\n          return null;\r\n        }\r\n\r\n        const { direction } = this.props;\r\n\r\n        // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\r\n        // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\r\n        // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\r\n        // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\r\n        let calculatedScrollLeft = scrollLeft;\r\n        if (direction === 'rtl') {\r\n          switch (getRTLOffsetType()) {\r\n            case 'negative':\r\n              calculatedScrollLeft = -scrollLeft;\r\n              break;\r\n            case 'positive-descending':\r\n              calculatedScrollLeft = scrollWidth - clientWidth - scrollLeft;\r\n              break;\r\n          }\r\n        }\r\n\r\n        // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\r\n        calculatedScrollLeft = Math.max(\r\n          0,\r\n          Math.min(calculatedScrollLeft, scrollWidth - clientWidth)\r\n        );\r\n        const calculatedScrollTop = Math.max(\r\n          0,\r\n          Math.min(scrollTop, scrollHeight - clientHeight)\r\n        );\r\n\r\n        return {\r\n          isScrolling: true,\r\n          horizontalScrollDirection:\r\n            prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\r\n          scrollLeft: calculatedScrollLeft,\r\n          scrollTop: calculatedScrollTop,\r\n          verticalScrollDirection:\r\n            prevState.scrollTop < scrollTop ? 'forward' : 'backward',\r\n          scrollUpdateWasRequested: false,\r\n        };\r\n      }, this._resetIsScrollingDebounced);\r\n    };\r\n\r\n    _outerRefSetter = (ref: any): void => {\r\n      const { outerRef } = this.props;\r\n\r\n      this._outerRef = ((ref: any): HTMLDivElement);\r\n\r\n      if (typeof outerRef === 'function') {\r\n        outerRef(ref);\r\n      } else if (\r\n        outerRef != null &&\r\n        typeof outerRef === 'object' &&\r\n        outerRef.hasOwnProperty('current')\r\n      ) {\r\n        outerRef.current = ref;\r\n      }\r\n    };\r\n\r\n    _resetIsScrollingDebounced = () => {\r\n      if (this._resetIsScrollingTimeoutId !== null) {\r\n        cancelTimeout(this._resetIsScrollingTimeoutId);\r\n      }\r\n\r\n      this._resetIsScrollingTimeoutId = requestTimeout(\r\n        this._resetIsScrolling,\r\n        IS_SCROLLING_DEBOUNCE_INTERVAL\r\n      );\r\n    };\r\n\r\n    _resetIsScrolling = () => {\r\n      this._resetIsScrollingTimeoutId = null;\r\n\r\n      this.setState({ isScrolling: false }, () => {\r\n        // Clear style cache after state update has been committed.\r\n        // This way we don't break pure sCU for items that don't use isScrolling param.\r\n        this._getItemStyleCache(-1);\r\n      });\r\n    };\r\n  };\r\n}\r\n\r\nconst validateSharedProps = (\r\n  {\r\n    children,\r\n    direction,\r\n    height,\r\n    innerTagName,\r\n    outerTagName,\r\n    overscanColumnsCount,\r\n    overscanCount,\r\n    overscanRowsCount,\r\n    width,\r\n  }: Props<any>,\r\n  { instance }: State\r\n): void => {\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    if (typeof overscanCount === 'number') {\r\n      if (devWarningsOverscanCount && !devWarningsOverscanCount.has(instance)) {\r\n        devWarningsOverscanCount.add(instance);\r\n        console.warn(\r\n          'The overscanCount prop has been deprecated. ' +\r\n            'Please use the overscanColumnCount and overscanRowCount props instead.'\r\n        );\r\n      }\r\n    }\r\n\r\n    if (\r\n      typeof overscanColumnsCount === 'number' ||\r\n      typeof overscanRowsCount === 'number'\r\n    ) {\r\n      if (\r\n        devWarningsOverscanRowsColumnsCount &&\r\n        !devWarningsOverscanRowsColumnsCount.has(instance)\r\n      ) {\r\n        devWarningsOverscanRowsColumnsCount.add(instance);\r\n        console.warn(\r\n          'The overscanColumnsCount and overscanRowsCount props have been deprecated. ' +\r\n            'Please use the overscanColumnCount and overscanRowCount props instead.'\r\n        );\r\n      }\r\n    }\r\n\r\n    if (innerTagName != null || outerTagName != null) {\r\n      if (devWarningsTagName && !devWarningsTagName.has(instance)) {\r\n        devWarningsTagName.add(instance);\r\n        console.warn(\r\n          'The innerTagName and outerTagName props have been deprecated. ' +\r\n            'Please use the innerElementType and outerElementType props instead.'\r\n        );\r\n      }\r\n    }\r\n\r\n    if (children == null) {\r\n      throw Error(\r\n        'An invalid \"children\" prop has been specified. ' +\r\n          'Value should be a React component. ' +\r\n          `\"${children === null ? 'null' : typeof children}\" was specified.`\r\n      );\r\n    }\r\n\r\n    switch (direction) {\r\n      case 'ltr':\r\n      case 'rtl':\r\n        // Valid values\r\n        break;\r\n      default:\r\n        throw Error(\r\n          'An invalid \"direction\" prop has been specified. ' +\r\n            'Value should be either \"ltr\" or \"rtl\". ' +\r\n            `\"${direction}\" was specified.`\r\n        );\r\n    }\r\n\r\n    if (typeof width !== 'number') {\r\n      throw Error(\r\n        'An invalid \"width\" prop has been specified. ' +\r\n          'Grids must specify a number for width. ' +\r\n          `\"${width === null ? 'null' : typeof width}\" was specified.`\r\n      );\r\n    }\r\n\r\n    if (typeof height !== 'number') {\r\n      throw Error(\r\n        'An invalid \"height\" prop has been specified. ' +\r\n          'Grids must specify a number for height. ' +\r\n          `\"${height === null ? 'null' : typeof height}\" was specified.`\r\n      );\r\n    }\r\n  }\r\n};\r\n","// @flow\r\n\r\nimport createGridComponent from './createGridComponent';\r\n\r\nimport type { Props, ScrollToAlign } from './createGridComponent';\r\n\r\nconst DEFAULT_ESTIMATED_ITEM_SIZE = 50;\r\n\r\ntype VariableSizeProps = {|\r\n  estimatedColumnWidth: number,\r\n  estimatedRowHeight: number,\r\n  disableColVirtualized?: boolean,\r\n  disableRowVirtualized?: boolean,\r\n  ...Props<any>,\r\n|};\r\n\r\ntype itemSizeGetter = (index: number) => number;\r\ntype ItemType = 'column' | 'row';\r\n\r\ntype ItemMetadata = {|\r\n  offset: number,\r\n  size: number,\r\n|};\r\ntype ItemMetadataMap = { [index: number]: ItemMetadata };\r\ntype InstanceProps = {|\r\n  columnMetadataMap: ItemMetadataMap,\r\n  estimatedColumnWidth: number,\r\n  estimatedRowHeight: number,\r\n  lastMeasuredColumnIndex: number,\r\n  lastMeasuredRowIndex: number,\r\n  rowMetadataMap: ItemMetadataMap,\r\n|};\r\n\r\nconst getEstimatedTotalHeight = (\r\n  { rowCount }: Props<any>,\r\n  { rowMetadataMap, estimatedRowHeight, lastMeasuredRowIndex }: InstanceProps\r\n) => {\r\n  let totalSizeOfMeasuredRows = 0;\r\n\r\n  // Edge case check for when the number of items decreases while a scroll is in progress.\r\n  // https://github.com/bvaughn/react-window/pull/138\r\n  if (lastMeasuredRowIndex >= rowCount) {\r\n    lastMeasuredRowIndex = rowCount - 1;\r\n  }\r\n\r\n  if (lastMeasuredRowIndex >= 0) {\r\n    const itemMetadata = rowMetadataMap[lastMeasuredRowIndex];\r\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\r\n  }\r\n\r\n  const numUnmeasuredItems = rowCount - lastMeasuredRowIndex - 1;\r\n  const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedRowHeight;\r\n\r\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\r\n};\r\n\r\nconst getEstimatedTotalWidth = (\r\n  { columnCount }: Props<any>,\r\n  {\r\n    columnMetadataMap,\r\n    estimatedColumnWidth,\r\n    lastMeasuredColumnIndex,\r\n  }: InstanceProps\r\n) => {\r\n  let totalSizeOfMeasuredRows = 0;\r\n\r\n  // Edge case check for when the number of items decreases while a scroll is in progress.\r\n  // https://github.com/bvaughn/react-window/pull/138\r\n  if (lastMeasuredColumnIndex >= columnCount) {\r\n    lastMeasuredColumnIndex = columnCount - 1;\r\n  }\r\n\r\n  if (lastMeasuredColumnIndex >= 0) {\r\n    const itemMetadata = columnMetadataMap[lastMeasuredColumnIndex];\r\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\r\n  }\r\n\r\n  const numUnmeasuredItems = columnCount - lastMeasuredColumnIndex - 1;\r\n  const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedColumnWidth;\r\n\r\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\r\n};\r\n\r\nconst getItemMetadata = (\r\n  itemType: ItemType,\r\n  props: Props<any>,\r\n  index: number,\r\n  instanceProps: InstanceProps\r\n): ItemMetadata => {\r\n  let itemMetadataMap, itemSize, lastMeasuredIndex;\r\n  if (itemType === 'column') {\r\n    itemMetadataMap = instanceProps.columnMetadataMap;\r\n    itemSize = ((props.columnWidth: any): itemSizeGetter);\r\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\r\n  } else {\r\n    itemMetadataMap = instanceProps.rowMetadataMap;\r\n    itemSize = ((props.rowHeight: any): itemSizeGetter);\r\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\r\n  }\r\n\r\n  if (index > lastMeasuredIndex) {\r\n    let offset = 0;\r\n    if (lastMeasuredIndex >= 0) {\r\n      const itemMetadata = itemMetadataMap[lastMeasuredIndex];\r\n      offset = itemMetadata.offset + itemMetadata.size;\r\n    }\r\n\r\n    for (let i = lastMeasuredIndex + 1; i <= index; i++) {\r\n      let size = itemSize(i);\r\n\r\n      itemMetadataMap[i] = {\r\n        offset,\r\n        size,\r\n      };\r\n\r\n      offset += size;\r\n    }\r\n\r\n    if (itemType === 'column') {\r\n      instanceProps.lastMeasuredColumnIndex = index;\r\n    } else {\r\n      instanceProps.lastMeasuredRowIndex = index;\r\n    }\r\n  }\r\n\r\n  return itemMetadataMap[index];\r\n};\r\n\r\nconst findNearestItem = (\r\n  itemType: ItemType,\r\n  props: Props<any>,\r\n  instanceProps: InstanceProps,\r\n  offset: number\r\n) => {\r\n  let itemMetadataMap, lastMeasuredIndex;\r\n  if (itemType === 'column') {\r\n    itemMetadataMap = instanceProps.columnMetadataMap;\r\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\r\n  } else {\r\n    itemMetadataMap = instanceProps.rowMetadataMap;\r\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\r\n  }\r\n\r\n  const lastMeasuredItemOffset =\r\n    lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\r\n\r\n  if (lastMeasuredItemOffset >= offset) {\r\n    // If we've already measured items within this range just use a binary search as it's faster.\r\n    return findNearestItemBinarySearch(\r\n      itemType,\r\n      props,\r\n      instanceProps,\r\n      lastMeasuredIndex,\r\n      0,\r\n      offset\r\n    );\r\n  } else {\r\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\r\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\r\n    // The overall complexity for this approach is O(log n).\r\n    return findNearestItemExponentialSearch(\r\n      itemType,\r\n      props,\r\n      instanceProps,\r\n      Math.max(0, lastMeasuredIndex),\r\n      offset\r\n    );\r\n  }\r\n};\r\n\r\nconst findNearestItemBinarySearch = (\r\n  itemType: ItemType,\r\n  props: Props<any>,\r\n  instanceProps: InstanceProps,\r\n  high: number,\r\n  low: number,\r\n  offset: number\r\n): number => {\r\n  while (low <= high) {\r\n    const middle = low + Math.floor((high - low) / 2);\r\n    const currentOffset = getItemMetadata(\r\n      itemType,\r\n      props,\r\n      middle,\r\n      instanceProps\r\n    ).offset;\r\n\r\n    if (currentOffset === offset) {\r\n      return middle;\r\n    } else if (currentOffset < offset) {\r\n      low = middle + 1;\r\n    } else if (currentOffset > offset) {\r\n      high = middle - 1;\r\n    }\r\n  }\r\n\r\n  if (low > 0) {\r\n    return low - 1;\r\n  } else {\r\n    return 0;\r\n  }\r\n};\r\n\r\nconst findNearestItemExponentialSearch = (\r\n  itemType: ItemType,\r\n  props: Props<any>,\r\n  instanceProps: InstanceProps,\r\n  index: number,\r\n  offset: number\r\n): number => {\r\n  const itemCount = itemType === 'column' ? props.columnCount : props.rowCount;\r\n  let interval = 1;\r\n\r\n  while (\r\n    index < itemCount &&\r\n    getItemMetadata(itemType, props, index, instanceProps).offset < offset\r\n  ) {\r\n    index += interval;\r\n    interval *= 2;\r\n  }\r\n\r\n  return findNearestItemBinarySearch(\r\n    itemType,\r\n    props,\r\n    instanceProps,\r\n    Math.min(index, itemCount - 1),\r\n    Math.floor(index / 2),\r\n    offset\r\n  );\r\n};\r\n\r\nconst getOffsetForIndexAndAlignment = (\r\n  itemType: ItemType,\r\n  props: Props<any>,\r\n  index: number,\r\n  align: ScrollToAlign,\r\n  scrollOffset: number,\r\n  instanceProps: InstanceProps,\r\n  scrollbarSize: number\r\n): number => {\r\n  const size = itemType === 'column' ? props.width : props.height;\r\n  const itemMetadata = getItemMetadata(itemType, props, index, instanceProps);\r\n\r\n  // Get estimated total size after ItemMetadata is computed,\r\n  // To ensure it reflects actual measurements instead of just estimates.\r\n  const estimatedTotalSize =\r\n    itemType === 'column'\r\n      ? getEstimatedTotalWidth(props, instanceProps)\r\n      : getEstimatedTotalHeight(props, instanceProps);\r\n\r\n  const maxOffset = Math.max(\r\n    0,\r\n    Math.min(estimatedTotalSize - size, itemMetadata.offset)\r\n  );\r\n  const minOffset = Math.max(\r\n    0,\r\n    itemMetadata.offset - size + scrollbarSize + itemMetadata.size\r\n  );\r\n\r\n  if (align === 'smart') {\r\n    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\r\n      align = 'auto';\r\n    } else {\r\n      align = 'center';\r\n    }\r\n  }\r\n\r\n  switch (align) {\r\n    case 'start':\r\n      return maxOffset;\r\n    case 'end':\r\n      return minOffset;\r\n    case 'center':\r\n      return Math.round(minOffset + (maxOffset - minOffset) / 2);\r\n    case 'auto':\r\n    default:\r\n      if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\r\n        return scrollOffset;\r\n      } else if (minOffset > maxOffset) {\r\n        // Because we only take into account the scrollbar size when calculating minOffset\r\n        // this value can be larger than maxOffset when at the end of the list\r\n        return minOffset;\r\n      } else if (scrollOffset < minOffset) {\r\n        return minOffset;\r\n      } else {\r\n        return maxOffset;\r\n      }\r\n  }\r\n};\r\n\r\nconst VariableSizeGrid = createGridComponent({\r\n  getColumnOffset: (\r\n    props: Props<any>,\r\n    index: number,\r\n    instanceProps: InstanceProps\r\n  ): number => getItemMetadata('column', props, index, instanceProps).offset,\r\n\r\n  getColumnStartIndexForOffset: (\r\n    props: Props<any>,\r\n    scrollLeft: number,\r\n    instanceProps: InstanceProps\r\n  ): number => findNearestItem('column', props, instanceProps, scrollLeft),\r\n\r\n  getColumnStopIndexForStartIndex: (\r\n    props: Props<any>,\r\n    startIndex: number,\r\n    scrollLeft: number,\r\n    instanceProps: InstanceProps\r\n  ): number => {\r\n    const { columnCount, width } = props;\r\n\r\n    const itemMetadata = getItemMetadata(\r\n      'column',\r\n      props,\r\n      startIndex,\r\n      instanceProps\r\n    );\r\n    const maxOffset = scrollLeft + width;\r\n\r\n    let offset = itemMetadata.offset + itemMetadata.size;\r\n    let stopIndex = startIndex;\r\n\r\n    while (stopIndex < columnCount - 1 && offset < maxOffset) {\r\n      stopIndex++;\r\n      offset += getItemMetadata('column', props, stopIndex, instanceProps).size;\r\n    }\r\n\r\n    return stopIndex;\r\n  },\r\n\r\n  getColumnWidth: (\r\n    props: Props<any>,\r\n    index: number,\r\n    instanceProps: InstanceProps\r\n  ): number => instanceProps.columnMetadataMap[index].size,\r\n\r\n  getEstimatedTotalHeight,\r\n  getEstimatedTotalWidth,\r\n\r\n  getOffsetForColumnAndAlignment: (\r\n    props: Props<any>,\r\n    index: number,\r\n    align: ScrollToAlign,\r\n    scrollOffset: number,\r\n    instanceProps: InstanceProps,\r\n    scrollbarSize: number\r\n  ): number =>\r\n    getOffsetForIndexAndAlignment(\r\n      'column',\r\n      props,\r\n      index,\r\n      align,\r\n      scrollOffset,\r\n      instanceProps,\r\n      scrollbarSize\r\n    ),\r\n\r\n  getOffsetForRowAndAlignment: (\r\n    props: Props<any>,\r\n    index: number,\r\n    align: ScrollToAlign,\r\n    scrollOffset: number,\r\n    instanceProps: InstanceProps,\r\n    scrollbarSize: number\r\n  ): number =>\r\n    getOffsetForIndexAndAlignment(\r\n      'row',\r\n      props,\r\n      index,\r\n      align,\r\n      scrollOffset,\r\n      instanceProps,\r\n      scrollbarSize\r\n    ),\r\n\r\n  getRowOffset: (\r\n    props: Props<any>,\r\n    index: number,\r\n    instanceProps: InstanceProps\r\n  ): number => getItemMetadata('row', props, index, instanceProps).offset,\r\n\r\n  getRowHeight: (\r\n    props: Props<any>,\r\n    index: number,\r\n    instanceProps: InstanceProps\r\n  ): number => instanceProps.rowMetadataMap[index].size,\r\n\r\n  getRowStartIndexForOffset: (\r\n    props: Props<any>,\r\n    scrollTop: number,\r\n    instanceProps: InstanceProps\r\n  ): number => findNearestItem('row', props, instanceProps, scrollTop),\r\n\r\n  getRowStopIndexForStartIndex: (\r\n    props: Props<any>,\r\n    startIndex: number,\r\n    scrollTop: number,\r\n    instanceProps: InstanceProps\r\n  ): number => {\r\n    const { rowCount, height } = props;\r\n\r\n    const itemMetadata = getItemMetadata(\r\n      'row',\r\n      props,\r\n      startIndex,\r\n      instanceProps\r\n    );\r\n    const maxOffset = scrollTop + height;\r\n\r\n    let offset = itemMetadata.offset + itemMetadata.size;\r\n    let stopIndex = startIndex;\r\n\r\n    while (stopIndex < rowCount - 1 && offset < maxOffset) {\r\n      stopIndex++;\r\n      offset += getItemMetadata('row', props, stopIndex, instanceProps).size;\r\n    }\r\n\r\n    return stopIndex;\r\n  },\r\n\r\n  initInstanceProps(props: Props<any>, instance: any): InstanceProps {\r\n    const {\r\n      estimatedColumnWidth,\r\n      estimatedRowHeight,\r\n    } = ((props: any): VariableSizeProps);\r\n\r\n    const instanceProps = {\r\n      columnMetadataMap: {},\r\n      estimatedColumnWidth: estimatedColumnWidth || DEFAULT_ESTIMATED_ITEM_SIZE,\r\n      estimatedRowHeight: estimatedRowHeight || DEFAULT_ESTIMATED_ITEM_SIZE,\r\n      lastMeasuredColumnIndex: -1,\r\n      lastMeasuredRowIndex: -1,\r\n      rowMetadataMap: {},\r\n    };\r\n\r\n    instance.resetAfterColumnIndex = (\r\n      columnIndex: number,\r\n      shouldForceUpdate?: boolean = true\r\n    ) => {\r\n      instance.resetAfterIndices({ columnIndex, shouldForceUpdate });\r\n    };\r\n\r\n    instance.resetAfterRowIndex = (\r\n      rowIndex: number,\r\n      shouldForceUpdate?: boolean = true\r\n    ) => {\r\n      instance.resetAfterIndices({ rowIndex, shouldForceUpdate });\r\n    };\r\n\r\n    instance.resetAfterIndices = ({\r\n      columnIndex,\r\n      rowIndex,\r\n      shouldForceUpdate = true,\r\n    }: {\r\n      columnIndex?: number,\r\n      rowIndex?: number,\r\n      shouldForceUpdate: boolean,\r\n    }) => {\r\n      if (typeof columnIndex === 'number') {\r\n        instanceProps.lastMeasuredColumnIndex = Math.min(\r\n          instanceProps.lastMeasuredColumnIndex,\r\n          columnIndex - 1\r\n        );\r\n      }\r\n      if (typeof rowIndex === 'number') {\r\n        instanceProps.lastMeasuredRowIndex = Math.min(\r\n          instanceProps.lastMeasuredRowIndex,\r\n          rowIndex - 1\r\n        );\r\n      }\r\n\r\n      // We could potentially optimize further by only evicting styles after this index,\r\n      // But since styles are only cached while scrolling is in progress-\r\n      // It seems an unnecessary optimization.\r\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\r\n      instance._getItemStyleCache(-1);\r\n\r\n      if (shouldForceUpdate) {\r\n        instance.forceUpdate();\r\n      }\r\n    };\r\n\r\n    return instanceProps;\r\n  },\r\n\r\n  shouldResetStyleCacheOnItemSizeChange: false,\r\n\r\n  validateProps: ({ columnWidth, rowHeight }: Props<any>): void => {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      if (typeof columnWidth !== 'function') {\r\n        throw Error(\r\n          'An invalid \"columnWidth\" prop has been specified. ' +\r\n            'Value should be a function. ' +\r\n            `\"${\r\n              columnWidth === null ? 'null' : typeof columnWidth\r\n            }\" was specified.`\r\n        );\r\n      } else if (typeof rowHeight !== 'function') {\r\n        throw Error(\r\n          'An invalid \"rowHeight\" prop has been specified. ' +\r\n            'Value should be a function. ' +\r\n            `\"${rowHeight === null ? 'null' : typeof rowHeight}\" was specified.`\r\n        );\r\n      }\r\n    }\r\n  },\r\n});\r\n\r\nexport default VariableSizeGrid;\r\n","// @flow\r\n\r\nimport memoizeOne from 'memoize-one';\r\nimport { createElement, PureComponent } from 'react';\r\nimport { cancelTimeout, requestTimeout } from './timer';\r\nimport { getScrollbarSize, getRTLOffsetType } from './domHelpers';\r\n\r\nimport type { TimeoutID } from './timer';\r\n\r\nexport type ScrollToAlign = 'auto' | 'smart' | 'center' | 'start' | 'end';\r\n\r\ntype itemSize = number | ((index: number) => number);\r\n// TODO Deprecate directions \"horizontal\" and \"vertical\"\r\ntype Direction = 'ltr' | 'rtl' | 'horizontal' | 'vertical';\r\ntype Layout = 'horizontal' | 'vertical';\r\n\r\ntype RenderComponentProps<T> = {|\r\n  data: T,\r\n  index: number,\r\n  isScrolling?: boolean,\r\n  style: Object,\r\n|};\r\ntype RenderComponent<T> = React$ComponentType<$Shape<RenderComponentProps<T>>>;\r\n\r\ntype ScrollDirection = 'forward' | 'backward';\r\n\r\ntype onItemsRenderedCallback = ({\r\n  overscanStartIndex: number,\r\n  overscanStopIndex: number,\r\n  visibleStartIndex: number,\r\n  visibleStopIndex: number,\r\n}) => void;\r\ntype onScrollCallback = ({\r\n  scrollDirection: ScrollDirection,\r\n  scrollOffset: number,\r\n  scrollUpdateWasRequested: boolean,\r\n}) => void;\r\n\r\ntype ScrollEvent = SyntheticEvent<HTMLDivElement>;\r\ntype ItemStyleCache = { [index: number]: Object };\r\n\r\ntype OuterProps = {|\r\n  children: React$Node,\r\n  className: string | void,\r\n  onScroll: ScrollEvent => void,\r\n  style: {\r\n    [string]: mixed,\r\n  },\r\n|};\r\n\r\ntype InnerProps = {|\r\n  children: React$Node,\r\n  style: {\r\n    [string]: mixed,\r\n  },\r\n|};\r\n\r\nexport type Props<T> = {|\r\n  children: RenderComponent<T>,\r\n  className?: string,\r\n  direction: Direction,\r\n  height: number | string,\r\n  initialScrollOffset?: number,\r\n  innerRef?: any,\r\n  innerElementType?: string | React$AbstractComponent<InnerProps, any>,\r\n  innerTagName?: string, // deprecated\r\n  itemCount: number,\r\n  itemData: T,\r\n  itemKey?: (index: number, data: T) => any,\r\n  itemSize: itemSize,\r\n  layout: Layout,\r\n  onItemsRendered?: onItemsRenderedCallback,\r\n  onScroll?: onScrollCallback,\r\n  outerRef?: any,\r\n  outerElementType?: string | React$AbstractComponent<OuterProps, any>,\r\n  outerTagName?: string, // deprecated\r\n  overscanCount: number,\r\n  style?: Object,\r\n  useIsScrolling: boolean,\r\n  width: number | string,\r\n|};\r\n\r\ntype State = {|\r\n  instance: any,\r\n  isScrolling: boolean,\r\n  scrollDirection: ScrollDirection,\r\n  scrollOffset: number,\r\n  scrollUpdateWasRequested: boolean,\r\n|};\r\n\r\ntype GetItemOffset = (\r\n  props: Props<any>,\r\n  index: number,\r\n  instanceProps: any\r\n) => number;\r\ntype GetItemSize = (\r\n  props: Props<any>,\r\n  index: number,\r\n  instanceProps: any\r\n) => number;\r\ntype GetEstimatedTotalSize = (props: Props<any>, instanceProps: any) => number;\r\ntype GetOffsetForIndexAndAlignment = (\r\n  props: Props<any>,\r\n  index: number,\r\n  align: ScrollToAlign,\r\n  scrollOffset: number,\r\n  instanceProps: any\r\n) => number;\r\ntype GetStartIndexForOffset = (\r\n  props: Props<any>,\r\n  offset: number,\r\n  instanceProps: any\r\n) => number;\r\ntype GetStopIndexForStartIndex = (\r\n  props: Props<any>,\r\n  startIndex: number,\r\n  scrollOffset: number,\r\n  instanceProps: any\r\n) => number;\r\ntype InitInstanceProps = (props: Props<any>, instance: any) => any;\r\ntype ValidateProps = (props: Props<any>) => void;\r\n\r\nconst IS_SCROLLING_DEBOUNCE_INTERVAL = 150;\r\n\r\nconst defaultItemKey = (index: number, data: any) => index;\r\n\r\n// In DEV mode, this Set helps us only log a warning once per component instance.\r\n// This avoids spamming the console every time a render happens.\r\nlet devWarningsDirection = null;\r\nlet devWarningsTagName = null;\r\nif (process.env.NODE_ENV !== 'production') {\r\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\r\n    devWarningsDirection = new WeakSet();\r\n    devWarningsTagName = new WeakSet();\r\n  }\r\n}\r\n\r\nexport default function createListComponent({\r\n  getItemOffset,\r\n  getEstimatedTotalSize,\r\n  getItemSize,\r\n  getOffsetForIndexAndAlignment,\r\n  getStartIndexForOffset,\r\n  getStopIndexForStartIndex,\r\n  initInstanceProps,\r\n  shouldResetStyleCacheOnItemSizeChange,\r\n  validateProps,\r\n}: {|\r\n  getItemOffset: GetItemOffset,\r\n  getEstimatedTotalSize: GetEstimatedTotalSize,\r\n  getItemSize: GetItemSize,\r\n  getOffsetForIndexAndAlignment: GetOffsetForIndexAndAlignment,\r\n  getStartIndexForOffset: GetStartIndexForOffset,\r\n  getStopIndexForStartIndex: GetStopIndexForStartIndex,\r\n  initInstanceProps: InitInstanceProps,\r\n  shouldResetStyleCacheOnItemSizeChange: boolean,\r\n  validateProps: ValidateProps,\r\n|}) {\r\n  return class List<T> extends PureComponent<Props<T>, State> {\r\n    _instanceProps: any = initInstanceProps(this.props, this);\r\n    _outerRef: ?HTMLDivElement;\r\n    _resetIsScrollingTimeoutId: TimeoutID | null = null;\r\n\r\n    static defaultProps = {\r\n      direction: 'ltr',\r\n      itemData: undefined,\r\n      layout: 'vertical',\r\n      overscanCount: 2,\r\n      useIsScrolling: false,\r\n    };\r\n\r\n    state: State = {\r\n      instance: this,\r\n      isScrolling: false,\r\n      scrollDirection: 'forward',\r\n      scrollOffset:\r\n        typeof this.props.initialScrollOffset === 'number'\r\n          ? this.props.initialScrollOffset\r\n          : 0,\r\n      scrollUpdateWasRequested: false,\r\n    };\r\n\r\n    // Always use explicit constructor for React components.\r\n    // It produces less code after transpilation. (#26)\r\n    // eslint-disable-next-line no-useless-constructor\r\n    constructor(props: Props<T>) {\r\n      super(props);\r\n    }\r\n\r\n    static getDerivedStateFromProps(\r\n      nextProps: Props<T>,\r\n      prevState: State\r\n    ): $Shape<State> | null {\r\n      validateSharedProps(nextProps, prevState);\r\n      validateProps(nextProps);\r\n      return null;\r\n    }\r\n\r\n    scrollTo(scrollOffset: number): void {\r\n      scrollOffset = Math.max(0, scrollOffset);\r\n\r\n      this.setState(prevState => {\r\n        if (prevState.scrollOffset === scrollOffset) {\r\n          return null;\r\n        }\r\n        return {\r\n          scrollDirection:\r\n            prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\r\n          scrollOffset: scrollOffset,\r\n          scrollUpdateWasRequested: true,\r\n        };\r\n      }, this._resetIsScrollingDebounced);\r\n    }\r\n\r\n    scrollToItem(index: number, align: ScrollToAlign = 'auto'): void {\r\n      const { itemCount, layout } = this.props;\r\n      const { scrollOffset } = this.state;\r\n\r\n      index = Math.max(0, Math.min(index, itemCount - 1));\r\n\r\n      // The scrollbar size should be considered when scrolling an item into view, to ensure it's fully visible.\r\n      // But we only need to account for its size when it's actually visible.\r\n      // This is an edge case for lists; normally they only scroll in the dominant direction.\r\n      let scrollbarSize = 0;\r\n      if (this._outerRef) {\r\n        const outerRef = ((this._outerRef: any): HTMLElement);\r\n        if (layout === 'vertical') {\r\n          scrollbarSize =\r\n            outerRef.scrollWidth > outerRef.clientWidth\r\n              ? getScrollbarSize()\r\n              : 0;\r\n        } else {\r\n          scrollbarSize =\r\n            outerRef.scrollHeight > outerRef.clientHeight\r\n              ? getScrollbarSize()\r\n              : 0;\r\n        }\r\n      }\r\n\r\n      this.scrollTo(\r\n        getOffsetForIndexAndAlignment(\r\n          this.props,\r\n          index,\r\n          align,\r\n          scrollOffset,\r\n          this._instanceProps,\r\n          scrollbarSize\r\n        )\r\n      );\r\n    }\r\n\r\n    componentDidMount() {\r\n      const { direction, initialScrollOffset, layout } = this.props;\r\n\r\n      if (typeof initialScrollOffset === 'number' && this._outerRef != null) {\r\n        const outerRef = ((this._outerRef: any): HTMLElement);\r\n        // TODO Deprecate direction \"horizontal\"\r\n        if (direction === 'horizontal' || layout === 'horizontal') {\r\n          outerRef.scrollLeft = initialScrollOffset;\r\n        } else {\r\n          outerRef.scrollTop = initialScrollOffset;\r\n        }\r\n      }\r\n\r\n      this._callPropsCallbacks();\r\n    }\r\n\r\n    componentDidUpdate() {\r\n      const { direction, layout } = this.props;\r\n      const { scrollOffset, scrollUpdateWasRequested } = this.state;\r\n\r\n      if (scrollUpdateWasRequested && this._outerRef != null) {\r\n        const outerRef = ((this._outerRef: any): HTMLElement);\r\n\r\n        // TODO Deprecate direction \"horizontal\"\r\n        if (direction === 'horizontal' || layout === 'horizontal') {\r\n          if (direction === 'rtl') {\r\n            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\r\n            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\r\n            // So we need to determine which browser behavior we're dealing with, and mimic it.\r\n            switch (getRTLOffsetType()) {\r\n              case 'negative':\r\n                outerRef.scrollLeft = -scrollOffset;\r\n                break;\r\n              case 'positive-ascending':\r\n                outerRef.scrollLeft = scrollOffset;\r\n                break;\r\n              default:\r\n                const { clientWidth, scrollWidth } = outerRef;\r\n                outerRef.scrollLeft = scrollWidth - clientWidth - scrollOffset;\r\n                break;\r\n            }\r\n          } else {\r\n            outerRef.scrollLeft = scrollOffset;\r\n          }\r\n        } else {\r\n          outerRef.scrollTop = scrollOffset;\r\n        }\r\n      }\r\n\r\n      this._callPropsCallbacks();\r\n    }\r\n\r\n    componentWillUnmount() {\r\n      if (this._resetIsScrollingTimeoutId !== null) {\r\n        cancelTimeout(this._resetIsScrollingTimeoutId);\r\n      }\r\n    }\r\n\r\n    render() {\r\n      const {\r\n        children,\r\n        className,\r\n        direction,\r\n        height,\r\n        innerRef,\r\n        innerElementType,\r\n        innerTagName,\r\n        itemCount,\r\n        itemData,\r\n        itemKey = defaultItemKey,\r\n        layout,\r\n        outerElementType,\r\n        outerTagName,\r\n        style,\r\n        useIsScrolling,\r\n        width,\r\n      } = this.props;\r\n      const { isScrolling } = this.state;\r\n\r\n      // TODO Deprecate direction \"horizontal\"\r\n      const isHorizontal =\r\n        direction === 'horizontal' || layout === 'horizontal';\r\n\r\n      const onScroll = isHorizontal\r\n        ? this._onScrollHorizontal\r\n        : this._onScrollVertical;\r\n\r\n      const [startIndex, stopIndex] = this._getRangeToRender();\r\n\r\n      const items = [];\r\n      if (itemCount > 0) {\r\n        for (let index = startIndex; index <= stopIndex; index++) {\r\n          items.push(\r\n            createElement(children, {\r\n              data: itemData,\r\n              key: itemKey(index, itemData),\r\n              index,\r\n              isScrolling: useIsScrolling ? isScrolling : undefined,\r\n              style: this._getItemStyle(index),\r\n            })\r\n          );\r\n        }\r\n      }\r\n\r\n      // Read this value AFTER items have been created,\r\n      // So their actual sizes (if variable) are taken into consideration.\r\n      const estimatedTotalSize = getEstimatedTotalSize(\r\n        this.props,\r\n        this._instanceProps\r\n      );\r\n\r\n      return createElement(\r\n        outerElementType || outerTagName || 'div',\r\n        {\r\n          className,\r\n          onScroll,\r\n          ref: this._outerRefSetter,\r\n          style: {\r\n            position: 'relative',\r\n            height,\r\n            width,\r\n            overflow: 'auto',\r\n            WebkitOverflowScrolling: 'touch',\r\n            willChange: 'transform',\r\n            direction,\r\n            ...style,\r\n          },\r\n        },\r\n        createElement(innerElementType || innerTagName || 'div', {\r\n          children: items,\r\n          ref: innerRef,\r\n          style: {\r\n            height: isHorizontal ? '100%' : estimatedTotalSize,\r\n            pointerEvents: isScrolling ? 'none' : undefined,\r\n            width: isHorizontal ? estimatedTotalSize : '100%',\r\n          },\r\n        })\r\n      );\r\n    }\r\n\r\n    _callOnItemsRendered: (\r\n      overscanStartIndex: number,\r\n      overscanStopIndex: number,\r\n      visibleStartIndex: number,\r\n      visibleStopIndex: number\r\n    ) => void;\r\n    _callOnItemsRendered = memoizeOne(\r\n      (\r\n        overscanStartIndex: number,\r\n        overscanStopIndex: number,\r\n        visibleStartIndex: number,\r\n        visibleStopIndex: number\r\n      ) =>\r\n        ((this.props.onItemsRendered: any): onItemsRenderedCallback)({\r\n          overscanStartIndex,\r\n          overscanStopIndex,\r\n          visibleStartIndex,\r\n          visibleStopIndex,\r\n        })\r\n    );\r\n\r\n    _callOnScroll: (\r\n      scrollDirection: ScrollDirection,\r\n      scrollOffset: number,\r\n      scrollUpdateWasRequested: boolean\r\n    ) => void;\r\n    _callOnScroll = memoizeOne(\r\n      (\r\n        scrollDirection: ScrollDirection,\r\n        scrollOffset: number,\r\n        scrollUpdateWasRequested: boolean\r\n      ) =>\r\n        ((this.props.onScroll: any): onScrollCallback)({\r\n          scrollDirection,\r\n          scrollOffset,\r\n          scrollUpdateWasRequested,\r\n        })\r\n    );\r\n\r\n    _callPropsCallbacks() {\r\n      if (typeof this.props.onItemsRendered === 'function') {\r\n        const { itemCount } = this.props;\r\n        if (itemCount > 0) {\r\n          const [\r\n            overscanStartIndex,\r\n            overscanStopIndex,\r\n            visibleStartIndex,\r\n            visibleStopIndex,\r\n          ] = this._getRangeToRender();\r\n          this._callOnItemsRendered(\r\n            overscanStartIndex,\r\n            overscanStopIndex,\r\n            visibleStartIndex,\r\n            visibleStopIndex\r\n          );\r\n        }\r\n      }\r\n\r\n      if (typeof this.props.onScroll === 'function') {\r\n        const {\r\n          scrollDirection,\r\n          scrollOffset,\r\n          scrollUpdateWasRequested,\r\n        } = this.state;\r\n        this._callOnScroll(\r\n          scrollDirection,\r\n          scrollOffset,\r\n          scrollUpdateWasRequested\r\n        );\r\n      }\r\n    }\r\n\r\n    // Lazily create and cache item styles while scrolling,\r\n    // So that pure component sCU will prevent re-renders.\r\n    // We maintain this cache, and pass a style prop rather than index,\r\n    // So that List can clear cached styles and force item re-render if necessary.\r\n    _getItemStyle: (index: number) => Object;\r\n    _getItemStyle = (index: number): Object => {\r\n      const { direction, itemSize, layout } = this.props;\r\n\r\n      const itemStyleCache = this._getItemStyleCache(\r\n        shouldResetStyleCacheOnItemSizeChange && itemSize,\r\n        shouldResetStyleCacheOnItemSizeChange && layout,\r\n        shouldResetStyleCacheOnItemSizeChange && direction\r\n      );\r\n\r\n      let style;\r\n      if (itemStyleCache.hasOwnProperty(index)) {\r\n        style = itemStyleCache[index];\r\n      } else {\r\n        const offset = getItemOffset(this.props, index, this._instanceProps);\r\n        const size = getItemSize(this.props, index, this._instanceProps);\r\n\r\n        // TODO Deprecate direction \"horizontal\"\r\n        const isHorizontal =\r\n          direction === 'horizontal' || layout === 'horizontal';\r\n\r\n        const isRtl = direction === 'rtl';\r\n        const offsetHorizontal = isHorizontal ? offset : 0;\r\n        itemStyleCache[index] = style = {\r\n          position: 'absolute',\r\n          left: isRtl ? undefined : offsetHorizontal,\r\n          right: isRtl ? offsetHorizontal : undefined,\r\n          top: !isHorizontal ? offset : 0,\r\n          height: !isHorizontal ? size : '100%',\r\n          width: isHorizontal ? size : '100%',\r\n        };\r\n      }\r\n\r\n      return style;\r\n    };\r\n\r\n    _getItemStyleCache: (_: any, __: any, ___: any) => ItemStyleCache;\r\n    _getItemStyleCache = memoizeOne((_: any, __: any, ___: any) => ({}));\r\n\r\n    _getRangeToRender(): [number, number, number, number] {\r\n      const { itemCount, overscanCount } = this.props;\r\n      const { isScrolling, scrollDirection, scrollOffset } = this.state;\r\n\r\n      if (itemCount === 0) {\r\n        return [0, 0, 0, 0];\r\n      }\r\n\r\n      const startIndex = getStartIndexForOffset(\r\n        this.props,\r\n        scrollOffset,\r\n        this._instanceProps\r\n      );\r\n      const stopIndex = getStopIndexForStartIndex(\r\n        this.props,\r\n        startIndex,\r\n        scrollOffset,\r\n        this._instanceProps\r\n      );\r\n\r\n      // Overscan by one item in each direction so that tab/focus works.\r\n      // If there isn't at least one extra item, tab loops back around.\r\n      const overscanBackward =\r\n        !isScrolling || scrollDirection === 'backward'\r\n          ? Math.max(1, overscanCount)\r\n          : 1;\r\n      const overscanForward =\r\n        !isScrolling || scrollDirection === 'forward'\r\n          ? Math.max(1, overscanCount)\r\n          : 1;\r\n\r\n      return [\r\n        Math.max(0, startIndex - overscanBackward),\r\n        Math.max(0, Math.min(itemCount - 1, stopIndex + overscanForward)),\r\n        startIndex,\r\n        stopIndex,\r\n      ];\r\n    }\r\n\r\n    _onScrollHorizontal = (event: ScrollEvent): void => {\r\n      const { clientWidth, scrollLeft, scrollWidth } = event.currentTarget;\r\n      this.setState(prevState => {\r\n        if (prevState.scrollOffset === scrollLeft) {\r\n          // Scroll position may have been updated by cDM/cDU,\r\n          // In which case we don't need to trigger another render,\r\n          // And we don't want to update state.isScrolling.\r\n          return null;\r\n        }\r\n\r\n        const { direction } = this.props;\r\n\r\n        let scrollOffset = scrollLeft;\r\n        if (direction === 'rtl') {\r\n          // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\r\n          // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\r\n          // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\r\n          // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\r\n          switch (getRTLOffsetType()) {\r\n            case 'negative':\r\n              scrollOffset = -scrollLeft;\r\n              break;\r\n            case 'positive-descending':\r\n              scrollOffset = scrollWidth - clientWidth - scrollLeft;\r\n              break;\r\n          }\r\n        }\r\n\r\n        // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\r\n        scrollOffset = Math.max(\r\n          0,\r\n          Math.min(scrollOffset, scrollWidth - clientWidth)\r\n        );\r\n\r\n        return {\r\n          isScrolling: true,\r\n          scrollDirection:\r\n            prevState.scrollOffset < scrollLeft ? 'forward' : 'backward',\r\n          scrollOffset,\r\n          scrollUpdateWasRequested: false,\r\n        };\r\n      }, this._resetIsScrollingDebounced);\r\n    };\r\n\r\n    _onScrollVertical = (event: ScrollEvent): void => {\r\n      const { clientHeight, scrollHeight, scrollTop } = event.currentTarget;\r\n      this.setState(prevState => {\r\n        if (prevState.scrollOffset === scrollTop) {\r\n          // Scroll position may have been updated by cDM/cDU,\r\n          // In which case we don't need to trigger another render,\r\n          // And we don't want to update state.isScrolling.\r\n          return null;\r\n        }\r\n\r\n        // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\r\n        const scrollOffset = Math.max(\r\n          0,\r\n          Math.min(scrollTop, scrollHeight - clientHeight)\r\n        );\r\n\r\n        return {\r\n          isScrolling: true,\r\n          scrollDirection:\r\n            prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\r\n          scrollOffset,\r\n          scrollUpdateWasRequested: false,\r\n        };\r\n      }, this._resetIsScrollingDebounced);\r\n    };\r\n\r\n    _outerRefSetter = (ref: any): void => {\r\n      const { outerRef } = this.props;\r\n\r\n      this._outerRef = ((ref: any): HTMLDivElement);\r\n\r\n      if (typeof outerRef === 'function') {\r\n        outerRef(ref);\r\n      } else if (\r\n        outerRef != null &&\r\n        typeof outerRef === 'object' &&\r\n        outerRef.hasOwnProperty('current')\r\n      ) {\r\n        outerRef.current = ref;\r\n      }\r\n    };\r\n\r\n    _resetIsScrollingDebounced = () => {\r\n      if (this._resetIsScrollingTimeoutId !== null) {\r\n        cancelTimeout(this._resetIsScrollingTimeoutId);\r\n      }\r\n\r\n      this._resetIsScrollingTimeoutId = requestTimeout(\r\n        this._resetIsScrolling,\r\n        IS_SCROLLING_DEBOUNCE_INTERVAL\r\n      );\r\n    };\r\n\r\n    _resetIsScrolling = () => {\r\n      this._resetIsScrollingTimeoutId = null;\r\n\r\n      this.setState({ isScrolling: false }, () => {\r\n        // Clear style cache after state update has been committed.\r\n        // This way we don't break pure sCU for items that don't use isScrolling param.\r\n        this._getItemStyleCache(-1, null);\r\n      });\r\n    };\r\n  };\r\n}\r\n\r\n// NOTE: I considered further wrapping individual items with a pure ListItem component.\r\n// This would avoid ever calling the render function for the same index more than once,\r\n// But it would also add the overhead of a lot of components/fibers.\r\n// I assume people already do this (render function returning a class component),\r\n// So my doing it would just unnecessarily double the wrappers.\r\n\r\nconst validateSharedProps = (\r\n  {\r\n    children,\r\n    direction,\r\n    height,\r\n    layout,\r\n    innerTagName,\r\n    outerTagName,\r\n    width,\r\n  }: Props<any>,\r\n  { instance }: State\r\n): void => {\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    if (innerTagName != null || outerTagName != null) {\r\n      if (devWarningsTagName && !devWarningsTagName.has(instance)) {\r\n        devWarningsTagName.add(instance);\r\n        console.warn(\r\n          'The innerTagName and outerTagName props have been deprecated. ' +\r\n            'Please use the innerElementType and outerElementType props instead.'\r\n        );\r\n      }\r\n    }\r\n\r\n    // TODO Deprecate direction \"horizontal\"\r\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\r\n\r\n    switch (direction) {\r\n      case 'horizontal':\r\n      case 'vertical':\r\n        if (devWarningsDirection && !devWarningsDirection.has(instance)) {\r\n          devWarningsDirection.add(instance);\r\n          console.warn(\r\n            'The direction prop should be either \"ltr\" (default) or \"rtl\". ' +\r\n              'Please use the layout prop to specify \"vertical\" (default) or \"horizontal\" orientation.'\r\n          );\r\n        }\r\n        break;\r\n      case 'ltr':\r\n      case 'rtl':\r\n        // Valid values\r\n        break;\r\n      default:\r\n        throw Error(\r\n          'An invalid \"direction\" prop has been specified. ' +\r\n            'Value should be either \"ltr\" or \"rtl\". ' +\r\n            `\"${direction}\" was specified.`\r\n        );\r\n    }\r\n\r\n    switch (layout) {\r\n      case 'horizontal':\r\n      case 'vertical':\r\n        // Valid values\r\n        break;\r\n      default:\r\n        throw Error(\r\n          'An invalid \"layout\" prop has been specified. ' +\r\n            'Value should be either \"horizontal\" or \"vertical\". ' +\r\n            `\"${layout}\" was specified.`\r\n        );\r\n    }\r\n\r\n    if (children == null) {\r\n      throw Error(\r\n        'An invalid \"children\" prop has been specified. ' +\r\n          'Value should be a React component. ' +\r\n          `\"${children === null ? 'null' : typeof children}\" was specified.`\r\n      );\r\n    }\r\n\r\n    if (isHorizontal && typeof width !== 'number') {\r\n      throw Error(\r\n        'An invalid \"width\" prop has been specified. ' +\r\n          'Horizontal lists must specify a number for width. ' +\r\n          `\"${width === null ? 'null' : typeof width}\" was specified.`\r\n      );\r\n    } else if (!isHorizontal && typeof height !== 'number') {\r\n      throw Error(\r\n        'An invalid \"height\" prop has been specified. ' +\r\n          'Vertical lists must specify a number for height. ' +\r\n          `\"${height === null ? 'null' : typeof height}\" was specified.`\r\n      );\r\n    }\r\n  }\r\n};\r\n","// @flow\r\n\r\nimport createListComponent from './createListComponent';\r\n\r\nimport type { Props, ScrollToAlign } from './createListComponent';\r\n\r\nconst DEFAULT_ESTIMATED_ITEM_SIZE = 50;\r\n\r\ntype VariableSizeProps = {|\r\n  estimatedItemSize: number,\r\n  ...Props<any>,\r\n|};\r\n\r\ntype itemSizeGetter = (index: number) => number;\r\n\r\ntype ItemMetadata = {|\r\n  offset: number,\r\n  size: number,\r\n|};\r\ntype InstanceProps = {|\r\n  itemMetadataMap: { [index: number]: ItemMetadata },\r\n  estimatedItemSize: number,\r\n  lastMeasuredIndex: number,\r\n|};\r\n\r\nconst getItemMetadata = (\r\n  props: Props<any>,\r\n  index: number,\r\n  instanceProps: InstanceProps\r\n): ItemMetadata => {\r\n  const { itemSize } = ((props: any): VariableSizeProps);\r\n  const { itemMetadataMap, lastMeasuredIndex } = instanceProps;\r\n\r\n  if (index > lastMeasuredIndex) {\r\n    let offset = 0;\r\n    if (lastMeasuredIndex >= 0) {\r\n      const itemMetadata = itemMetadataMap[lastMeasuredIndex];\r\n      offset = itemMetadata.offset + itemMetadata.size;\r\n    }\r\n\r\n    for (let i = lastMeasuredIndex + 1; i <= index; i++) {\r\n      let size = ((itemSize: any): itemSizeGetter)(i);\r\n\r\n      itemMetadataMap[i] = {\r\n        offset,\r\n        size,\r\n      };\r\n\r\n      offset += size;\r\n    }\r\n\r\n    instanceProps.lastMeasuredIndex = index;\r\n  }\r\n\r\n  return itemMetadataMap[index];\r\n};\r\n\r\nconst findNearestItem = (\r\n  props: Props<any>,\r\n  instanceProps: InstanceProps,\r\n  offset: number\r\n) => {\r\n  const { itemMetadataMap, lastMeasuredIndex } = instanceProps;\r\n\r\n  const lastMeasuredItemOffset =\r\n    lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\r\n\r\n  if (lastMeasuredItemOffset >= offset) {\r\n    // If we've already measured items within this range just use a binary search as it's faster.\r\n    return findNearestItemBinarySearch(\r\n      props,\r\n      instanceProps,\r\n      lastMeasuredIndex,\r\n      0,\r\n      offset\r\n    );\r\n  } else {\r\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\r\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\r\n    // The overall complexity for this approach is O(log n).\r\n    return findNearestItemExponentialSearch(\r\n      props,\r\n      instanceProps,\r\n      Math.max(0, lastMeasuredIndex),\r\n      offset\r\n    );\r\n  }\r\n};\r\n\r\nconst findNearestItemBinarySearch = (\r\n  props: Props<any>,\r\n  instanceProps: InstanceProps,\r\n  high: number,\r\n  low: number,\r\n  offset: number\r\n): number => {\r\n  while (low <= high) {\r\n    const middle = low + Math.floor((high - low) / 2);\r\n    const currentOffset = getItemMetadata(props, middle, instanceProps).offset;\r\n\r\n    if (currentOffset === offset) {\r\n      return middle;\r\n    } else if (currentOffset < offset) {\r\n      low = middle + 1;\r\n    } else if (currentOffset > offset) {\r\n      high = middle - 1;\r\n    }\r\n  }\r\n\r\n  if (low > 0) {\r\n    return low - 1;\r\n  } else {\r\n    return 0;\r\n  }\r\n};\r\n\r\nconst findNearestItemExponentialSearch = (\r\n  props: Props<any>,\r\n  instanceProps: InstanceProps,\r\n  index: number,\r\n  offset: number\r\n): number => {\r\n  const { itemCount } = props;\r\n  let interval = 1;\r\n\r\n  while (\r\n    index < itemCount &&\r\n    getItemMetadata(props, index, instanceProps).offset < offset\r\n  ) {\r\n    index += interval;\r\n    interval *= 2;\r\n  }\r\n\r\n  return findNearestItemBinarySearch(\r\n    props,\r\n    instanceProps,\r\n    Math.min(index, itemCount - 1),\r\n    Math.floor(index / 2),\r\n    offset\r\n  );\r\n};\r\n\r\nconst getEstimatedTotalSize = (\r\n  { itemCount }: Props<any>,\r\n  { itemMetadataMap, estimatedItemSize, lastMeasuredIndex }: InstanceProps\r\n) => {\r\n  let totalSizeOfMeasuredItems = 0;\r\n\r\n  // Edge case check for when the number of items decreases while a scroll is in progress.\r\n  // https://github.com/bvaughn/react-window/pull/138\r\n  if (lastMeasuredIndex >= itemCount) {\r\n    lastMeasuredIndex = itemCount - 1;\r\n  }\r\n\r\n  if (lastMeasuredIndex >= 0) {\r\n    const itemMetadata = itemMetadataMap[lastMeasuredIndex];\r\n    totalSizeOfMeasuredItems = itemMetadata.offset + itemMetadata.size;\r\n  }\r\n\r\n  const numUnmeasuredItems = itemCount - lastMeasuredIndex - 1;\r\n  const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;\r\n\r\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;\r\n};\r\n\r\nconst VariableSizeList = createListComponent({\r\n  getItemOffset: (\r\n    props: Props<any>,\r\n    index: number,\r\n    instanceProps: InstanceProps\r\n  ): number => getItemMetadata(props, index, instanceProps).offset,\r\n\r\n  getItemSize: (\r\n    props: Props<any>,\r\n    index: number,\r\n    instanceProps: InstanceProps\r\n  ): number => instanceProps.itemMetadataMap[index].size,\r\n\r\n  getEstimatedTotalSize,\r\n\r\n  getOffsetForIndexAndAlignment: (\r\n    props: Props<any>,\r\n    index: number,\r\n    align: ScrollToAlign,\r\n    scrollOffset: number,\r\n    instanceProps: InstanceProps,\r\n    scrollbarSize: number\r\n  ): number => {\r\n    const { direction, height, layout, width } = props;\r\n\r\n    // TODO Deprecate direction \"horizontal\"\r\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\r\n    const size = (((isHorizontal ? width : height): any): number);\r\n    const itemMetadata = getItemMetadata(props, index, instanceProps);\r\n\r\n    // Get estimated total size after ItemMetadata is computed,\r\n    // To ensure it reflects actual measurements instead of just estimates.\r\n    const estimatedTotalSize = getEstimatedTotalSize(props, instanceProps);\r\n\r\n    const maxOffset = Math.max(\r\n      0,\r\n      Math.min(estimatedTotalSize - size, itemMetadata.offset)\r\n    );\r\n    const minOffset = Math.max(\r\n      0,\r\n      itemMetadata.offset - size + itemMetadata.size + scrollbarSize\r\n    );\r\n\r\n    if (align === 'smart') {\r\n      if (\r\n        scrollOffset >= minOffset - size &&\r\n        scrollOffset <= maxOffset + size\r\n      ) {\r\n        align = 'auto';\r\n      } else {\r\n        align = 'center';\r\n      }\r\n    }\r\n\r\n    switch (align) {\r\n      case 'start':\r\n        return maxOffset;\r\n      case 'end':\r\n        return minOffset;\r\n      case 'center':\r\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\r\n      case 'auto':\r\n      default:\r\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\r\n          return scrollOffset;\r\n        } else if (scrollOffset < minOffset) {\r\n          return minOffset;\r\n        } else {\r\n          return maxOffset;\r\n        }\r\n    }\r\n  },\r\n\r\n  getStartIndexForOffset: (\r\n    props: Props<any>,\r\n    offset: number,\r\n    instanceProps: InstanceProps\r\n  ): number => findNearestItem(props, instanceProps, offset),\r\n\r\n  getStopIndexForStartIndex: (\r\n    props: Props<any>,\r\n    startIndex: number,\r\n    scrollOffset: number,\r\n    instanceProps: InstanceProps\r\n  ): number => {\r\n    const { direction, height, itemCount, layout, width } = props;\r\n\r\n    // TODO Deprecate direction \"horizontal\"\r\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\r\n    const size = (((isHorizontal ? width : height): any): number);\r\n    const itemMetadata = getItemMetadata(props, startIndex, instanceProps);\r\n    const maxOffset = scrollOffset + size;\r\n\r\n    let offset = itemMetadata.offset + itemMetadata.size;\r\n    let stopIndex = startIndex;\r\n\r\n    while (stopIndex < itemCount - 1 && offset < maxOffset) {\r\n      stopIndex++;\r\n      offset += getItemMetadata(props, stopIndex, instanceProps).size;\r\n    }\r\n\r\n    return stopIndex;\r\n  },\r\n\r\n  initInstanceProps(props: Props<any>, instance: any): InstanceProps {\r\n    const { estimatedItemSize } = ((props: any): VariableSizeProps);\r\n\r\n    const instanceProps = {\r\n      itemMetadataMap: {},\r\n      estimatedItemSize: estimatedItemSize || DEFAULT_ESTIMATED_ITEM_SIZE,\r\n      lastMeasuredIndex: -1,\r\n    };\r\n\r\n    instance.resetAfterIndex = (\r\n      index: number,\r\n      shouldForceUpdate?: boolean = true\r\n    ) => {\r\n      instanceProps.lastMeasuredIndex = Math.min(\r\n        instanceProps.lastMeasuredIndex,\r\n        index - 1\r\n      );\r\n\r\n      // We could potentially optimize further by only evicting styles after this index,\r\n      // But since styles are only cached while scrolling is in progress-\r\n      // It seems an unnecessary optimization.\r\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\r\n      instance._getItemStyleCache(-1);\r\n\r\n      if (shouldForceUpdate) {\r\n        instance.forceUpdate();\r\n      }\r\n    };\r\n\r\n    return instanceProps;\r\n  },\r\n\r\n  shouldResetStyleCacheOnItemSizeChange: false,\r\n\r\n  validateProps: ({ itemSize }: Props<any>): void => {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      if (typeof itemSize !== 'function') {\r\n        throw Error(\r\n          'An invalid \"itemSize\" prop has been specified. ' +\r\n            'Value should be a function. ' +\r\n            `\"${itemSize === null ? 'null' : typeof itemSize}\" was specified.`\r\n        );\r\n      }\r\n    }\r\n  },\r\n});\r\n\r\nexport default VariableSizeList;\r\n","// @flow\r\n\r\nimport createGridComponent from './createGridComponent';\r\n\r\nimport type { Props, ScrollToAlign } from './createGridComponent';\r\n\r\nconst FixedSizeGrid = createGridComponent({\r\n  getColumnOffset: ({ columnWidth }: Props<any>, index: number): number =>\r\n    index * ((columnWidth: any): number),\r\n\r\n  getColumnWidth: ({ columnWidth }: Props<any>, index: number): number =>\r\n    ((columnWidth: any): number),\r\n\r\n  getRowOffset: ({ rowHeight }: Props<any>, index: number): number =>\r\n    index * ((rowHeight: any): number),\r\n\r\n  getRowHeight: ({ rowHeight }: Props<any>, index: number): number =>\r\n    ((rowHeight: any): number),\r\n\r\n  getEstimatedTotalHeight: ({ rowCount, rowHeight }: Props<any>) =>\r\n    ((rowHeight: any): number) * rowCount,\r\n\r\n  getEstimatedTotalWidth: ({ columnCount, columnWidth }: Props<any>) =>\r\n    ((columnWidth: any): number) * columnCount,\r\n\r\n  getOffsetForColumnAndAlignment: (\r\n    { columnCount, columnWidth, width }: Props<any>,\r\n    columnIndex: number,\r\n    align: ScrollToAlign,\r\n    scrollLeft: number,\r\n    instanceProps: typeof undefined,\r\n    scrollbarSize: number\r\n  ): number => {\r\n    const lastColumnOffset = Math.max(\r\n      0,\r\n      columnCount * ((columnWidth: any): number) - width\r\n    );\r\n    const maxOffset = Math.min(\r\n      lastColumnOffset,\r\n      columnIndex * ((columnWidth: any): number)\r\n    );\r\n    const minOffset = Math.max(\r\n      0,\r\n      columnIndex * ((columnWidth: any): number) -\r\n        width +\r\n        scrollbarSize +\r\n        ((columnWidth: any): number)\r\n    );\r\n\r\n    if (align === 'smart') {\r\n      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {\r\n        align = 'auto';\r\n      } else {\r\n        align = 'center';\r\n      }\r\n    }\r\n\r\n    switch (align) {\r\n      case 'start':\r\n        return maxOffset;\r\n      case 'end':\r\n        return minOffset;\r\n      case 'center':\r\n        // \"Centered\" offset is usually the average of the min and max.\r\n        // But near the edges of the list, this doesn't hold true.\r\n        const middleOffset = Math.round(\r\n          minOffset + (maxOffset - minOffset) / 2\r\n        );\r\n        if (middleOffset < Math.ceil(width / 2)) {\r\n          return 0; // near the beginning\r\n        } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {\r\n          return lastColumnOffset; // near the end\r\n        } else {\r\n          return middleOffset;\r\n        }\r\n      case 'auto':\r\n      default:\r\n        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {\r\n          return scrollLeft;\r\n        } else if (minOffset > maxOffset) {\r\n          // Because we only take into account the scrollbar size when calculating minOffset\r\n          // this value can be larger than maxOffset when at the end of the list\r\n          return minOffset;\r\n        } else if (scrollLeft < minOffset) {\r\n          return minOffset;\r\n        } else {\r\n          return maxOffset;\r\n        }\r\n    }\r\n  },\r\n\r\n  getOffsetForRowAndAlignment: (\r\n    { rowHeight, height, rowCount }: Props<any>,\r\n    rowIndex: number,\r\n    align: ScrollToAlign,\r\n    scrollTop: number,\r\n    instanceProps: typeof undefined,\r\n    scrollbarSize: number\r\n  ): number => {\r\n    const lastRowOffset = Math.max(\r\n      0,\r\n      rowCount * ((rowHeight: any): number) - height\r\n    );\r\n    const maxOffset = Math.min(\r\n      lastRowOffset,\r\n      rowIndex * ((rowHeight: any): number)\r\n    );\r\n    const minOffset = Math.max(\r\n      0,\r\n      rowIndex * ((rowHeight: any): number) -\r\n        height +\r\n        scrollbarSize +\r\n        ((rowHeight: any): number)\r\n    );\r\n\r\n    if (align === 'smart') {\r\n      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {\r\n        align = 'auto';\r\n      } else {\r\n        align = 'center';\r\n      }\r\n    }\r\n\r\n    switch (align) {\r\n      case 'start':\r\n        return maxOffset;\r\n      case 'end':\r\n        return minOffset;\r\n      case 'center':\r\n        // \"Centered\" offset is usually the average of the min and max.\r\n        // But near the edges of the list, this doesn't hold true.\r\n        const middleOffset = Math.round(\r\n          minOffset + (maxOffset - minOffset) / 2\r\n        );\r\n        if (middleOffset < Math.ceil(height / 2)) {\r\n          return 0; // near the beginning\r\n        } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {\r\n          return lastRowOffset; // near the end\r\n        } else {\r\n          return middleOffset;\r\n        }\r\n      case 'auto':\r\n      default:\r\n        if (scrollTop >= minOffset && scrollTop <= maxOffset) {\r\n          return scrollTop;\r\n        } else if (minOffset > maxOffset) {\r\n          // Because we only take into account the scrollbar size when calculating minOffset\r\n          // this value can be larger than maxOffset when at the end of the list\r\n          return minOffset;\r\n        } else if (scrollTop < minOffset) {\r\n          return minOffset;\r\n        } else {\r\n          return maxOffset;\r\n        }\r\n    }\r\n  },\r\n\r\n  getColumnStartIndexForOffset: (\r\n    { columnWidth, columnCount }: Props<any>,\r\n    scrollLeft: number\r\n  ): number =>\r\n    Math.max(\r\n      0,\r\n      Math.min(\r\n        columnCount - 1,\r\n        Math.floor(scrollLeft / ((columnWidth: any): number))\r\n      )\r\n    ),\r\n\r\n  getColumnStopIndexForStartIndex: (\r\n    { columnWidth, columnCount, width }: Props<any>,\r\n    startIndex: number,\r\n    scrollLeft: number\r\n  ): number => {\r\n    const left = startIndex * ((columnWidth: any): number);\r\n    const numVisibleColumns = Math.ceil(\r\n      (width + scrollLeft - left) / ((columnWidth: any): number)\r\n    );\r\n    return Math.max(\r\n      0,\r\n      Math.min(\r\n        columnCount - 1,\r\n        startIndex + numVisibleColumns - 1 // -1 is because stop index is inclusive\r\n      )\r\n    );\r\n  },\r\n\r\n  getRowStartIndexForOffset: (\r\n    { rowHeight, rowCount }: Props<any>,\r\n    scrollTop: number\r\n  ): number =>\r\n    Math.max(\r\n      0,\r\n      Math.min(rowCount - 1, Math.floor(scrollTop / ((rowHeight: any): number)))\r\n    ),\r\n\r\n  getRowStopIndexForStartIndex: (\r\n    { rowHeight, rowCount, height }: Props<any>,\r\n    startIndex: number,\r\n    scrollTop: number\r\n  ): number => {\r\n    const top = startIndex * ((rowHeight: any): number);\r\n    const numVisibleRows = Math.ceil(\r\n      (height + scrollTop - top) / ((rowHeight: any): number)\r\n    );\r\n    return Math.max(\r\n      0,\r\n      Math.min(\r\n        rowCount - 1,\r\n        startIndex + numVisibleRows - 1 // -1 is because stop index is inclusive\r\n      )\r\n    );\r\n  },\r\n\r\n  initInstanceProps(props: Props<any>): any {\r\n    // Noop\r\n  },\r\n\r\n  shouldResetStyleCacheOnItemSizeChange: true,\r\n\r\n  validateProps: ({ columnWidth, rowHeight }: Props<any>): void => {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      if (typeof columnWidth !== 'number') {\r\n        throw Error(\r\n          'An invalid \"columnWidth\" prop has been specified. ' +\r\n            'Value should be a number. ' +\r\n            `\"${\r\n              columnWidth === null ? 'null' : typeof columnWidth\r\n            }\" was specified.`\r\n        );\r\n      }\r\n\r\n      if (typeof rowHeight !== 'number') {\r\n        throw Error(\r\n          'An invalid \"rowHeight\" prop has been specified. ' +\r\n            'Value should be a number. ' +\r\n            `\"${rowHeight === null ? 'null' : typeof rowHeight}\" was specified.`\r\n        );\r\n      }\r\n    }\r\n  },\r\n});\r\n\r\nexport default FixedSizeGrid;\r\n","// @flow\r\n\r\nimport createListComponent from './createListComponent';\r\n\r\nimport type { Props, ScrollToAlign } from './createListComponent';\r\n\r\ntype InstanceProps = any;\r\n\r\nconst FixedSizeList = createListComponent({\r\n  getItemOffset: ({ itemSize }: Props<any>, index: number): number =>\r\n    index * ((itemSize: any): number),\r\n\r\n  getItemSize: ({ itemSize }: Props<any>, index: number): number =>\r\n    ((itemSize: any): number),\r\n\r\n  getEstimatedTotalSize: ({ itemCount, itemSize }: Props<any>) =>\r\n    ((itemSize: any): number) * itemCount,\r\n\r\n  getOffsetForIndexAndAlignment: (\r\n    { direction, height, itemCount, itemSize, layout, width }: Props<any>,\r\n    index: number,\r\n    align: ScrollToAlign,\r\n    scrollOffset: number,\r\n    instanceProps: InstanceProps,\r\n    scrollbarSize: number\r\n  ): number => {\r\n    // TODO Deprecate direction \"horizontal\"\r\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\r\n    const size = (((isHorizontal ? width : height): any): number);\r\n    const lastItemOffset = Math.max(\r\n      0,\r\n      itemCount * ((itemSize: any): number) - size\r\n    );\r\n    const maxOffset = Math.min(\r\n      lastItemOffset,\r\n      index * ((itemSize: any): number)\r\n    );\r\n    const minOffset = Math.max(\r\n      0,\r\n      index * ((itemSize: any): number) -\r\n        size +\r\n        ((itemSize: any): number) +\r\n        scrollbarSize\r\n    );\r\n\r\n    if (align === 'smart') {\r\n      if (\r\n        scrollOffset >= minOffset - size &&\r\n        scrollOffset <= maxOffset + size\r\n      ) {\r\n        align = 'auto';\r\n      } else {\r\n        align = 'center';\r\n      }\r\n    }\r\n\r\n    switch (align) {\r\n      case 'start':\r\n        return maxOffset;\r\n      case 'end':\r\n        return minOffset;\r\n      case 'center': {\r\n        // \"Centered\" offset is usually the average of the min and max.\r\n        // But near the edges of the list, this doesn't hold true.\r\n        const middleOffset = Math.round(\r\n          minOffset + (maxOffset - minOffset) / 2\r\n        );\r\n        if (middleOffset < Math.ceil(size / 2)) {\r\n          return 0; // near the beginning\r\n        } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {\r\n          return lastItemOffset; // near the end\r\n        } else {\r\n          return middleOffset;\r\n        }\r\n      }\r\n      case 'auto':\r\n      default:\r\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\r\n          return scrollOffset;\r\n        } else if (scrollOffset < minOffset) {\r\n          return minOffset;\r\n        } else {\r\n          return maxOffset;\r\n        }\r\n    }\r\n  },\r\n\r\n  getStartIndexForOffset: (\r\n    { itemCount, itemSize }: Props<any>,\r\n    offset: number\r\n  ): number =>\r\n    Math.max(\r\n      0,\r\n      Math.min(itemCount - 1, Math.floor(offset / ((itemSize: any): number)))\r\n    ),\r\n\r\n  getStopIndexForStartIndex: (\r\n    { direction, height, itemCount, itemSize, layout, width }: Props<any>,\r\n    startIndex: number,\r\n    scrollOffset: number\r\n  ): number => {\r\n    // TODO Deprecate direction \"horizontal\"\r\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\r\n    const offset = startIndex * ((itemSize: any): number);\r\n    const size = (((isHorizontal ? width : height): any): number);\r\n    const numVisibleItems = Math.ceil(\r\n      (size + scrollOffset - offset) / ((itemSize: any): number)\r\n    );\r\n    return Math.max(\r\n      0,\r\n      Math.min(\r\n        itemCount - 1,\r\n        startIndex + numVisibleItems - 1 // -1 is because stop index is inclusive\r\n      )\r\n    );\r\n  },\r\n\r\n  initInstanceProps(props: Props<any>): any {\r\n    // Noop\r\n  },\r\n\r\n  shouldResetStyleCacheOnItemSizeChange: true,\r\n\r\n  validateProps: ({ itemSize }: Props<any>): void => {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      if (typeof itemSize !== 'number') {\r\n        throw Error(\r\n          'An invalid \"itemSize\" prop has been specified. ' +\r\n            'Value should be a number. ' +\r\n            `\"${itemSize === null ? 'null' : typeof itemSize}\" was specified.`\r\n        );\r\n      }\r\n    }\r\n  },\r\n});\r\n\r\nexport default FixedSizeList;\r\n","export default function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}","// @flow\r\n\r\n// Pulled from react-compat\r\n// https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349\r\nexport default function shallowDiffers(prev: Object, next: Object): boolean {\r\n  for (let attribute in prev) {\r\n    if (!(attribute in next)) {\r\n      return true;\r\n    }\r\n  }\r\n  for (let attribute in next) {\r\n    if (prev[attribute] !== next[attribute]) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n","// @flow\r\n\r\nimport shallowDiffers from './shallowDiffers';\r\n\r\n// Custom comparison function for React.memo().\r\n// It knows to compare individual style props and ignore the wrapper object.\r\n// See https://reactjs.org/docs/react-api.html#reactmemo\r\nexport default function areEqual(\r\n  prevProps: Object,\r\n  nextProps: Object\r\n): boolean {\r\n  const { style: prevStyle, ...prevRest } = prevProps;\r\n  const { style: nextStyle, ...nextRest } = nextProps;\r\n\r\n  return (\r\n    !shallowDiffers(prevStyle, nextStyle) && !shallowDiffers(prevRest, nextRest)\r\n  );\r\n}\r\n","// @flow\r\n\r\nimport areEqual from './areEqual';\r\nimport shallowDiffers from './shallowDiffers';\r\n\r\n// Custom shouldComponentUpdate for class components.\r\n// It knows to compare individual style props and ignore the wrapper object.\r\n// See https://reactjs.org/docs/react-component.html#shouldcomponentupdate\r\nexport default function shouldComponentUpdate(\r\n  nextProps: Object,\r\n  nextState: Object\r\n): boolean {\r\n  return (\r\n    !areEqual(this.props, nextProps) || shallowDiffers(this.state, nextState)\r\n  );\r\n}\r\n"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","this","_assertThisInitialized","self","ReferenceError","_setPrototypeOf","o","p","setPrototypeOf","__proto__","_inheritsLoose","subClass","superClass","create","constructor","safeIsNaN","Number","isNaN","value","areInputsEqual","newInputs","lastInputs","first","second","memoizeOne","resultFn","isEqual","lastThis","lastResult","lastArgs","calledOnce","newArgs","_i","now","performance","Date","cancelTimeout","timeoutID","cancelAnimationFrame","id","requestTimeout","callback","delay","start","requestAnimationFrame","tick","size","getScrollbarSize","recalculate","div","document","createElement","style","width","height","overflow","body","appendChild","offsetWidth","clientWidth","removeChild","cachedRTLResult","getRTLOffsetType","outerDiv","outerStyle","direction","innerDiv","innerStyle","scrollLeft","defaultItemKey","columnIndex","data","rowIndex","createGridComponent","getColumnOffset","getColumnStartIndexForOffset","getColumnStopIndexForStartIndex","getColumnWidth","getEstimatedTotalHeight","getEstimatedTotalWidth","getOffsetForColumnAndAlignment","getOffsetForRowAndAlignment","getRowHeight","getRowOffset","getRowStartIndexForOffset","getRowStopIndexForStartIndex","initInstanceProps","shouldResetStyleCacheOnItemSizeChange","validateProps","props","_instanceProps","_this","_resetIsScrollingTimeoutId","_outerRef","state","instance","isScrolling","horizontalScrollDirection","initialScrollLeft","scrollTop","initialScrollTop","scrollUpdateWasRequested","verticalScrollDirection","_callOnItemsRendered","overscanColumnStartIndex","overscanColumnStopIndex","overscanRowStartIndex","overscanRowStopIndex","visibleColumnStartIndex","visibleColumnStopIndex","visibleRowStartIndex","visibleRowStopIndex","onItemsRendered","_callOnScroll","onScroll","_getItemStyle","columnWidth","rowHeight","itemStyleCache","_getItemStyleCache","offset","isRtl","position","left","undefined","right","top","_","__","___","_onScroll","event","currentTarget","clientHeight","scrollHeight","scrollWidth","setState","prevState","calculatedScrollLeft","Math","max","min","calculatedScrollTop","_resetIsScrollingDebounced","_outerRefSetter","ref","outerRef","current","_resetIsScrolling","getDerivedStateFromProps","nextProps","validateSharedProps","scrollTo","scrollToItem","align","columnCount","rowCount","scrollbarSize","estimatedTotalHeight","horizontalScrollbarSize","verticalScrollbarSize","componentDidMount","_callPropsCallbacks","componentDidUpdate","componentWillUnmount","render","children","className","innerRef","innerElementType","innerTagName","itemData","itemKey","outerElementType","outerTagName","useIsScrolling","disableColVirtualized","disableRowVirtualized","_getHorizontalRangeToRender","columnStartIndex","columnStopIndex","_getVerticalRangeToRender","rowStartIndex","rowStopIndex","items","push","estimatedTotalWidth","WebkitOverflowScrolling","willChange","pointerEvents","overscanColumnCount","overscanColumnsCount","overscanCount","overscanCountResolved","startIndex","stopIndex","overscanBackward","overscanForward","overscanRowCount","overscanRowsCount","PureComponent","defaultProps","rowMetadataMap","estimatedRowHeight","lastMeasuredRowIndex","totalSizeOfMeasuredRows","itemMetadata","columnMetadataMap","estimatedColumnWidth","lastMeasuredColumnIndex","getItemMetadata","itemType","index","instanceProps","itemMetadataMap","itemSize","lastMeasuredIndex","findNearestItem","findNearestItemBinarySearch","findNearestItemExponentialSearch","high","low","middle","floor","currentOffset","itemCount","interval","getOffsetForIndexAndAlignment","scrollOffset","estimatedTotalSize","maxOffset","minOffset","round","VariableSizeGrid","resetAfterColumnIndex","shouldForceUpdate","resetAfterIndices","resetAfterRowIndex","forceUpdate","createListComponent","getItemOffset","getEstimatedTotalSize","getItemSize","getStartIndexForOffset","getStopIndexForStartIndex","scrollDirection","initialScrollOffset","overscanStartIndex","overscanStopIndex","visibleStartIndex","visibleStopIndex","layout","isHorizontal","offsetHorizontal","_onScrollHorizontal","_onScrollVertical","_getRangeToRender","estimatedItemSize","totalSizeOfMeasuredItems","VariableSizeList","resetAfterIndex","FixedSizeGrid","lastColumnOffset","middleOffset","ceil","lastRowOffset","numVisibleColumns","numVisibleRows","FixedSizeList","lastItemOffset","numVisibleItems","_objectWithoutPropertiesLoose","excluded","sourceKeys","keys","indexOf","shallowDiffers","prev","next","attribute","areEqual","prevProps","prevStyle","prevRest","nextStyle","nextRest","nextState"],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/react-window/dist/index.cjs.js b/node_modules/react-window/dist/index.cjs.js
index 7e441c2..e54d3dc 100644
--- a/node_modules/react-window/dist/index.cjs.js
+++ b/node_modules/react-window/dist/index.cjs.js
@@ -5,8 +5,8 @@ Object.defineProperty(exports, '__esModule', { value: true });
 function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }
 
 var _extends = _interopDefault(require('@babel/runtime/helpers/extends'));
-var _inheritsLoose = _interopDefault(require('@babel/runtime/helpers/inheritsLoose'));
 var _assertThisInitialized = _interopDefault(require('@babel/runtime/helpers/assertThisInitialized'));
+var _inheritsLoose = _interopDefault(require('@babel/runtime/helpers/inheritsLoose'));
 var memoizeOne = _interopDefault(require('memoize-one'));
 var react = require('react');
 var _objectWithoutPropertiesLoose = _interopDefault(require('@babel/runtime/helpers/objectWithoutPropertiesLoose'));
@@ -121,20 +121,14 @@ var devWarningsTagName = null;
 
 if (process.env.NODE_ENV !== 'production') {
   if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {
-    devWarningsOverscanCount =
-    /*#__PURE__*/
-    new WeakSet();
-    devWarningsOverscanRowsColumnsCount =
-    /*#__PURE__*/
-    new WeakSet();
-    devWarningsTagName =
-    /*#__PURE__*/
-    new WeakSet();
+    devWarningsOverscanCount = /*#__PURE__*/new WeakSet();
+    devWarningsOverscanRowsColumnsCount = /*#__PURE__*/new WeakSet();
+    devWarningsTagName = /*#__PURE__*/new WeakSet();
   }
 }
 
 function createGridComponent(_ref2) {
-  var _class, _temp;
+  var _class;
 
   var getColumnOffset = _ref2.getColumnOffset,
       getColumnStartIndexForOffset = _ref2.getColumnStartIndexForOffset,
@@ -151,9 +145,7 @@ function createGridComponent(_ref2) {
       initInstanceProps = _ref2.initInstanceProps,
       shouldResetStyleCacheOnItemSizeChange = _ref2.shouldResetStyleCacheOnItemSizeChange,
       validateProps = _ref2.validateProps;
-  return _temp = _class =
-  /*#__PURE__*/
-  function (_PureComponent) {
+  return _class = /*#__PURE__*/function (_PureComponent) {
     _inheritsLoose(Grid, _PureComponent);
 
     // Always use explicit constructor for React components.
@@ -163,11 +155,11 @@ function createGridComponent(_ref2) {
       var _this;
 
       _this = _PureComponent.call(this, props) || this;
-      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_assertThisInitialized(_this)));
+      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_this));
       _this._resetIsScrollingTimeoutId = null;
       _this._outerRef = void 0;
       _this.state = {
-        instance: _assertThisInitialized(_assertThisInitialized(_this)),
+        instance: _assertThisInitialized(_this),
         isScrolling: false,
         horizontalScrollDirection: 'forward',
         scrollLeft: typeof _this.props.initialScrollLeft === 'number' ? _this.props.initialScrollLeft : 0,
@@ -481,7 +473,9 @@ function createGridComponent(_ref2) {
           rowCount = _this$props4.rowCount,
           style = _this$props4.style,
           useIsScrolling = _this$props4.useIsScrolling,
-          width = _this$props4.width;
+          width = _this$props4.width,
+          disableColVirtualized = _this$props4.disableColVirtualized,
+          disableRowVirtualized = _this$props4.disableRowVirtualized;
       var isScrolling = this.state.isScrolling;
 
       var _this$_getHorizontalR = this._getHorizontalRangeToRender(),
@@ -492,6 +486,8 @@ function createGridComponent(_ref2) {
           rowStartIndex = _this$_getVerticalRan[0],
           rowStopIndex = _this$_getVerticalRan[1];
 
+      if (disableColVirtualized) columnStartIndex = 0;
+      if (disableRowVirtualized) rowStartIndex = 0;
       var items = [];
 
       if (columnCount > 0 && rowCount) {
@@ -576,11 +572,11 @@ function createGridComponent(_ref2) {
 
         this._callOnScroll(_scrollLeft, _scrollTop, _horizontalScrollDirection, _verticalScrollDirection, _scrollUpdateWasRequested);
       }
-    }; // Lazily create and cache item styles while scrolling,
+    } // Lazily create and cache item styles while scrolling,
     // So that pure component sCU will prevent re-renders.
     // We maintain this cache, and pass a style prop rather than index,
     // So that List can clear cached styles and force item re-render if necessary.
-
+    ;
 
     _proto._getHorizontalRangeToRender = function _getHorizontalRangeToRender() {
       var _this$props6 = this.props,
@@ -639,7 +635,7 @@ function createGridComponent(_ref2) {
     direction: 'ltr',
     itemData: undefined,
     useIsScrolling: false
-  }, _temp;
+  }, _class;
 }
 
 var validateSharedProps = function validateSharedProps(_ref5, _ref6) {
@@ -887,9 +883,7 @@ var getOffsetForIndexAndAlignment = function getOffsetForIndexAndAlignment(itemT
   }
 };
 
-var VariableSizeGrid =
-/*#__PURE__*/
-createGridComponent({
+var VariableSizeGrid = /*#__PURE__*/createGridComponent({
   getColumnOffset: function getColumnOffset(props, index, instanceProps) {
     return getItemMetadata('column', props, index, instanceProps).offset;
   },
@@ -1036,17 +1030,13 @@ var devWarningsTagName$1 = null;
 
 if (process.env.NODE_ENV !== 'production') {
   if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {
-    devWarningsDirection =
-    /*#__PURE__*/
-    new WeakSet();
-    devWarningsTagName$1 =
-    /*#__PURE__*/
-    new WeakSet();
+    devWarningsDirection = /*#__PURE__*/new WeakSet();
+    devWarningsTagName$1 = /*#__PURE__*/new WeakSet();
   }
 }
 
 function createListComponent(_ref) {
-  var _class, _temp;
+  var _class;
 
   var getItemOffset = _ref.getItemOffset,
       getEstimatedTotalSize = _ref.getEstimatedTotalSize,
@@ -1057,9 +1047,7 @@ function createListComponent(_ref) {
       initInstanceProps = _ref.initInstanceProps,
       shouldResetStyleCacheOnItemSizeChange = _ref.shouldResetStyleCacheOnItemSizeChange,
       validateProps = _ref.validateProps;
-  return _temp = _class =
-  /*#__PURE__*/
-  function (_PureComponent) {
+  return _class = /*#__PURE__*/function (_PureComponent) {
     _inheritsLoose(List, _PureComponent);
 
     // Always use explicit constructor for React components.
@@ -1069,11 +1057,11 @@ function createListComponent(_ref) {
       var _this;
 
       _this = _PureComponent.call(this, props) || this;
-      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_assertThisInitialized(_this)));
+      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_this));
       _this._outerRef = void 0;
       _this._resetIsScrollingTimeoutId = null;
       _this.state = {
-        instance: _assertThisInitialized(_assertThisInitialized(_this)),
+        instance: _assertThisInitialized(_this),
         isScrolling: false,
         scrollDirection: 'forward',
         scrollOffset: typeof _this.props.initialScrollOffset === 'number' ? _this.props.initialScrollOffset : 0,
@@ -1267,17 +1255,34 @@ function createListComponent(_ref) {
         align = 'auto';
       }
 
-      var itemCount = this.props.itemCount;
+      var _this$props2 = this.props,
+          itemCount = _this$props2.itemCount,
+          layout = _this$props2.layout;
       var scrollOffset = this.state.scrollOffset;
-      index = Math.max(0, Math.min(index, itemCount - 1));
-      this.scrollTo(getOffsetForIndexAndAlignment(this.props, index, align, scrollOffset, this._instanceProps));
+      index = Math.max(0, Math.min(index, itemCount - 1)); // The scrollbar size should be considered when scrolling an item into view, to ensure it's fully visible.
+      // But we only need to account for its size when it's actually visible.
+      // This is an edge case for lists; normally they only scroll in the dominant direction.
+
+      var scrollbarSize = 0;
+
+      if (this._outerRef) {
+        var outerRef = this._outerRef;
+
+        if (layout === 'vertical') {
+          scrollbarSize = outerRef.scrollWidth > outerRef.clientWidth ? getScrollbarSize() : 0;
+        } else {
+          scrollbarSize = outerRef.scrollHeight > outerRef.clientHeight ? getScrollbarSize() : 0;
+        }
+      }
+
+      this.scrollTo(getOffsetForIndexAndAlignment(this.props, index, align, scrollOffset, this._instanceProps, scrollbarSize));
     };
 
     _proto.componentDidMount = function componentDidMount() {
-      var _this$props2 = this.props,
-          direction = _this$props2.direction,
-          initialScrollOffset = _this$props2.initialScrollOffset,
-          layout = _this$props2.layout;
+      var _this$props3 = this.props,
+          direction = _this$props3.direction,
+          initialScrollOffset = _this$props3.initialScrollOffset,
+          layout = _this$props3.layout;
 
       if (typeof initialScrollOffset === 'number' && this._outerRef != null) {
         var outerRef = this._outerRef; // TODO Deprecate direction "horizontal"
@@ -1293,9 +1298,9 @@ function createListComponent(_ref) {
     };
 
     _proto.componentDidUpdate = function componentDidUpdate() {
-      var _this$props3 = this.props,
-          direction = _this$props3.direction,
-          layout = _this$props3.layout;
+      var _this$props4 = this.props,
+          direction = _this$props4.direction,
+          layout = _this$props4.layout;
       var _this$state = this.state,
           scrollOffset = _this$state.scrollOffset,
           scrollUpdateWasRequested = _this$state.scrollUpdateWasRequested;
@@ -1341,24 +1346,24 @@ function createListComponent(_ref) {
     };
 
     _proto.render = function render() {
-      var _this$props4 = this.props,
-          children = _this$props4.children,
-          className = _this$props4.className,
-          direction = _this$props4.direction,
-          height = _this$props4.height,
-          innerRef = _this$props4.innerRef,
-          innerElementType = _this$props4.innerElementType,
-          innerTagName = _this$props4.innerTagName,
-          itemCount = _this$props4.itemCount,
-          itemData = _this$props4.itemData,
-          _this$props4$itemKey = _this$props4.itemKey,
-          itemKey = _this$props4$itemKey === void 0 ? defaultItemKey$1 : _this$props4$itemKey,
-          layout = _this$props4.layout,
-          outerElementType = _this$props4.outerElementType,
-          outerTagName = _this$props4.outerTagName,
-          style = _this$props4.style,
-          useIsScrolling = _this$props4.useIsScrolling,
-          width = _this$props4.width;
+      var _this$props5 = this.props,
+          children = _this$props5.children,
+          className = _this$props5.className,
+          direction = _this$props5.direction,
+          height = _this$props5.height,
+          innerRef = _this$props5.innerRef,
+          innerElementType = _this$props5.innerElementType,
+          innerTagName = _this$props5.innerTagName,
+          itemCount = _this$props5.itemCount,
+          itemData = _this$props5.itemData,
+          _this$props5$itemKey = _this$props5.itemKey,
+          itemKey = _this$props5$itemKey === void 0 ? defaultItemKey$1 : _this$props5$itemKey,
+          layout = _this$props5.layout,
+          outerElementType = _this$props5.outerElementType,
+          outerTagName = _this$props5.outerTagName,
+          style = _this$props5.style,
+          useIsScrolling = _this$props5.useIsScrolling,
+          width = _this$props5.width;
       var isScrolling = this.state.isScrolling; // TODO Deprecate direction "horizontal"
 
       var isHorizontal = direction === 'horizontal' || layout === 'horizontal';
@@ -1432,16 +1437,16 @@ function createListComponent(_ref) {
 
         this._callOnScroll(_scrollDirection, _scrollOffset, _scrollUpdateWasRequested);
       }
-    }; // Lazily create and cache item styles while scrolling,
+    } // Lazily create and cache item styles while scrolling,
     // So that pure component sCU will prevent re-renders.
     // We maintain this cache, and pass a style prop rather than index,
     // So that List can clear cached styles and force item re-render if necessary.
-
+    ;
 
     _proto._getRangeToRender = function _getRangeToRender() {
-      var _this$props5 = this.props,
-          itemCount = _this$props5.itemCount,
-          overscanCount = _this$props5.overscanCount;
+      var _this$props6 = this.props,
+          itemCount = _this$props6.itemCount,
+          overscanCount = _this$props6.overscanCount;
       var _this$state3 = this.state,
           isScrolling = _this$state3.isScrolling,
           scrollDirection = _this$state3.scrollDirection,
@@ -1467,7 +1472,7 @@ function createListComponent(_ref) {
     layout: 'vertical',
     overscanCount: 2,
     useIsScrolling: false
-  }, _temp;
+  }, _class;
 } // NOTE: I considered further wrapping individual items with a pure ListItem component.
 // This would avoid ever calling the render function for the same index more than once,
 // But it would also add the overhead of a lot of components/fibers.
@@ -1638,9 +1643,7 @@ var getEstimatedTotalSize = function getEstimatedTotalSize(_ref2, _ref3) {
   return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;
 };
 
-var VariableSizeList =
-/*#__PURE__*/
-createListComponent({
+var VariableSizeList = /*#__PURE__*/createListComponent({
   getItemOffset: function getItemOffset(props, index, instanceProps) {
     return getItemMetadata$1(props, index, instanceProps).offset;
   },
@@ -1648,7 +1651,7 @@ createListComponent({
     return instanceProps.itemMetadataMap[index].size;
   },
   getEstimatedTotalSize: getEstimatedTotalSize,
-  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(props, index, align, scrollOffset, instanceProps) {
+  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {
     var direction = props.direction,
         height = props.height,
         layout = props.layout,
@@ -1661,7 +1664,7 @@ createListComponent({
 
     var estimatedTotalSize = getEstimatedTotalSize(props, instanceProps);
     var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));
-    var minOffset = Math.max(0, itemMetadata.offset - size + itemMetadata.size);
+    var minOffset = Math.max(0, itemMetadata.offset - size + itemMetadata.size + scrollbarSize);
 
     if (align === 'smart') {
       if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {
@@ -1757,9 +1760,7 @@ createListComponent({
   }
 });
 
-var FixedSizeGrid =
-/*#__PURE__*/
-createGridComponent({
+var FixedSizeGrid = /*#__PURE__*/createGridComponent({
   getColumnOffset: function getColumnOffset(_ref, index) {
     var columnWidth = _ref.columnWidth;
     return index * columnWidth;
@@ -1937,9 +1938,7 @@ createGridComponent({
   }
 });
 
-var FixedSizeList =
-/*#__PURE__*/
-createListComponent({
+var FixedSizeList = /*#__PURE__*/createListComponent({
   getItemOffset: function getItemOffset(_ref, index) {
     var itemSize = _ref.itemSize;
     return index * itemSize;
@@ -1953,7 +1952,7 @@ createListComponent({
         itemSize = _ref3.itemSize;
     return itemSize * itemCount;
   },
-  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(_ref4, index, align, scrollOffset) {
+  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(_ref4, index, align, scrollOffset, instanceProps, scrollbarSize) {
     var direction = _ref4.direction,
         height = _ref4.height,
         itemCount = _ref4.itemCount,
@@ -1965,7 +1964,7 @@ createListComponent({
     var size = isHorizontal ? width : height;
     var lastItemOffset = Math.max(0, itemCount * itemSize - size);
     var maxOffset = Math.min(lastItemOffset, index * itemSize);
-    var minOffset = Math.max(0, index * itemSize - size + itemSize);
+    var minOffset = Math.max(0, index * itemSize - size + itemSize + scrollbarSize);
 
     if (align === 'smart') {
       if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {
@@ -2061,15 +2060,17 @@ function shallowDiffers(prev, next) {
   return false;
 }
 
+var _excluded = ["style"],
+    _excluded2 = ["style"];
 // It knows to compare individual style props and ignore the wrapper object.
 // See https://reactjs.org/docs/react-api.html#reactmemo
 
 function areEqual(prevProps, nextProps) {
   var prevStyle = prevProps.style,
-      prevRest = _objectWithoutPropertiesLoose(prevProps, ["style"]);
+      prevRest = _objectWithoutPropertiesLoose(prevProps, _excluded);
 
   var nextStyle = nextProps.style,
-      nextRest = _objectWithoutPropertiesLoose(nextProps, ["style"]);
+      nextRest = _objectWithoutPropertiesLoose(nextProps, _excluded2);
 
   return !shallowDiffers(prevStyle, nextStyle) && !shallowDiffers(prevRest, nextRest);
 }
@@ -2081,10 +2082,10 @@ function shouldComponentUpdate(nextProps, nextState) {
   return !areEqual(this.props, nextProps) || shallowDiffers(this.state, nextState);
 }
 
-exports.VariableSizeGrid = VariableSizeGrid;
-exports.VariableSizeList = VariableSizeList;
 exports.FixedSizeGrid = FixedSizeGrid;
 exports.FixedSizeList = FixedSizeList;
+exports.VariableSizeGrid = VariableSizeGrid;
+exports.VariableSizeList = VariableSizeList;
 exports.areEqual = areEqual;
 exports.shouldComponentUpdate = shouldComponentUpdate;
 //# sourceMappingURL=index.cjs.js.map
diff --git a/node_modules/react-window/dist/index.cjs.js.map b/node_modules/react-window/dist/index.cjs.js.map
index 625943a..9ac3b17 100644
--- a/node_modules/react-window/dist/index.cjs.js.map
+++ b/node_modules/react-window/dist/index.cjs.js.map
@@ -1 +1 @@
-{"version":3,"file":"index.cjs.js","sources":["../src/timer.js","../src/domHelpers.js","../src/createGridComponent.js","../src/VariableSizeGrid.js","../src/createListComponent.js","../src/VariableSizeList.js","../src/FixedSizeGrid.js","../src/FixedSizeList.js","../src/shallowDiffers.js","../src/areEqual.js","../src/shouldComponentUpdate.js"],"sourcesContent":["// @flow\n\n// Animation frame based implementation of setTimeout.\n// Inspired by Joe Lambert, https://gist.github.com/joelambert/1002116#file-requesttimeout-js\n\nconst hasNativePerformanceNow =\n  typeof performance === 'object' && typeof performance.now === 'function';\n\nconst now = hasNativePerformanceNow\n  ? () => performance.now()\n  : () => Date.now();\n\nexport type TimeoutID = {|\n  id: AnimationFrameID,\n|};\n\nexport function cancelTimeout(timeoutID: TimeoutID) {\n  cancelAnimationFrame(timeoutID.id);\n}\n\nexport function requestTimeout(callback: Function, delay: number): TimeoutID {\n  const start = now();\n\n  function tick() {\n    if (now() - start >= delay) {\n      callback.call(null);\n    } else {\n      timeoutID.id = requestAnimationFrame(tick);\n    }\n  }\n\n  const timeoutID: TimeoutID = {\n    id: requestAnimationFrame(tick),\n  };\n\n  return timeoutID;\n}\n","// @flow\n\nlet size: number = -1;\n\n// This utility copied from \"dom-helpers\" package.\nexport function getScrollbarSize(recalculate?: boolean = false): number {\n  if (size === -1 || recalculate) {\n    const div = document.createElement('div');\n    const style = div.style;\n    style.width = '50px';\n    style.height = '50px';\n    style.overflow = 'scroll';\n\n    ((document.body: any): HTMLBodyElement).appendChild(div);\n\n    size = div.offsetWidth - div.clientWidth;\n\n    ((document.body: any): HTMLBodyElement).removeChild(div);\n  }\n\n  return size;\n}\n\nexport type RTLOffsetType =\n  | 'negative'\n  | 'positive-descending'\n  | 'positive-ascending';\n\nlet cachedRTLResult: RTLOffsetType | null = null;\n\n// TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n// Chrome does not seem to adhere; its scrollLeft values are positive (measured relative to the left).\n// Safari's elastic bounce makes detecting this even more complicated wrt potential false positives.\n// The safest way to check this is to intentionally set a negative offset,\n// and then verify that the subsequent \"scroll\" event matches the negative offset.\n// If it does not match, then we can assume a non-standard RTL scroll implementation.\nexport function getRTLOffsetType(recalculate?: boolean = false): RTLOffsetType {\n  if (cachedRTLResult === null || recalculate) {\n    const outerDiv = document.createElement('div');\n    const outerStyle = outerDiv.style;\n    outerStyle.width = '50px';\n    outerStyle.height = '50px';\n    outerStyle.overflow = 'scroll';\n    outerStyle.direction = 'rtl';\n\n    const innerDiv = document.createElement('div');\n    const innerStyle = innerDiv.style;\n    innerStyle.width = '100px';\n    innerStyle.height = '100px';\n\n    outerDiv.appendChild(innerDiv);\n\n    ((document.body: any): HTMLBodyElement).appendChild(outerDiv);\n\n    if (outerDiv.scrollLeft > 0) {\n      cachedRTLResult = 'positive-descending';\n    } else {\n      outerDiv.scrollLeft = 1;\n      if (outerDiv.scrollLeft === 0) {\n        cachedRTLResult = 'negative';\n      } else {\n        cachedRTLResult = 'positive-ascending';\n      }\n    }\n\n    ((document.body: any): HTMLBodyElement).removeChild(outerDiv);\n\n    return cachedRTLResult;\n  }\n\n  return cachedRTLResult;\n}\n","// @flow\n\nimport memoizeOne from 'memoize-one';\nimport { createElement, PureComponent } from 'react';\nimport { cancelTimeout, requestTimeout } from './timer';\nimport { getScrollbarSize, getRTLOffsetType } from './domHelpers';\n\nimport type { TimeoutID } from './timer';\n\ntype Direction = 'ltr' | 'rtl';\nexport type ScrollToAlign = 'auto' | 'smart' | 'center' | 'start' | 'end';\n\ntype itemSize = number | ((index: number) => number);\n\ntype RenderComponentProps<T> = {|\n  columnIndex: number,\n  data: T,\n  isScrolling?: boolean,\n  rowIndex: number,\n  style: Object,\n|};\nexport type RenderComponent<T> = React$ComponentType<\n  $Shape<RenderComponentProps<T>>\n>;\n\ntype ScrollDirection = 'forward' | 'backward';\n\ntype OnItemsRenderedCallback = ({\n  overscanColumnStartIndex: number,\n  overscanColumnStopIndex: number,\n  overscanRowStartIndex: number,\n  overscanRowStopIndex: number,\n  visibleColumnStartIndex: number,\n  visibleColumnStopIndex: number,\n  visibleRowStartIndex: number,\n  visibleRowStopIndex: number,\n}) => void;\ntype OnScrollCallback = ({\n  horizontalScrollDirection: ScrollDirection,\n  scrollLeft: number,\n  scrollTop: number,\n  scrollUpdateWasRequested: boolean,\n  verticalScrollDirection: ScrollDirection,\n}) => void;\n\ntype ScrollEvent = SyntheticEvent<HTMLDivElement>;\ntype ItemStyleCache = { [key: string]: Object };\n\ntype OuterProps = {|\n  children: React$Node,\n  className: string | void,\n  onScroll: ScrollEvent => void,\n  style: {\n    [string]: mixed,\n  },\n|};\n\ntype InnerProps = {|\n  children: React$Node,\n  style: {\n    [string]: mixed,\n  },\n|};\n\nexport type Props<T> = {|\n  children: RenderComponent<T>,\n  className?: string,\n  columnCount: number,\n  columnWidth: itemSize,\n  direction: Direction,\n  height: number,\n  initialScrollLeft?: number,\n  initialScrollTop?: number,\n  innerRef?: any,\n  innerElementType?: string | React$AbstractComponent<InnerProps, any>,\n  innerTagName?: string, // deprecated\n  itemData: T,\n  itemKey?: (params: {|\n    columnIndex: number,\n    data: T,\n    rowIndex: number,\n  |}) => any,\n  onItemsRendered?: OnItemsRenderedCallback,\n  onScroll?: OnScrollCallback,\n  outerRef?: any,\n  outerElementType?: string | React$AbstractComponent<OuterProps, any>,\n  outerTagName?: string, // deprecated\n  overscanColumnCount?: number,\n  overscanColumnsCount?: number, // deprecated\n  overscanCount?: number, // deprecated\n  overscanRowCount?: number,\n  overscanRowsCount?: number, // deprecated\n  rowCount: number,\n  rowHeight: itemSize,\n  style?: Object,\n  useIsScrolling: boolean,\n  width: number,\n|};\n\ntype State = {|\n  instance: any,\n  isScrolling: boolean,\n  horizontalScrollDirection: ScrollDirection,\n  scrollLeft: number,\n  scrollTop: number,\n  scrollUpdateWasRequested: boolean,\n  verticalScrollDirection: ScrollDirection,\n|};\n\ntype getItemOffset = (\n  props: Props<any>,\n  index: number,\n  instanceProps: any\n) => number;\ntype getItemSize = (\n  props: Props<any>,\n  index: number,\n  instanceProps: any\n) => number;\ntype getEstimatedTotalSize = (props: Props<any>, instanceProps: any) => number;\ntype GetOffsetForItemAndAlignment = (\n  props: Props<any>,\n  index: number,\n  align: ScrollToAlign,\n  scrollOffset: number,\n  instanceProps: any,\n  scrollbarSize: number\n) => number;\ntype GetStartIndexForOffset = (\n  props: Props<any>,\n  offset: number,\n  instanceProps: any\n) => number;\ntype GetStopIndexForStartIndex = (\n  props: Props<any>,\n  startIndex: number,\n  scrollOffset: number,\n  instanceProps: any\n) => number;\ntype InitInstanceProps = (props: Props<any>, instance: any) => any;\ntype ValidateProps = (props: Props<any>) => void;\n\nconst IS_SCROLLING_DEBOUNCE_INTERVAL = 150;\n\nconst defaultItemKey = ({ columnIndex, data, rowIndex }) =>\n  `${rowIndex}:${columnIndex}`;\n\n// In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\nlet devWarningsOverscanCount = null;\nlet devWarningsOverscanRowsColumnsCount = null;\nlet devWarningsTagName = null;\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsOverscanCount = new WeakSet();\n    devWarningsOverscanRowsColumnsCount = new WeakSet();\n    devWarningsTagName = new WeakSet();\n  }\n}\n\nexport default function createGridComponent({\n  getColumnOffset,\n  getColumnStartIndexForOffset,\n  getColumnStopIndexForStartIndex,\n  getColumnWidth,\n  getEstimatedTotalHeight,\n  getEstimatedTotalWidth,\n  getOffsetForColumnAndAlignment,\n  getOffsetForRowAndAlignment,\n  getRowHeight,\n  getRowOffset,\n  getRowStartIndexForOffset,\n  getRowStopIndexForStartIndex,\n  initInstanceProps,\n  shouldResetStyleCacheOnItemSizeChange,\n  validateProps,\n}: {|\n  getColumnOffset: getItemOffset,\n  getColumnStartIndexForOffset: GetStartIndexForOffset,\n  getColumnStopIndexForStartIndex: GetStopIndexForStartIndex,\n  getColumnWidth: getItemSize,\n  getEstimatedTotalHeight: getEstimatedTotalSize,\n  getEstimatedTotalWidth: getEstimatedTotalSize,\n  getOffsetForColumnAndAlignment: GetOffsetForItemAndAlignment,\n  getOffsetForRowAndAlignment: GetOffsetForItemAndAlignment,\n  getRowOffset: getItemOffset,\n  getRowHeight: getItemSize,\n  getRowStartIndexForOffset: GetStartIndexForOffset,\n  getRowStopIndexForStartIndex: GetStopIndexForStartIndex,\n  initInstanceProps: InitInstanceProps,\n  shouldResetStyleCacheOnItemSizeChange: boolean,\n  validateProps: ValidateProps,\n|}) {\n  return class Grid<T> extends PureComponent<Props<T>, State> {\n    _instanceProps: any = initInstanceProps(this.props, this);\n    _resetIsScrollingTimeoutId: TimeoutID | null = null;\n    _outerRef: ?HTMLDivElement;\n\n    static defaultProps = {\n      direction: 'ltr',\n      itemData: undefined,\n      useIsScrolling: false,\n    };\n\n    state: State = {\n      instance: this,\n      isScrolling: false,\n      horizontalScrollDirection: 'forward',\n      scrollLeft:\n        typeof this.props.initialScrollLeft === 'number'\n          ? this.props.initialScrollLeft\n          : 0,\n      scrollTop:\n        typeof this.props.initialScrollTop === 'number'\n          ? this.props.initialScrollTop\n          : 0,\n      scrollUpdateWasRequested: false,\n      verticalScrollDirection: 'forward',\n    };\n\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    constructor(props: Props<T>) {\n      super(props);\n    }\n\n    static getDerivedStateFromProps(\n      nextProps: Props<T>,\n      prevState: State\n    ): $Shape<State> | null {\n      validateSharedProps(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    }\n\n    scrollTo({\n      scrollLeft,\n      scrollTop,\n    }: {\n      scrollLeft: number,\n      scrollTop: number,\n    }): void {\n      if (scrollLeft !== undefined) {\n        scrollLeft = Math.max(0, scrollLeft);\n      }\n      if (scrollTop !== undefined) {\n        scrollTop = Math.max(0, scrollTop);\n      }\n\n      this.setState(prevState => {\n        if (scrollLeft === undefined) {\n          scrollLeft = prevState.scrollLeft;\n        }\n        if (scrollTop === undefined) {\n          scrollTop = prevState.scrollTop;\n        }\n\n        if (\n          prevState.scrollLeft === scrollLeft &&\n          prevState.scrollTop === scrollTop\n        ) {\n          return null;\n        }\n\n        return {\n          horizontalScrollDirection:\n            prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          scrollUpdateWasRequested: true,\n          verticalScrollDirection:\n            prevState.scrollTop < scrollTop ? 'forward' : 'backward',\n        };\n      }, this._resetIsScrollingDebounced);\n    }\n\n    scrollToItem({\n      align = 'auto',\n      columnIndex,\n      rowIndex,\n    }: {\n      align: ScrollToAlign,\n      columnIndex?: number,\n      rowIndex?: number,\n    }): void {\n      const { columnCount, height, rowCount, width } = this.props;\n      const { scrollLeft, scrollTop } = this.state;\n      const scrollbarSize = getScrollbarSize();\n\n      if (columnIndex !== undefined) {\n        columnIndex = Math.max(0, Math.min(columnIndex, columnCount - 1));\n      }\n      if (rowIndex !== undefined) {\n        rowIndex = Math.max(0, Math.min(rowIndex, rowCount - 1));\n      }\n\n      const estimatedTotalHeight = getEstimatedTotalHeight(\n        this.props,\n        this._instanceProps\n      );\n      const estimatedTotalWidth = getEstimatedTotalWidth(\n        this.props,\n        this._instanceProps\n      );\n\n      // The scrollbar size should be considered when scrolling an item into view,\n      // to ensure it's fully visible.\n      // But we only need to account for its size when it's actually visible.\n      const horizontalScrollbarSize =\n        estimatedTotalWidth > width ? scrollbarSize : 0;\n      const verticalScrollbarSize =\n        estimatedTotalHeight > height ? scrollbarSize : 0;\n\n      this.scrollTo({\n        scrollLeft:\n          columnIndex !== undefined\n            ? getOffsetForColumnAndAlignment(\n                this.props,\n                columnIndex,\n                align,\n                scrollLeft,\n                this._instanceProps,\n                verticalScrollbarSize\n              )\n            : scrollLeft,\n        scrollTop:\n          rowIndex !== undefined\n            ? getOffsetForRowAndAlignment(\n                this.props,\n                rowIndex,\n                align,\n                scrollTop,\n                this._instanceProps,\n                horizontalScrollbarSize\n              )\n            : scrollTop,\n      });\n    }\n\n    componentDidMount() {\n      const { initialScrollLeft, initialScrollTop } = this.props;\n\n      if (this._outerRef != null) {\n        const outerRef = ((this._outerRef: any): HTMLElement);\n        if (typeof initialScrollLeft === 'number') {\n          outerRef.scrollLeft = initialScrollLeft;\n        }\n        if (typeof initialScrollTop === 'number') {\n          outerRef.scrollTop = initialScrollTop;\n        }\n      }\n\n      this._callPropsCallbacks();\n    }\n\n    componentDidUpdate() {\n      const { direction } = this.props;\n      const { scrollLeft, scrollTop, scrollUpdateWasRequested } = this.state;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n        // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n        // So we need to determine which browser behavior we're dealing with, and mimic it.\n        const outerRef = ((this._outerRef: any): HTMLElement);\n        if (direction === 'rtl') {\n          switch (getRTLOffsetType()) {\n            case 'negative':\n              outerRef.scrollLeft = -scrollLeft;\n              break;\n            case 'positive-ascending':\n              outerRef.scrollLeft = scrollLeft;\n              break;\n            default:\n              const { clientWidth, scrollWidth } = outerRef;\n              outerRef.scrollLeft = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        } else {\n          outerRef.scrollLeft = Math.max(0, scrollLeft);\n        }\n\n        outerRef.scrollTop = Math.max(0, scrollTop);\n      }\n\n      this._callPropsCallbacks();\n    }\n\n    componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    }\n\n    render() {\n      const {\n        children,\n        className,\n        columnCount,\n        direction,\n        height,\n        innerRef,\n        innerElementType,\n        innerTagName,\n        itemData,\n        itemKey = defaultItemKey,\n        outerElementType,\n        outerTagName,\n        rowCount,\n        style,\n        useIsScrolling,\n        width,\n      } = this.props;\n      const { isScrolling } = this.state;\n\n      const [\n        columnStartIndex,\n        columnStopIndex,\n      ] = this._getHorizontalRangeToRender();\n      const [rowStartIndex, rowStopIndex] = this._getVerticalRangeToRender();\n\n      const items = [];\n      if (columnCount > 0 && rowCount) {\n        for (\n          let rowIndex = rowStartIndex;\n          rowIndex <= rowStopIndex;\n          rowIndex++\n        ) {\n          for (\n            let columnIndex = columnStartIndex;\n            columnIndex <= columnStopIndex;\n            columnIndex++\n          ) {\n            items.push(\n              createElement(children, {\n                columnIndex,\n                data: itemData,\n                isScrolling: useIsScrolling ? isScrolling : undefined,\n                key: itemKey({ columnIndex, data: itemData, rowIndex }),\n                rowIndex,\n                style: this._getItemStyle(rowIndex, columnIndex),\n              })\n            );\n          }\n        }\n      }\n\n      // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n      const estimatedTotalHeight = getEstimatedTotalHeight(\n        this.props,\n        this._instanceProps\n      );\n      const estimatedTotalWidth = getEstimatedTotalWidth(\n        this.props,\n        this._instanceProps\n      );\n\n      return createElement(\n        outerElementType || outerTagName || 'div',\n        {\n          className,\n          onScroll: this._onScroll,\n          ref: this._outerRefSetter,\n          style: {\n            position: 'relative',\n            height,\n            width,\n            overflow: 'auto',\n            WebkitOverflowScrolling: 'touch',\n            willChange: 'transform',\n            direction,\n            ...style,\n          },\n        },\n        createElement(innerElementType || innerTagName || 'div', {\n          children: items,\n          ref: innerRef,\n          style: {\n            height: estimatedTotalHeight,\n            pointerEvents: isScrolling ? 'none' : undefined,\n            width: estimatedTotalWidth,\n          },\n        })\n      );\n    }\n\n    _callOnItemsRendered: (\n      overscanColumnStartIndex: number,\n      overscanColumnStopIndex: number,\n      overscanRowStartIndex: number,\n      overscanRowStopIndex: number,\n      visibleColumnStartIndex: number,\n      visibleColumnStopIndex: number,\n      visibleRowStartIndex: number,\n      visibleRowStopIndex: number\n    ) => void;\n    _callOnItemsRendered = memoizeOne(\n      (\n        overscanColumnStartIndex: number,\n        overscanColumnStopIndex: number,\n        overscanRowStartIndex: number,\n        overscanRowStopIndex: number,\n        visibleColumnStartIndex: number,\n        visibleColumnStopIndex: number,\n        visibleRowStartIndex: number,\n        visibleRowStopIndex: number\n      ) =>\n        ((this.props.onItemsRendered: any): OnItemsRenderedCallback)({\n          overscanColumnStartIndex,\n          overscanColumnStopIndex,\n          overscanRowStartIndex,\n          overscanRowStopIndex,\n          visibleColumnStartIndex,\n          visibleColumnStopIndex,\n          visibleRowStartIndex,\n          visibleRowStopIndex,\n        })\n    );\n\n    _callOnScroll: (\n      scrollLeft: number,\n      scrollTop: number,\n      horizontalScrollDirection: ScrollDirection,\n      verticalScrollDirection: ScrollDirection,\n      scrollUpdateWasRequested: boolean\n    ) => void;\n    _callOnScroll = memoizeOne(\n      (\n        scrollLeft: number,\n        scrollTop: number,\n        horizontalScrollDirection: ScrollDirection,\n        verticalScrollDirection: ScrollDirection,\n        scrollUpdateWasRequested: boolean\n      ) =>\n        ((this.props.onScroll: any): OnScrollCallback)({\n          horizontalScrollDirection,\n          scrollLeft,\n          scrollTop,\n          verticalScrollDirection,\n          scrollUpdateWasRequested,\n        })\n    );\n\n    _callPropsCallbacks() {\n      const { columnCount, onItemsRendered, onScroll, rowCount } = this.props;\n\n      if (typeof onItemsRendered === 'function') {\n        if (columnCount > 0 && rowCount > 0) {\n          const [\n            overscanColumnStartIndex,\n            overscanColumnStopIndex,\n            visibleColumnStartIndex,\n            visibleColumnStopIndex,\n          ] = this._getHorizontalRangeToRender();\n          const [\n            overscanRowStartIndex,\n            overscanRowStopIndex,\n            visibleRowStartIndex,\n            visibleRowStopIndex,\n          ] = this._getVerticalRangeToRender();\n          this._callOnItemsRendered(\n            overscanColumnStartIndex,\n            overscanColumnStopIndex,\n            overscanRowStartIndex,\n            overscanRowStopIndex,\n            visibleColumnStartIndex,\n            visibleColumnStopIndex,\n            visibleRowStartIndex,\n            visibleRowStopIndex\n          );\n        }\n      }\n\n      if (typeof onScroll === 'function') {\n        const {\n          horizontalScrollDirection,\n          scrollLeft,\n          scrollTop,\n          scrollUpdateWasRequested,\n          verticalScrollDirection,\n        } = this.state;\n        this._callOnScroll(\n          scrollLeft,\n          scrollTop,\n          horizontalScrollDirection,\n          verticalScrollDirection,\n          scrollUpdateWasRequested\n        );\n      }\n    }\n\n    // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n    _getItemStyle: (rowIndex: number, columnIndex: number) => Object;\n    _getItemStyle = (rowIndex: number, columnIndex: number): Object => {\n      const { columnWidth, direction, rowHeight } = this.props;\n\n      const itemStyleCache = this._getItemStyleCache(\n        shouldResetStyleCacheOnItemSizeChange && columnWidth,\n        shouldResetStyleCacheOnItemSizeChange && direction,\n        shouldResetStyleCacheOnItemSizeChange && rowHeight\n      );\n\n      const key = `${rowIndex}:${columnIndex}`;\n\n      let style;\n      if (itemStyleCache.hasOwnProperty(key)) {\n        style = itemStyleCache[key];\n      } else {\n        const offset = getColumnOffset(\n          this.props,\n          columnIndex,\n          this._instanceProps\n        );\n        const isRtl = direction === 'rtl';\n        itemStyleCache[key] = style = {\n          position: 'absolute',\n          left: isRtl ? undefined : offset,\n          right: isRtl ? offset : undefined,\n          top: getRowOffset(this.props, rowIndex, this._instanceProps),\n          height: getRowHeight(this.props, rowIndex, this._instanceProps),\n          width: getColumnWidth(this.props, columnIndex, this._instanceProps),\n        };\n      }\n\n      return style;\n    };\n\n    _getItemStyleCache: (_: any, __: any, ___: any) => ItemStyleCache;\n    _getItemStyleCache = memoizeOne((_: any, __: any, ___: any) => ({}));\n\n    _getHorizontalRangeToRender(): [number, number, number, number] {\n      const {\n        columnCount,\n        overscanColumnCount,\n        overscanColumnsCount,\n        overscanCount,\n        rowCount,\n      } = this.props;\n      const { horizontalScrollDirection, isScrolling, scrollLeft } = this.state;\n\n      const overscanCountResolved: number =\n        overscanColumnCount || overscanColumnsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      const startIndex = getColumnStartIndexForOffset(\n        this.props,\n        scrollLeft,\n        this._instanceProps\n      );\n      const stopIndex = getColumnStopIndexForStartIndex(\n        this.props,\n        startIndex,\n        scrollLeft,\n        this._instanceProps\n      );\n\n      // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n      const overscanBackward =\n        !isScrolling || horizontalScrollDirection === 'backward'\n          ? Math.max(1, overscanCountResolved)\n          : 1;\n      const overscanForward =\n        !isScrolling || horizontalScrollDirection === 'forward'\n          ? Math.max(1, overscanCountResolved)\n          : 1;\n\n      return [\n        Math.max(0, startIndex - overscanBackward),\n        Math.max(0, Math.min(columnCount - 1, stopIndex + overscanForward)),\n        startIndex,\n        stopIndex,\n      ];\n    }\n\n    _getVerticalRangeToRender(): [number, number, number, number] {\n      const {\n        columnCount,\n        overscanCount,\n        overscanRowCount,\n        overscanRowsCount,\n        rowCount,\n      } = this.props;\n      const { isScrolling, verticalScrollDirection, scrollTop } = this.state;\n\n      const overscanCountResolved: number =\n        overscanRowCount || overscanRowsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      const startIndex = getRowStartIndexForOffset(\n        this.props,\n        scrollTop,\n        this._instanceProps\n      );\n      const stopIndex = getRowStopIndexForStartIndex(\n        this.props,\n        startIndex,\n        scrollTop,\n        this._instanceProps\n      );\n\n      // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n      const overscanBackward =\n        !isScrolling || verticalScrollDirection === 'backward'\n          ? Math.max(1, overscanCountResolved)\n          : 1;\n      const overscanForward =\n        !isScrolling || verticalScrollDirection === 'forward'\n          ? Math.max(1, overscanCountResolved)\n          : 1;\n\n      return [\n        Math.max(0, startIndex - overscanBackward),\n        Math.max(0, Math.min(rowCount - 1, stopIndex + overscanForward)),\n        startIndex,\n        stopIndex,\n      ];\n    }\n\n    _onScroll = (event: ScrollEvent): void => {\n      const {\n        clientHeight,\n        clientWidth,\n        scrollLeft,\n        scrollTop,\n        scrollHeight,\n        scrollWidth,\n      } = event.currentTarget;\n      this.setState(prevState => {\n        if (\n          prevState.scrollLeft === scrollLeft &&\n          prevState.scrollTop === scrollTop\n        ) {\n          // Scroll position may have been updated by cDM/cDU,\n          // In which case we don't need to trigger another render,\n          // And we don't want to update state.isScrolling.\n          return null;\n        }\n\n        const { direction } = this.props;\n\n        // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n        // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n        // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n        // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n        let calculatedScrollLeft = scrollLeft;\n        if (direction === 'rtl') {\n          switch (getRTLOffsetType()) {\n            case 'negative':\n              calculatedScrollLeft = -scrollLeft;\n              break;\n            case 'positive-descending':\n              calculatedScrollLeft = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        }\n\n        // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n        calculatedScrollLeft = Math.max(\n          0,\n          Math.min(calculatedScrollLeft, scrollWidth - clientWidth)\n        );\n        const calculatedScrollTop = Math.max(\n          0,\n          Math.min(scrollTop, scrollHeight - clientHeight)\n        );\n\n        return {\n          isScrolling: true,\n          horizontalScrollDirection:\n            prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n          scrollLeft: calculatedScrollLeft,\n          scrollTop: calculatedScrollTop,\n          verticalScrollDirection:\n            prevState.scrollTop < scrollTop ? 'forward' : 'backward',\n          scrollUpdateWasRequested: false,\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _outerRefSetter = (ref: any): void => {\n      const { outerRef } = this.props;\n\n      this._outerRef = ((ref: any): HTMLDivElement);\n\n      if (typeof outerRef === 'function') {\n        outerRef(ref);\n      } else if (\n        outerRef != null &&\n        typeof outerRef === 'object' &&\n        outerRef.hasOwnProperty('current')\n      ) {\n        outerRef.current = ref;\n      }\n    };\n\n    _resetIsScrollingDebounced = () => {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n\n      this._resetIsScrollingTimeoutId = requestTimeout(\n        this._resetIsScrolling,\n        IS_SCROLLING_DEBOUNCE_INTERVAL\n      );\n    };\n\n    _resetIsScrolling = () => {\n      this._resetIsScrollingTimeoutId = null;\n\n      this.setState({ isScrolling: false }, () => {\n        // Clear style cache after state update has been committed.\n        // This way we don't break pure sCU for items that don't use isScrolling param.\n        this._getItemStyleCache(-1);\n      });\n    };\n  };\n}\n\nconst validateSharedProps = (\n  {\n    children,\n    direction,\n    height,\n    innerTagName,\n    outerTagName,\n    overscanColumnsCount,\n    overscanCount,\n    overscanRowsCount,\n    width,\n  }: Props<any>,\n  { instance }: State\n): void => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof overscanCount === 'number') {\n      if (devWarningsOverscanCount && !devWarningsOverscanCount.has(instance)) {\n        devWarningsOverscanCount.add(instance);\n        console.warn(\n          'The overscanCount prop has been deprecated. ' +\n            'Please use the overscanColumnCount and overscanRowCount props instead.'\n        );\n      }\n    }\n\n    if (\n      typeof overscanColumnsCount === 'number' ||\n      typeof overscanRowsCount === 'number'\n    ) {\n      if (\n        devWarningsOverscanRowsColumnsCount &&\n        !devWarningsOverscanRowsColumnsCount.has(instance)\n      ) {\n        devWarningsOverscanRowsColumnsCount.add(instance);\n        console.warn(\n          'The overscanColumnsCount and overscanRowsCount props have been deprecated. ' +\n            'Please use the overscanColumnCount and overscanRowCount props instead.'\n        );\n      }\n    }\n\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName && !devWarningsTagName.has(instance)) {\n        devWarningsTagName.add(instance);\n        console.warn(\n          'The innerTagName and outerTagName props have been deprecated. ' +\n            'Please use the innerElementType and outerElementType props instead.'\n        );\n      }\n    }\n\n    if (children == null) {\n      throw Error(\n        'An invalid \"children\" prop has been specified. ' +\n          'Value should be a React component. ' +\n          `\"${children === null ? 'null' : typeof children}\" was specified.`\n      );\n    }\n\n    switch (direction) {\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n      default:\n        throw Error(\n          'An invalid \"direction\" prop has been specified. ' +\n            'Value should be either \"ltr\" or \"rtl\". ' +\n            `\"${direction}\" was specified.`\n        );\n    }\n\n    if (typeof width !== 'number') {\n      throw Error(\n        'An invalid \"width\" prop has been specified. ' +\n          'Grids must specify a number for width. ' +\n          `\"${width === null ? 'null' : typeof width}\" was specified.`\n      );\n    }\n\n    if (typeof height !== 'number') {\n      throw Error(\n        'An invalid \"height\" prop has been specified. ' +\n          'Grids must specify a number for height. ' +\n          `\"${height === null ? 'null' : typeof height}\" was specified.`\n      );\n    }\n  }\n};\n","// @flow\n\nimport createGridComponent from './createGridComponent';\n\nimport type { Props, ScrollToAlign } from './createGridComponent';\n\nconst DEFAULT_ESTIMATED_ITEM_SIZE = 50;\n\ntype VariableSizeProps = {|\n  estimatedColumnWidth: number,\n  estimatedRowHeight: number,\n  ...Props<any>,\n|};\n\ntype itemSizeGetter = (index: number) => number;\ntype ItemType = 'column' | 'row';\n\ntype ItemMetadata = {|\n  offset: number,\n  size: number,\n|};\ntype ItemMetadataMap = { [index: number]: ItemMetadata };\ntype InstanceProps = {|\n  columnMetadataMap: ItemMetadataMap,\n  estimatedColumnWidth: number,\n  estimatedRowHeight: number,\n  lastMeasuredColumnIndex: number,\n  lastMeasuredRowIndex: number,\n  rowMetadataMap: ItemMetadataMap,\n|};\n\nconst getEstimatedTotalHeight = (\n  { rowCount }: Props<any>,\n  { rowMetadataMap, estimatedRowHeight, lastMeasuredRowIndex }: InstanceProps\n) => {\n  let totalSizeOfMeasuredRows = 0;\n\n  // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n  if (lastMeasuredRowIndex >= rowCount) {\n    lastMeasuredRowIndex = rowCount - 1;\n  }\n\n  if (lastMeasuredRowIndex >= 0) {\n    const itemMetadata = rowMetadataMap[lastMeasuredRowIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  const numUnmeasuredItems = rowCount - lastMeasuredRowIndex - 1;\n  const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedRowHeight;\n\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nconst getEstimatedTotalWidth = (\n  { columnCount }: Props<any>,\n  {\n    columnMetadataMap,\n    estimatedColumnWidth,\n    lastMeasuredColumnIndex,\n  }: InstanceProps\n) => {\n  let totalSizeOfMeasuredRows = 0;\n\n  // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n  if (lastMeasuredColumnIndex >= columnCount) {\n    lastMeasuredColumnIndex = columnCount - 1;\n  }\n\n  if (lastMeasuredColumnIndex >= 0) {\n    const itemMetadata = columnMetadataMap[lastMeasuredColumnIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  const numUnmeasuredItems = columnCount - lastMeasuredColumnIndex - 1;\n  const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedColumnWidth;\n\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nconst getItemMetadata = (\n  itemType: ItemType,\n  props: Props<any>,\n  index: number,\n  instanceProps: InstanceProps\n): ItemMetadata => {\n  let itemMetadataMap, itemSize, lastMeasuredIndex;\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    itemSize = ((props.columnWidth: any): itemSizeGetter);\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    itemSize = ((props.rowHeight: any): itemSizeGetter);\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  if (index > lastMeasuredIndex) {\n    let offset = 0;\n    if (lastMeasuredIndex >= 0) {\n      const itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (let i = lastMeasuredIndex + 1; i <= index; i++) {\n      let size = itemSize(i);\n\n      itemMetadataMap[i] = {\n        offset,\n        size,\n      };\n\n      offset += size;\n    }\n\n    if (itemType === 'column') {\n      instanceProps.lastMeasuredColumnIndex = index;\n    } else {\n      instanceProps.lastMeasuredRowIndex = index;\n    }\n  }\n\n  return itemMetadataMap[index];\n};\n\nconst findNearestItem = (\n  itemType: ItemType,\n  props: Props<any>,\n  instanceProps: InstanceProps,\n  offset: number\n) => {\n  let itemMetadataMap, lastMeasuredIndex;\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  const lastMeasuredItemOffset =\n    lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch(\n      itemType,\n      props,\n      instanceProps,\n      lastMeasuredIndex,\n      0,\n      offset\n    );\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch(\n      itemType,\n      props,\n      instanceProps,\n      Math.max(0, lastMeasuredIndex),\n      offset\n    );\n  }\n};\n\nconst findNearestItemBinarySearch = (\n  itemType: ItemType,\n  props: Props<any>,\n  instanceProps: InstanceProps,\n  high: number,\n  low: number,\n  offset: number\n): number => {\n  while (low <= high) {\n    const middle = low + Math.floor((high - low) / 2);\n    const currentOffset = getItemMetadata(\n      itemType,\n      props,\n      middle,\n      instanceProps\n    ).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nconst findNearestItemExponentialSearch = (\n  itemType: ItemType,\n  props: Props<any>,\n  instanceProps: InstanceProps,\n  index: number,\n  offset: number\n): number => {\n  const itemCount = itemType === 'column' ? props.columnCount : props.rowCount;\n  let interval = 1;\n\n  while (\n    index < itemCount &&\n    getItemMetadata(itemType, props, index, instanceProps).offset < offset\n  ) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch(\n    itemType,\n    props,\n    instanceProps,\n    Math.min(index, itemCount - 1),\n    Math.floor(index / 2),\n    offset\n  );\n};\n\nconst getOffsetForIndexAndAlignment = (\n  itemType: ItemType,\n  props: Props<any>,\n  index: number,\n  align: ScrollToAlign,\n  scrollOffset: number,\n  instanceProps: InstanceProps,\n  scrollbarSize: number\n): number => {\n  const size = itemType === 'column' ? props.width : props.height;\n  const itemMetadata = getItemMetadata(itemType, props, index, instanceProps);\n\n  // Get estimated total size after ItemMetadata is computed,\n  // To ensure it reflects actual measurements instead of just estimates.\n  const estimatedTotalSize =\n    itemType === 'column'\n      ? getEstimatedTotalWidth(props, instanceProps)\n      : getEstimatedTotalHeight(props, instanceProps);\n\n  const maxOffset = Math.max(\n    0,\n    Math.min(estimatedTotalSize - size, itemMetadata.offset)\n  );\n  const minOffset = Math.max(\n    0,\n    itemMetadata.offset - size + scrollbarSize + itemMetadata.size\n  );\n\n  if (align === 'smart') {\n    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n      align = 'auto';\n    } else {\n      align = 'center';\n    }\n  }\n\n  switch (align) {\n    case 'start':\n      return maxOffset;\n    case 'end':\n      return minOffset;\n    case 'center':\n      return Math.round(minOffset + (maxOffset - minOffset) / 2);\n    case 'auto':\n    default:\n      if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n        return scrollOffset;\n      } else if (minOffset > maxOffset) {\n        // Because we only take into account the scrollbar size when calculating minOffset\n        // this value can be larger than maxOffset when at the end of the list\n        return minOffset;\n      } else if (scrollOffset < minOffset) {\n        return minOffset;\n      } else {\n        return maxOffset;\n      }\n  }\n};\n\nconst VariableSizeGrid = createGridComponent({\n  getColumnOffset: (\n    props: Props<any>,\n    index: number,\n    instanceProps: InstanceProps\n  ): number => getItemMetadata('column', props, index, instanceProps).offset,\n\n  getColumnStartIndexForOffset: (\n    props: Props<any>,\n    scrollLeft: number,\n    instanceProps: InstanceProps\n  ): number => findNearestItem('column', props, instanceProps, scrollLeft),\n\n  getColumnStopIndexForStartIndex: (\n    props: Props<any>,\n    startIndex: number,\n    scrollLeft: number,\n    instanceProps: InstanceProps\n  ): number => {\n    const { columnCount, width } = props;\n\n    const itemMetadata = getItemMetadata(\n      'column',\n      props,\n      startIndex,\n      instanceProps\n    );\n    const maxOffset = scrollLeft + width;\n\n    let offset = itemMetadata.offset + itemMetadata.size;\n    let stopIndex = startIndex;\n\n    while (stopIndex < columnCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata('column', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n\n  getColumnWidth: (\n    props: Props<any>,\n    index: number,\n    instanceProps: InstanceProps\n  ): number => instanceProps.columnMetadataMap[index].size,\n\n  getEstimatedTotalHeight,\n  getEstimatedTotalWidth,\n\n  getOffsetForColumnAndAlignment: (\n    props: Props<any>,\n    index: number,\n    align: ScrollToAlign,\n    scrollOffset: number,\n    instanceProps: InstanceProps,\n    scrollbarSize: number\n  ): number =>\n    getOffsetForIndexAndAlignment(\n      'column',\n      props,\n      index,\n      align,\n      scrollOffset,\n      instanceProps,\n      scrollbarSize\n    ),\n\n  getOffsetForRowAndAlignment: (\n    props: Props<any>,\n    index: number,\n    align: ScrollToAlign,\n    scrollOffset: number,\n    instanceProps: InstanceProps,\n    scrollbarSize: number\n  ): number =>\n    getOffsetForIndexAndAlignment(\n      'row',\n      props,\n      index,\n      align,\n      scrollOffset,\n      instanceProps,\n      scrollbarSize\n    ),\n\n  getRowOffset: (\n    props: Props<any>,\n    index: number,\n    instanceProps: InstanceProps\n  ): number => getItemMetadata('row', props, index, instanceProps).offset,\n\n  getRowHeight: (\n    props: Props<any>,\n    index: number,\n    instanceProps: InstanceProps\n  ): number => instanceProps.rowMetadataMap[index].size,\n\n  getRowStartIndexForOffset: (\n    props: Props<any>,\n    scrollTop: number,\n    instanceProps: InstanceProps\n  ): number => findNearestItem('row', props, instanceProps, scrollTop),\n\n  getRowStopIndexForStartIndex: (\n    props: Props<any>,\n    startIndex: number,\n    scrollTop: number,\n    instanceProps: InstanceProps\n  ): number => {\n    const { rowCount, height } = props;\n\n    const itemMetadata = getItemMetadata(\n      'row',\n      props,\n      startIndex,\n      instanceProps\n    );\n    const maxOffset = scrollTop + height;\n\n    let offset = itemMetadata.offset + itemMetadata.size;\n    let stopIndex = startIndex;\n\n    while (stopIndex < rowCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata('row', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n\n  initInstanceProps(props: Props<any>, instance: any): InstanceProps {\n    const {\n      estimatedColumnWidth,\n      estimatedRowHeight,\n    } = ((props: any): VariableSizeProps);\n\n    const instanceProps = {\n      columnMetadataMap: {},\n      estimatedColumnWidth: estimatedColumnWidth || DEFAULT_ESTIMATED_ITEM_SIZE,\n      estimatedRowHeight: estimatedRowHeight || DEFAULT_ESTIMATED_ITEM_SIZE,\n      lastMeasuredColumnIndex: -1,\n      lastMeasuredRowIndex: -1,\n      rowMetadataMap: {},\n    };\n\n    instance.resetAfterColumnIndex = (\n      columnIndex: number,\n      shouldForceUpdate?: boolean = true\n    ) => {\n      instance.resetAfterIndices({ columnIndex, shouldForceUpdate });\n    };\n\n    instance.resetAfterRowIndex = (\n      rowIndex: number,\n      shouldForceUpdate?: boolean = true\n    ) => {\n      instance.resetAfterIndices({ rowIndex, shouldForceUpdate });\n    };\n\n    instance.resetAfterIndices = ({\n      columnIndex,\n      rowIndex,\n      shouldForceUpdate = true,\n    }: {\n      columnIndex?: number,\n      rowIndex?: number,\n      shouldForceUpdate: boolean,\n    }) => {\n      if (typeof columnIndex === 'number') {\n        instanceProps.lastMeasuredColumnIndex = Math.min(\n          instanceProps.lastMeasuredColumnIndex,\n          columnIndex - 1\n        );\n      }\n      if (typeof rowIndex === 'number') {\n        instanceProps.lastMeasuredRowIndex = Math.min(\n          instanceProps.lastMeasuredRowIndex,\n          rowIndex - 1\n        );\n      }\n\n      // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n\n  shouldResetStyleCacheOnItemSizeChange: false,\n\n  validateProps: ({ columnWidth, rowHeight }: Props<any>): void => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'function') {\n        throw Error(\n          'An invalid \"columnWidth\" prop has been specified. ' +\n            'Value should be a function. ' +\n            `\"${\n              columnWidth === null ? 'null' : typeof columnWidth\n            }\" was specified.`\n        );\n      } else if (typeof rowHeight !== 'function') {\n        throw Error(\n          'An invalid \"rowHeight\" prop has been specified. ' +\n            'Value should be a function. ' +\n            `\"${rowHeight === null ? 'null' : typeof rowHeight}\" was specified.`\n        );\n      }\n    }\n  },\n});\n\nexport default VariableSizeGrid;\n","// @flow\n\nimport memoizeOne from 'memoize-one';\nimport { createElement, PureComponent } from 'react';\nimport { cancelTimeout, requestTimeout } from './timer';\nimport { getRTLOffsetType } from './domHelpers';\n\nimport type { TimeoutID } from './timer';\n\nexport type ScrollToAlign = 'auto' | 'smart' | 'center' | 'start' | 'end';\n\ntype itemSize = number | ((index: number) => number);\n// TODO Deprecate directions \"horizontal\" and \"vertical\"\ntype Direction = 'ltr' | 'rtl' | 'horizontal' | 'vertical';\ntype Layout = 'horizontal' | 'vertical';\n\ntype RenderComponentProps<T> = {|\n  data: T,\n  index: number,\n  isScrolling?: boolean,\n  style: Object,\n|};\ntype RenderComponent<T> = React$ComponentType<$Shape<RenderComponentProps<T>>>;\n\ntype ScrollDirection = 'forward' | 'backward';\n\ntype onItemsRenderedCallback = ({\n  overscanStartIndex: number,\n  overscanStopIndex: number,\n  visibleStartIndex: number,\n  visibleStopIndex: number,\n}) => void;\ntype onScrollCallback = ({\n  scrollDirection: ScrollDirection,\n  scrollOffset: number,\n  scrollUpdateWasRequested: boolean,\n}) => void;\n\ntype ScrollEvent = SyntheticEvent<HTMLDivElement>;\ntype ItemStyleCache = { [index: number]: Object };\n\ntype OuterProps = {|\n  children: React$Node,\n  className: string | void,\n  onScroll: ScrollEvent => void,\n  style: {\n    [string]: mixed,\n  },\n|};\n\ntype InnerProps = {|\n  children: React$Node,\n  style: {\n    [string]: mixed,\n  },\n|};\n\nexport type Props<T> = {|\n  children: RenderComponent<T>,\n  className?: string,\n  direction: Direction,\n  height: number | string,\n  initialScrollOffset?: number,\n  innerRef?: any,\n  innerElementType?: string | React$AbstractComponent<InnerProps, any>,\n  innerTagName?: string, // deprecated\n  itemCount: number,\n  itemData: T,\n  itemKey?: (index: number, data: T) => any,\n  itemSize: itemSize,\n  layout: Layout,\n  onItemsRendered?: onItemsRenderedCallback,\n  onScroll?: onScrollCallback,\n  outerRef?: any,\n  outerElementType?: string | React$AbstractComponent<OuterProps, any>,\n  outerTagName?: string, // deprecated\n  overscanCount: number,\n  style?: Object,\n  useIsScrolling: boolean,\n  width: number | string,\n|};\n\ntype State = {|\n  instance: any,\n  isScrolling: boolean,\n  scrollDirection: ScrollDirection,\n  scrollOffset: number,\n  scrollUpdateWasRequested: boolean,\n|};\n\ntype GetItemOffset = (\n  props: Props<any>,\n  index: number,\n  instanceProps: any\n) => number;\ntype GetItemSize = (\n  props: Props<any>,\n  index: number,\n  instanceProps: any\n) => number;\ntype GetEstimatedTotalSize = (props: Props<any>, instanceProps: any) => number;\ntype GetOffsetForIndexAndAlignment = (\n  props: Props<any>,\n  index: number,\n  align: ScrollToAlign,\n  scrollOffset: number,\n  instanceProps: any\n) => number;\ntype GetStartIndexForOffset = (\n  props: Props<any>,\n  offset: number,\n  instanceProps: any\n) => number;\ntype GetStopIndexForStartIndex = (\n  props: Props<any>,\n  startIndex: number,\n  scrollOffset: number,\n  instanceProps: any\n) => number;\ntype InitInstanceProps = (props: Props<any>, instance: any) => any;\ntype ValidateProps = (props: Props<any>) => void;\n\nconst IS_SCROLLING_DEBOUNCE_INTERVAL = 150;\n\nconst defaultItemKey = (index: number, data: any) => index;\n\n// In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\nlet devWarningsDirection = null;\nlet devWarningsTagName = null;\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsDirection = new WeakSet();\n    devWarningsTagName = new WeakSet();\n  }\n}\n\nexport default function createListComponent({\n  getItemOffset,\n  getEstimatedTotalSize,\n  getItemSize,\n  getOffsetForIndexAndAlignment,\n  getStartIndexForOffset,\n  getStopIndexForStartIndex,\n  initInstanceProps,\n  shouldResetStyleCacheOnItemSizeChange,\n  validateProps,\n}: {|\n  getItemOffset: GetItemOffset,\n  getEstimatedTotalSize: GetEstimatedTotalSize,\n  getItemSize: GetItemSize,\n  getOffsetForIndexAndAlignment: GetOffsetForIndexAndAlignment,\n  getStartIndexForOffset: GetStartIndexForOffset,\n  getStopIndexForStartIndex: GetStopIndexForStartIndex,\n  initInstanceProps: InitInstanceProps,\n  shouldResetStyleCacheOnItemSizeChange: boolean,\n  validateProps: ValidateProps,\n|}) {\n  return class List<T> extends PureComponent<Props<T>, State> {\n    _instanceProps: any = initInstanceProps(this.props, this);\n    _outerRef: ?HTMLDivElement;\n    _resetIsScrollingTimeoutId: TimeoutID | null = null;\n\n    static defaultProps = {\n      direction: 'ltr',\n      itemData: undefined,\n      layout: 'vertical',\n      overscanCount: 2,\n      useIsScrolling: false,\n    };\n\n    state: State = {\n      instance: this,\n      isScrolling: false,\n      scrollDirection: 'forward',\n      scrollOffset:\n        typeof this.props.initialScrollOffset === 'number'\n          ? this.props.initialScrollOffset\n          : 0,\n      scrollUpdateWasRequested: false,\n    };\n\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    constructor(props: Props<T>) {\n      super(props);\n    }\n\n    static getDerivedStateFromProps(\n      nextProps: Props<T>,\n      prevState: State\n    ): $Shape<State> | null {\n      validateSharedProps(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    }\n\n    scrollTo(scrollOffset: number): void {\n      scrollOffset = Math.max(0, scrollOffset);\n\n      this.setState(prevState => {\n        if (prevState.scrollOffset === scrollOffset) {\n          return null;\n        }\n        return {\n          scrollDirection:\n            prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n          scrollOffset: scrollOffset,\n          scrollUpdateWasRequested: true,\n        };\n      }, this._resetIsScrollingDebounced);\n    }\n\n    scrollToItem(index: number, align: ScrollToAlign = 'auto'): void {\n      const { itemCount } = this.props;\n      const { scrollOffset } = this.state;\n\n      index = Math.max(0, Math.min(index, itemCount - 1));\n\n      this.scrollTo(\n        getOffsetForIndexAndAlignment(\n          this.props,\n          index,\n          align,\n          scrollOffset,\n          this._instanceProps\n        )\n      );\n    }\n\n    componentDidMount() {\n      const { direction, initialScrollOffset, layout } = this.props;\n\n      if (typeof initialScrollOffset === 'number' && this._outerRef != null) {\n        const outerRef = ((this._outerRef: any): HTMLElement);\n        // TODO Deprecate direction \"horizontal\"\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          outerRef.scrollLeft = initialScrollOffset;\n        } else {\n          outerRef.scrollTop = initialScrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    }\n\n    componentDidUpdate() {\n      const { direction, layout } = this.props;\n      const { scrollOffset, scrollUpdateWasRequested } = this.state;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        const outerRef = ((this._outerRef: any): HTMLElement);\n\n        // TODO Deprecate direction \"horizontal\"\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          if (direction === 'rtl') {\n            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n            // So we need to determine which browser behavior we're dealing with, and mimic it.\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                outerRef.scrollLeft = -scrollOffset;\n                break;\n              case 'positive-ascending':\n                outerRef.scrollLeft = scrollOffset;\n                break;\n              default:\n                const { clientWidth, scrollWidth } = outerRef;\n                outerRef.scrollLeft = scrollWidth - clientWidth - scrollOffset;\n                break;\n            }\n          } else {\n            outerRef.scrollLeft = scrollOffset;\n          }\n        } else {\n          outerRef.scrollTop = scrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    }\n\n    componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    }\n\n    render() {\n      const {\n        children,\n        className,\n        direction,\n        height,\n        innerRef,\n        innerElementType,\n        innerTagName,\n        itemCount,\n        itemData,\n        itemKey = defaultItemKey,\n        layout,\n        outerElementType,\n        outerTagName,\n        style,\n        useIsScrolling,\n        width,\n      } = this.props;\n      const { isScrolling } = this.state;\n\n      // TODO Deprecate direction \"horizontal\"\n      const isHorizontal =\n        direction === 'horizontal' || layout === 'horizontal';\n\n      const onScroll = isHorizontal\n        ? this._onScrollHorizontal\n        : this._onScrollVertical;\n\n      const [startIndex, stopIndex] = this._getRangeToRender();\n\n      const items = [];\n      if (itemCount > 0) {\n        for (let index = startIndex; index <= stopIndex; index++) {\n          items.push(\n            createElement(children, {\n              data: itemData,\n              key: itemKey(index, itemData),\n              index,\n              isScrolling: useIsScrolling ? isScrolling : undefined,\n              style: this._getItemStyle(index),\n            })\n          );\n        }\n      }\n\n      // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n      const estimatedTotalSize = getEstimatedTotalSize(\n        this.props,\n        this._instanceProps\n      );\n\n      return createElement(\n        outerElementType || outerTagName || 'div',\n        {\n          className,\n          onScroll,\n          ref: this._outerRefSetter,\n          style: {\n            position: 'relative',\n            height,\n            width,\n            overflow: 'auto',\n            WebkitOverflowScrolling: 'touch',\n            willChange: 'transform',\n            direction,\n            ...style,\n          },\n        },\n        createElement(innerElementType || innerTagName || 'div', {\n          children: items,\n          ref: innerRef,\n          style: {\n            height: isHorizontal ? '100%' : estimatedTotalSize,\n            pointerEvents: isScrolling ? 'none' : undefined,\n            width: isHorizontal ? estimatedTotalSize : '100%',\n          },\n        })\n      );\n    }\n\n    _callOnItemsRendered: (\n      overscanStartIndex: number,\n      overscanStopIndex: number,\n      visibleStartIndex: number,\n      visibleStopIndex: number\n    ) => void;\n    _callOnItemsRendered = memoizeOne(\n      (\n        overscanStartIndex: number,\n        overscanStopIndex: number,\n        visibleStartIndex: number,\n        visibleStopIndex: number\n      ) =>\n        ((this.props.onItemsRendered: any): onItemsRenderedCallback)({\n          overscanStartIndex,\n          overscanStopIndex,\n          visibleStartIndex,\n          visibleStopIndex,\n        })\n    );\n\n    _callOnScroll: (\n      scrollDirection: ScrollDirection,\n      scrollOffset: number,\n      scrollUpdateWasRequested: boolean\n    ) => void;\n    _callOnScroll = memoizeOne(\n      (\n        scrollDirection: ScrollDirection,\n        scrollOffset: number,\n        scrollUpdateWasRequested: boolean\n      ) =>\n        ((this.props.onScroll: any): onScrollCallback)({\n          scrollDirection,\n          scrollOffset,\n          scrollUpdateWasRequested,\n        })\n    );\n\n    _callPropsCallbacks() {\n      if (typeof this.props.onItemsRendered === 'function') {\n        const { itemCount } = this.props;\n        if (itemCount > 0) {\n          const [\n            overscanStartIndex,\n            overscanStopIndex,\n            visibleStartIndex,\n            visibleStopIndex,\n          ] = this._getRangeToRender();\n          this._callOnItemsRendered(\n            overscanStartIndex,\n            overscanStopIndex,\n            visibleStartIndex,\n            visibleStopIndex\n          );\n        }\n      }\n\n      if (typeof this.props.onScroll === 'function') {\n        const {\n          scrollDirection,\n          scrollOffset,\n          scrollUpdateWasRequested,\n        } = this.state;\n        this._callOnScroll(\n          scrollDirection,\n          scrollOffset,\n          scrollUpdateWasRequested\n        );\n      }\n    }\n\n    // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n    _getItemStyle: (index: number) => Object;\n    _getItemStyle = (index: number): Object => {\n      const { direction, itemSize, layout } = this.props;\n\n      const itemStyleCache = this._getItemStyleCache(\n        shouldResetStyleCacheOnItemSizeChange && itemSize,\n        shouldResetStyleCacheOnItemSizeChange && layout,\n        shouldResetStyleCacheOnItemSizeChange && direction\n      );\n\n      let style;\n      if (itemStyleCache.hasOwnProperty(index)) {\n        style = itemStyleCache[index];\n      } else {\n        const offset = getItemOffset(this.props, index, this._instanceProps);\n        const size = getItemSize(this.props, index, this._instanceProps);\n\n        // TODO Deprecate direction \"horizontal\"\n        const isHorizontal =\n          direction === 'horizontal' || layout === 'horizontal';\n\n        const isRtl = direction === 'rtl';\n        const offsetHorizontal = isHorizontal ? offset : 0;\n        itemStyleCache[index] = style = {\n          position: 'absolute',\n          left: isRtl ? undefined : offsetHorizontal,\n          right: isRtl ? offsetHorizontal : undefined,\n          top: !isHorizontal ? offset : 0,\n          height: !isHorizontal ? size : '100%',\n          width: isHorizontal ? size : '100%',\n        };\n      }\n\n      return style;\n    };\n\n    _getItemStyleCache: (_: any, __: any, ___: any) => ItemStyleCache;\n    _getItemStyleCache = memoizeOne((_: any, __: any, ___: any) => ({}));\n\n    _getRangeToRender(): [number, number, number, number] {\n      const { itemCount, overscanCount } = this.props;\n      const { isScrolling, scrollDirection, scrollOffset } = this.state;\n\n      if (itemCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      const startIndex = getStartIndexForOffset(\n        this.props,\n        scrollOffset,\n        this._instanceProps\n      );\n      const stopIndex = getStopIndexForStartIndex(\n        this.props,\n        startIndex,\n        scrollOffset,\n        this._instanceProps\n      );\n\n      // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n      const overscanBackward =\n        !isScrolling || scrollDirection === 'backward'\n          ? Math.max(1, overscanCount)\n          : 1;\n      const overscanForward =\n        !isScrolling || scrollDirection === 'forward'\n          ? Math.max(1, overscanCount)\n          : 1;\n\n      return [\n        Math.max(0, startIndex - overscanBackward),\n        Math.max(0, Math.min(itemCount - 1, stopIndex + overscanForward)),\n        startIndex,\n        stopIndex,\n      ];\n    }\n\n    _onScrollHorizontal = (event: ScrollEvent): void => {\n      const { clientWidth, scrollLeft, scrollWidth } = event.currentTarget;\n      this.setState(prevState => {\n        if (prevState.scrollOffset === scrollLeft) {\n          // Scroll position may have been updated by cDM/cDU,\n          // In which case we don't need to trigger another render,\n          // And we don't want to update state.isScrolling.\n          return null;\n        }\n\n        const { direction } = this.props;\n\n        let scrollOffset = scrollLeft;\n        if (direction === 'rtl') {\n          // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n          // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n          // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n          // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n          switch (getRTLOffsetType()) {\n            case 'negative':\n              scrollOffset = -scrollLeft;\n              break;\n            case 'positive-descending':\n              scrollOffset = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        }\n\n        // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n        scrollOffset = Math.max(\n          0,\n          Math.min(scrollOffset, scrollWidth - clientWidth)\n        );\n\n        return {\n          isScrolling: true,\n          scrollDirection:\n            prevState.scrollOffset < scrollLeft ? 'forward' : 'backward',\n          scrollOffset,\n          scrollUpdateWasRequested: false,\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _onScrollVertical = (event: ScrollEvent): void => {\n      const { clientHeight, scrollHeight, scrollTop } = event.currentTarget;\n      this.setState(prevState => {\n        if (prevState.scrollOffset === scrollTop) {\n          // Scroll position may have been updated by cDM/cDU,\n          // In which case we don't need to trigger another render,\n          // And we don't want to update state.isScrolling.\n          return null;\n        }\n\n        // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n        const scrollOffset = Math.max(\n          0,\n          Math.min(scrollTop, scrollHeight - clientHeight)\n        );\n\n        return {\n          isScrolling: true,\n          scrollDirection:\n            prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n          scrollOffset,\n          scrollUpdateWasRequested: false,\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _outerRefSetter = (ref: any): void => {\n      const { outerRef } = this.props;\n\n      this._outerRef = ((ref: any): HTMLDivElement);\n\n      if (typeof outerRef === 'function') {\n        outerRef(ref);\n      } else if (\n        outerRef != null &&\n        typeof outerRef === 'object' &&\n        outerRef.hasOwnProperty('current')\n      ) {\n        outerRef.current = ref;\n      }\n    };\n\n    _resetIsScrollingDebounced = () => {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n\n      this._resetIsScrollingTimeoutId = requestTimeout(\n        this._resetIsScrolling,\n        IS_SCROLLING_DEBOUNCE_INTERVAL\n      );\n    };\n\n    _resetIsScrolling = () => {\n      this._resetIsScrollingTimeoutId = null;\n\n      this.setState({ isScrolling: false }, () => {\n        // Clear style cache after state update has been committed.\n        // This way we don't break pure sCU for items that don't use isScrolling param.\n        this._getItemStyleCache(-1, null);\n      });\n    };\n  };\n}\n\n// NOTE: I considered further wrapping individual items with a pure ListItem component.\n// This would avoid ever calling the render function for the same index more than once,\n// But it would also add the overhead of a lot of components/fibers.\n// I assume people already do this (render function returning a class component),\n// So my doing it would just unnecessarily double the wrappers.\n\nconst validateSharedProps = (\n  {\n    children,\n    direction,\n    height,\n    layout,\n    innerTagName,\n    outerTagName,\n    width,\n  }: Props<any>,\n  { instance }: State\n): void => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName && !devWarningsTagName.has(instance)) {\n        devWarningsTagName.add(instance);\n        console.warn(\n          'The innerTagName and outerTagName props have been deprecated. ' +\n            'Please use the innerElementType and outerElementType props instead.'\n        );\n      }\n    }\n\n    // TODO Deprecate direction \"horizontal\"\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n\n    switch (direction) {\n      case 'horizontal':\n      case 'vertical':\n        if (devWarningsDirection && !devWarningsDirection.has(instance)) {\n          devWarningsDirection.add(instance);\n          console.warn(\n            'The direction prop should be either \"ltr\" (default) or \"rtl\". ' +\n              'Please use the layout prop to specify \"vertical\" (default) or \"horizontal\" orientation.'\n          );\n        }\n        break;\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n      default:\n        throw Error(\n          'An invalid \"direction\" prop has been specified. ' +\n            'Value should be either \"ltr\" or \"rtl\". ' +\n            `\"${direction}\" was specified.`\n        );\n    }\n\n    switch (layout) {\n      case 'horizontal':\n      case 'vertical':\n        // Valid values\n        break;\n      default:\n        throw Error(\n          'An invalid \"layout\" prop has been specified. ' +\n            'Value should be either \"horizontal\" or \"vertical\". ' +\n            `\"${layout}\" was specified.`\n        );\n    }\n\n    if (children == null) {\n      throw Error(\n        'An invalid \"children\" prop has been specified. ' +\n          'Value should be a React component. ' +\n          `\"${children === null ? 'null' : typeof children}\" was specified.`\n      );\n    }\n\n    if (isHorizontal && typeof width !== 'number') {\n      throw Error(\n        'An invalid \"width\" prop has been specified. ' +\n          'Horizontal lists must specify a number for width. ' +\n          `\"${width === null ? 'null' : typeof width}\" was specified.`\n      );\n    } else if (!isHorizontal && typeof height !== 'number') {\n      throw Error(\n        'An invalid \"height\" prop has been specified. ' +\n          'Vertical lists must specify a number for height. ' +\n          `\"${height === null ? 'null' : typeof height}\" was specified.`\n      );\n    }\n  }\n};\n","// @flow\n\nimport createListComponent from './createListComponent';\n\nimport type { Props, ScrollToAlign } from './createListComponent';\n\nconst DEFAULT_ESTIMATED_ITEM_SIZE = 50;\n\ntype VariableSizeProps = {|\n  estimatedItemSize: number,\n  ...Props<any>,\n|};\n\ntype itemSizeGetter = (index: number) => number;\n\ntype ItemMetadata = {|\n  offset: number,\n  size: number,\n|};\ntype InstanceProps = {|\n  itemMetadataMap: { [index: number]: ItemMetadata },\n  estimatedItemSize: number,\n  lastMeasuredIndex: number,\n|};\n\nconst getItemMetadata = (\n  props: Props<any>,\n  index: number,\n  instanceProps: InstanceProps\n): ItemMetadata => {\n  const { itemSize } = ((props: any): VariableSizeProps);\n  const { itemMetadataMap, lastMeasuredIndex } = instanceProps;\n\n  if (index > lastMeasuredIndex) {\n    let offset = 0;\n    if (lastMeasuredIndex >= 0) {\n      const itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (let i = lastMeasuredIndex + 1; i <= index; i++) {\n      let size = ((itemSize: any): itemSizeGetter)(i);\n\n      itemMetadataMap[i] = {\n        offset,\n        size,\n      };\n\n      offset += size;\n    }\n\n    instanceProps.lastMeasuredIndex = index;\n  }\n\n  return itemMetadataMap[index];\n};\n\nconst findNearestItem = (\n  props: Props<any>,\n  instanceProps: InstanceProps,\n  offset: number\n) => {\n  const { itemMetadataMap, lastMeasuredIndex } = instanceProps;\n\n  const lastMeasuredItemOffset =\n    lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch(\n      props,\n      instanceProps,\n      lastMeasuredIndex,\n      0,\n      offset\n    );\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch(\n      props,\n      instanceProps,\n      Math.max(0, lastMeasuredIndex),\n      offset\n    );\n  }\n};\n\nconst findNearestItemBinarySearch = (\n  props: Props<any>,\n  instanceProps: InstanceProps,\n  high: number,\n  low: number,\n  offset: number\n): number => {\n  while (low <= high) {\n    const middle = low + Math.floor((high - low) / 2);\n    const currentOffset = getItemMetadata(props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nconst findNearestItemExponentialSearch = (\n  props: Props<any>,\n  instanceProps: InstanceProps,\n  index: number,\n  offset: number\n): number => {\n  const { itemCount } = props;\n  let interval = 1;\n\n  while (\n    index < itemCount &&\n    getItemMetadata(props, index, instanceProps).offset < offset\n  ) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch(\n    props,\n    instanceProps,\n    Math.min(index, itemCount - 1),\n    Math.floor(index / 2),\n    offset\n  );\n};\n\nconst getEstimatedTotalSize = (\n  { itemCount }: Props<any>,\n  { itemMetadataMap, estimatedItemSize, lastMeasuredIndex }: InstanceProps\n) => {\n  let totalSizeOfMeasuredItems = 0;\n\n  // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n  if (lastMeasuredIndex >= itemCount) {\n    lastMeasuredIndex = itemCount - 1;\n  }\n\n  if (lastMeasuredIndex >= 0) {\n    const itemMetadata = itemMetadataMap[lastMeasuredIndex];\n    totalSizeOfMeasuredItems = itemMetadata.offset + itemMetadata.size;\n  }\n\n  const numUnmeasuredItems = itemCount - lastMeasuredIndex - 1;\n  const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;\n\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;\n};\n\nconst VariableSizeList = createListComponent({\n  getItemOffset: (\n    props: Props<any>,\n    index: number,\n    instanceProps: InstanceProps\n  ): number => getItemMetadata(props, index, instanceProps).offset,\n\n  getItemSize: (\n    props: Props<any>,\n    index: number,\n    instanceProps: InstanceProps\n  ): number => instanceProps.itemMetadataMap[index].size,\n\n  getEstimatedTotalSize,\n\n  getOffsetForIndexAndAlignment: (\n    props: Props<any>,\n    index: number,\n    align: ScrollToAlign,\n    scrollOffset: number,\n    instanceProps: InstanceProps\n  ): number => {\n    const { direction, height, layout, width } = props;\n\n    // TODO Deprecate direction \"horizontal\"\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    const size = (((isHorizontal ? width : height): any): number);\n    const itemMetadata = getItemMetadata(props, index, instanceProps);\n\n    // Get estimated total size after ItemMetadata is computed,\n    // To ensure it reflects actual measurements instead of just estimates.\n    const estimatedTotalSize = getEstimatedTotalSize(props, instanceProps);\n\n    const maxOffset = Math.max(\n      0,\n      Math.min(estimatedTotalSize - size, itemMetadata.offset)\n    );\n    const minOffset = Math.max(\n      0,\n      itemMetadata.offset - size + itemMetadata.size\n    );\n\n    if (align === 'smart') {\n      if (\n        scrollOffset >= minOffset - size &&\n        scrollOffset <= maxOffset + size\n      ) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n      case 'end':\n        return minOffset;\n      case 'center':\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n    }\n  },\n\n  getStartIndexForOffset: (\n    props: Props<any>,\n    offset: number,\n    instanceProps: InstanceProps\n  ): number => findNearestItem(props, instanceProps, offset),\n\n  getStopIndexForStartIndex: (\n    props: Props<any>,\n    startIndex: number,\n    scrollOffset: number,\n    instanceProps: InstanceProps\n  ): number => {\n    const { direction, height, itemCount, layout, width } = props;\n\n    // TODO Deprecate direction \"horizontal\"\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    const size = (((isHorizontal ? width : height): any): number);\n    const itemMetadata = getItemMetadata(props, startIndex, instanceProps);\n    const maxOffset = scrollOffset + size;\n\n    let offset = itemMetadata.offset + itemMetadata.size;\n    let stopIndex = startIndex;\n\n    while (stopIndex < itemCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata(props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n\n  initInstanceProps(props: Props<any>, instance: any): InstanceProps {\n    const { estimatedItemSize } = ((props: any): VariableSizeProps);\n\n    const instanceProps = {\n      itemMetadataMap: {},\n      estimatedItemSize: estimatedItemSize || DEFAULT_ESTIMATED_ITEM_SIZE,\n      lastMeasuredIndex: -1,\n    };\n\n    instance.resetAfterIndex = (\n      index: number,\n      shouldForceUpdate?: boolean = true\n    ) => {\n      instanceProps.lastMeasuredIndex = Math.min(\n        instanceProps.lastMeasuredIndex,\n        index - 1\n      );\n\n      // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n\n  shouldResetStyleCacheOnItemSizeChange: false,\n\n  validateProps: ({ itemSize }: Props<any>): void => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'function') {\n        throw Error(\n          'An invalid \"itemSize\" prop has been specified. ' +\n            'Value should be a function. ' +\n            `\"${itemSize === null ? 'null' : typeof itemSize}\" was specified.`\n        );\n      }\n    }\n  },\n});\n\nexport default VariableSizeList;\n","// @flow\n\nimport createGridComponent from './createGridComponent';\n\nimport type { Props, ScrollToAlign } from './createGridComponent';\n\nconst FixedSizeGrid = createGridComponent({\n  getColumnOffset: ({ columnWidth }: Props<any>, index: number): number =>\n    index * ((columnWidth: any): number),\n\n  getColumnWidth: ({ columnWidth }: Props<any>, index: number): number =>\n    ((columnWidth: any): number),\n\n  getRowOffset: ({ rowHeight }: Props<any>, index: number): number =>\n    index * ((rowHeight: any): number),\n\n  getRowHeight: ({ rowHeight }: Props<any>, index: number): number =>\n    ((rowHeight: any): number),\n\n  getEstimatedTotalHeight: ({ rowCount, rowHeight }: Props<any>) =>\n    ((rowHeight: any): number) * rowCount,\n\n  getEstimatedTotalWidth: ({ columnCount, columnWidth }: Props<any>) =>\n    ((columnWidth: any): number) * columnCount,\n\n  getOffsetForColumnAndAlignment: (\n    { columnCount, columnWidth, width }: Props<any>,\n    columnIndex: number,\n    align: ScrollToAlign,\n    scrollLeft: number,\n    instanceProps: typeof undefined,\n    scrollbarSize: number\n  ): number => {\n    const lastColumnOffset = Math.max(\n      0,\n      columnCount * ((columnWidth: any): number) - width\n    );\n    const maxOffset = Math.min(\n      lastColumnOffset,\n      columnIndex * ((columnWidth: any): number)\n    );\n    const minOffset = Math.max(\n      0,\n      columnIndex * ((columnWidth: any): number) -\n        width +\n        scrollbarSize +\n        ((columnWidth: any): number)\n    );\n\n    if (align === 'smart') {\n      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n      case 'end':\n        return minOffset;\n      case 'center':\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        const middleOffset = Math.round(\n          minOffset + (maxOffset - minOffset) / 2\n        );\n        if (middleOffset < Math.ceil(width / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {\n          return lastColumnOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n      case 'auto':\n      default:\n        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {\n          return scrollLeft;\n        } else if (minOffset > maxOffset) {\n          // Because we only take into account the scrollbar size when calculating minOffset\n          // this value can be larger than maxOffset when at the end of the list\n          return minOffset;\n        } else if (scrollLeft < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n    }\n  },\n\n  getOffsetForRowAndAlignment: (\n    { rowHeight, height, rowCount }: Props<any>,\n    rowIndex: number,\n    align: ScrollToAlign,\n    scrollTop: number,\n    instanceProps: typeof undefined,\n    scrollbarSize: number\n  ): number => {\n    const lastRowOffset = Math.max(\n      0,\n      rowCount * ((rowHeight: any): number) - height\n    );\n    const maxOffset = Math.min(\n      lastRowOffset,\n      rowIndex * ((rowHeight: any): number)\n    );\n    const minOffset = Math.max(\n      0,\n      rowIndex * ((rowHeight: any): number) -\n        height +\n        scrollbarSize +\n        ((rowHeight: any): number)\n    );\n\n    if (align === 'smart') {\n      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n      case 'end':\n        return minOffset;\n      case 'center':\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        const middleOffset = Math.round(\n          minOffset + (maxOffset - minOffset) / 2\n        );\n        if (middleOffset < Math.ceil(height / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {\n          return lastRowOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n      case 'auto':\n      default:\n        if (scrollTop >= minOffset && scrollTop <= maxOffset) {\n          return scrollTop;\n        } else if (minOffset > maxOffset) {\n          // Because we only take into account the scrollbar size when calculating minOffset\n          // this value can be larger than maxOffset when at the end of the list\n          return minOffset;\n        } else if (scrollTop < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n    }\n  },\n\n  getColumnStartIndexForOffset: (\n    { columnWidth, columnCount }: Props<any>,\n    scrollLeft: number\n  ): number =>\n    Math.max(\n      0,\n      Math.min(\n        columnCount - 1,\n        Math.floor(scrollLeft / ((columnWidth: any): number))\n      )\n    ),\n\n  getColumnStopIndexForStartIndex: (\n    { columnWidth, columnCount, width }: Props<any>,\n    startIndex: number,\n    scrollLeft: number\n  ): number => {\n    const left = startIndex * ((columnWidth: any): number);\n    const numVisibleColumns = Math.ceil(\n      (width + scrollLeft - left) / ((columnWidth: any): number)\n    );\n    return Math.max(\n      0,\n      Math.min(\n        columnCount - 1,\n        startIndex + numVisibleColumns - 1 // -1 is because stop index is inclusive\n      )\n    );\n  },\n\n  getRowStartIndexForOffset: (\n    { rowHeight, rowCount }: Props<any>,\n    scrollTop: number\n  ): number =>\n    Math.max(\n      0,\n      Math.min(rowCount - 1, Math.floor(scrollTop / ((rowHeight: any): number)))\n    ),\n\n  getRowStopIndexForStartIndex: (\n    { rowHeight, rowCount, height }: Props<any>,\n    startIndex: number,\n    scrollTop: number\n  ): number => {\n    const top = startIndex * ((rowHeight: any): number);\n    const numVisibleRows = Math.ceil(\n      (height + scrollTop - top) / ((rowHeight: any): number)\n    );\n    return Math.max(\n      0,\n      Math.min(\n        rowCount - 1,\n        startIndex + numVisibleRows - 1 // -1 is because stop index is inclusive\n      )\n    );\n  },\n\n  initInstanceProps(props: Props<any>): any {\n    // Noop\n  },\n\n  shouldResetStyleCacheOnItemSizeChange: true,\n\n  validateProps: ({ columnWidth, rowHeight }: Props<any>): void => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'number') {\n        throw Error(\n          'An invalid \"columnWidth\" prop has been specified. ' +\n            'Value should be a number. ' +\n            `\"${\n              columnWidth === null ? 'null' : typeof columnWidth\n            }\" was specified.`\n        );\n      }\n\n      if (typeof rowHeight !== 'number') {\n        throw Error(\n          'An invalid \"rowHeight\" prop has been specified. ' +\n            'Value should be a number. ' +\n            `\"${rowHeight === null ? 'null' : typeof rowHeight}\" was specified.`\n        );\n      }\n    }\n  },\n});\n\nexport default FixedSizeGrid;\n","// @flow\n\nimport createListComponent from './createListComponent';\n\nimport type { Props, ScrollToAlign } from './createListComponent';\n\nconst FixedSizeList = createListComponent({\n  getItemOffset: ({ itemSize }: Props<any>, index: number): number =>\n    index * ((itemSize: any): number),\n\n  getItemSize: ({ itemSize }: Props<any>, index: number): number =>\n    ((itemSize: any): number),\n\n  getEstimatedTotalSize: ({ itemCount, itemSize }: Props<any>) =>\n    ((itemSize: any): number) * itemCount,\n\n  getOffsetForIndexAndAlignment: (\n    { direction, height, itemCount, itemSize, layout, width }: Props<any>,\n    index: number,\n    align: ScrollToAlign,\n    scrollOffset: number\n  ): number => {\n    // TODO Deprecate direction \"horizontal\"\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    const size = (((isHorizontal ? width : height): any): number);\n    const lastItemOffset = Math.max(\n      0,\n      itemCount * ((itemSize: any): number) - size\n    );\n    const maxOffset = Math.min(\n      lastItemOffset,\n      index * ((itemSize: any): number)\n    );\n    const minOffset = Math.max(\n      0,\n      index * ((itemSize: any): number) - size + ((itemSize: any): number)\n    );\n\n    if (align === 'smart') {\n      if (\n        scrollOffset >= minOffset - size &&\n        scrollOffset <= maxOffset + size\n      ) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n      case 'end':\n        return minOffset;\n      case 'center': {\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        const middleOffset = Math.round(\n          minOffset + (maxOffset - minOffset) / 2\n        );\n        if (middleOffset < Math.ceil(size / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {\n          return lastItemOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n      }\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n    }\n  },\n\n  getStartIndexForOffset: (\n    { itemCount, itemSize }: Props<any>,\n    offset: number\n  ): number =>\n    Math.max(\n      0,\n      Math.min(itemCount - 1, Math.floor(offset / ((itemSize: any): number)))\n    ),\n\n  getStopIndexForStartIndex: (\n    { direction, height, itemCount, itemSize, layout, width }: Props<any>,\n    startIndex: number,\n    scrollOffset: number\n  ): number => {\n    // TODO Deprecate direction \"horizontal\"\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    const offset = startIndex * ((itemSize: any): number);\n    const size = (((isHorizontal ? width : height): any): number);\n    const numVisibleItems = Math.ceil(\n      (size + scrollOffset - offset) / ((itemSize: any): number)\n    );\n    return Math.max(\n      0,\n      Math.min(\n        itemCount - 1,\n        startIndex + numVisibleItems - 1 // -1 is because stop index is inclusive\n      )\n    );\n  },\n\n  initInstanceProps(props: Props<any>): any {\n    // Noop\n  },\n\n  shouldResetStyleCacheOnItemSizeChange: true,\n\n  validateProps: ({ itemSize }: Props<any>): void => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'number') {\n        throw Error(\n          'An invalid \"itemSize\" prop has been specified. ' +\n            'Value should be a number. ' +\n            `\"${itemSize === null ? 'null' : typeof itemSize}\" was specified.`\n        );\n      }\n    }\n  },\n});\n\nexport default FixedSizeList;\n","// @flow\n\n// Pulled from react-compat\n// https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349\nexport default function shallowDiffers(prev: Object, next: Object): boolean {\n  for (let attribute in prev) {\n    if (!(attribute in next)) {\n      return true;\n    }\n  }\n  for (let attribute in next) {\n    if (prev[attribute] !== next[attribute]) {\n      return true;\n    }\n  }\n  return false;\n}\n","// @flow\n\nimport shallowDiffers from './shallowDiffers';\n\n// Custom comparison function for React.memo().\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-api.html#reactmemo\nexport default function areEqual(\n  prevProps: Object,\n  nextProps: Object\n): boolean {\n  const { style: prevStyle, ...prevRest } = prevProps;\n  const { style: nextStyle, ...nextRest } = nextProps;\n\n  return (\n    !shallowDiffers(prevStyle, nextStyle) && !shallowDiffers(prevRest, nextRest)\n  );\n}\n","// @flow\n\nimport areEqual from './areEqual';\nimport shallowDiffers from './shallowDiffers';\n\n// Custom shouldComponentUpdate for class components.\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-component.html#shouldcomponentupdate\nexport default function shouldComponentUpdate(\n  nextProps: Object,\n  nextState: Object\n): boolean {\n  return (\n    !areEqual(this.props, nextProps) || shallowDiffers(this.state, nextState)\n  );\n}\n"],"names":["hasNativePerformanceNow","performance","now","Date","cancelTimeout","timeoutID","cancelAnimationFrame","id","requestTimeout","callback","delay","start","tick","call","requestAnimationFrame","size","getScrollbarSize","recalculate","div","document","createElement","style","width","height","overflow","body","appendChild","offsetWidth","clientWidth","removeChild","cachedRTLResult","getRTLOffsetType","outerDiv","outerStyle","direction","innerDiv","innerStyle","scrollLeft","IS_SCROLLING_DEBOUNCE_INTERVAL","defaultItemKey","columnIndex","data","rowIndex","devWarningsOverscanCount","devWarningsOverscanRowsColumnsCount","devWarningsTagName","process","env","NODE_ENV","window","WeakSet","createGridComponent","getColumnOffset","getColumnStartIndexForOffset","getColumnStopIndexForStartIndex","getColumnWidth","getEstimatedTotalHeight","getEstimatedTotalWidth","getOffsetForColumnAndAlignment","getOffsetForRowAndAlignment","getRowHeight","getRowOffset","getRowStartIndexForOffset","getRowStopIndexForStartIndex","initInstanceProps","shouldResetStyleCacheOnItemSizeChange","validateProps","props","_instanceProps","_resetIsScrollingTimeoutId","_outerRef","state","instance","isScrolling","horizontalScrollDirection","initialScrollLeft","scrollTop","initialScrollTop","scrollUpdateWasRequested","verticalScrollDirection","_callOnItemsRendered","memoizeOne","overscanColumnStartIndex","overscanColumnStopIndex","overscanRowStartIndex","overscanRowStopIndex","visibleColumnStartIndex","visibleColumnStopIndex","visibleRowStartIndex","visibleRowStopIndex","onItemsRendered","_callOnScroll","onScroll","_getItemStyle","columnWidth","rowHeight","itemStyleCache","_getItemStyleCache","key","hasOwnProperty","offset","isRtl","position","left","undefined","right","top","_","__","___","_onScroll","event","currentTarget","clientHeight","scrollHeight","scrollWidth","setState","prevState","calculatedScrollLeft","Math","max","min","calculatedScrollTop","_resetIsScrollingDebounced","_outerRefSetter","ref","outerRef","current","_resetIsScrolling","getDerivedStateFromProps","nextProps","validateSharedProps","scrollTo","scrollToItem","align","columnCount","rowCount","scrollbarSize","estimatedTotalHeight","estimatedTotalWidth","horizontalScrollbarSize","verticalScrollbarSize","componentDidMount","_callPropsCallbacks","componentDidUpdate","componentWillUnmount","render","children","className","innerRef","innerElementType","innerTagName","itemData","itemKey","outerElementType","outerTagName","useIsScrolling","_getHorizontalRangeToRender","columnStartIndex","columnStopIndex","_getVerticalRangeToRender","rowStartIndex","rowStopIndex","items","push","WebkitOverflowScrolling","willChange","pointerEvents","overscanColumnCount","overscanColumnsCount","overscanCount","overscanCountResolved","startIndex","stopIndex","overscanBackward","overscanForward","overscanRowCount","overscanRowsCount","PureComponent","defaultProps","has","add","console","warn","Error","DEFAULT_ESTIMATED_ITEM_SIZE","rowMetadataMap","estimatedRowHeight","lastMeasuredRowIndex","totalSizeOfMeasuredRows","itemMetadata","numUnmeasuredItems","totalSizeOfUnmeasuredItems","columnMetadataMap","estimatedColumnWidth","lastMeasuredColumnIndex","getItemMetadata","itemType","index","instanceProps","itemMetadataMap","itemSize","lastMeasuredIndex","i","findNearestItem","lastMeasuredItemOffset","findNearestItemBinarySearch","findNearestItemExponentialSearch","high","low","middle","floor","currentOffset","itemCount","interval","getOffsetForIndexAndAlignment","scrollOffset","estimatedTotalSize","maxOffset","minOffset","round","VariableSizeGrid","resetAfterColumnIndex","shouldForceUpdate","resetAfterIndices","resetAfterRowIndex","forceUpdate","devWarningsDirection","createListComponent","getItemOffset","getEstimatedTotalSize","getItemSize","getStartIndexForOffset","getStopIndexForStartIndex","scrollDirection","initialScrollOffset","overscanStartIndex","overscanStopIndex","visibleStartIndex","visibleStopIndex","layout","isHorizontal","offsetHorizontal","_onScrollHorizontal","_onScrollVertical","_getRangeToRender","estimatedItemSize","totalSizeOfMeasuredItems","VariableSizeList","resetAfterIndex","FixedSizeGrid","lastColumnOffset","middleOffset","ceil","lastRowOffset","numVisibleColumns","numVisibleRows","FixedSizeList","lastItemOffset","numVisibleItems","shallowDiffers","prev","next","attribute","areEqual","prevProps","prevStyle","prevRest","nextStyle","nextRest","shouldComponentUpdate","nextState"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"index.cjs.js","sources":["../src/timer.js","../src/domHelpers.js","../src/createGridComponent.js","../src/VariableSizeGrid.js","../src/createListComponent.js","../src/VariableSizeList.js","../src/FixedSizeGrid.js","../src/FixedSizeList.js","../src/shallowDiffers.js","../src/areEqual.js","../src/shouldComponentUpdate.js"],"sourcesContent":["// @flow\r\n\r\n// Animation frame based implementation of setTimeout.\r\n// Inspired by Joe Lambert, https://gist.github.com/joelambert/1002116#file-requesttimeout-js\r\n\r\nconst hasNativePerformanceNow =\r\n  typeof performance === 'object' && typeof performance.now === 'function';\r\n\r\nconst now = hasNativePerformanceNow\r\n  ? () => performance.now()\r\n  : () => Date.now();\r\n\r\nexport type TimeoutID = {|\r\n  id: AnimationFrameID,\r\n|};\r\n\r\nexport function cancelTimeout(timeoutID: TimeoutID) {\r\n  cancelAnimationFrame(timeoutID.id);\r\n}\r\n\r\nexport function requestTimeout(callback: Function, delay: number): TimeoutID {\r\n  const start = now();\r\n\r\n  function tick() {\r\n    if (now() - start >= delay) {\r\n      callback.call(null);\r\n    } else {\r\n      timeoutID.id = requestAnimationFrame(tick);\r\n    }\r\n  }\r\n\r\n  const timeoutID: TimeoutID = {\r\n    id: requestAnimationFrame(tick),\r\n  };\r\n\r\n  return timeoutID;\r\n}\r\n","// @flow\r\n\r\nlet size: number = -1;\r\n\r\n// This utility copied from \"dom-helpers\" package.\r\nexport function getScrollbarSize(recalculate?: boolean = false): number {\r\n  if (size === -1 || recalculate) {\r\n    const div = document.createElement('div');\r\n    const style = div.style;\r\n    style.width = '50px';\r\n    style.height = '50px';\r\n    style.overflow = 'scroll';\r\n\r\n    ((document.body: any): HTMLBodyElement).appendChild(div);\r\n\r\n    size = div.offsetWidth - div.clientWidth;\r\n\r\n    ((document.body: any): HTMLBodyElement).removeChild(div);\r\n  }\r\n\r\n  return size;\r\n}\r\n\r\nexport type RTLOffsetType =\r\n  | 'negative'\r\n  | 'positive-descending'\r\n  | 'positive-ascending';\r\n\r\nlet cachedRTLResult: RTLOffsetType | null = null;\r\n\r\n// TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\r\n// Chrome does not seem to adhere; its scrollLeft values are positive (measured relative to the left).\r\n// Safari's elastic bounce makes detecting this even more complicated wrt potential false positives.\r\n// The safest way to check this is to intentionally set a negative offset,\r\n// and then verify that the subsequent \"scroll\" event matches the negative offset.\r\n// If it does not match, then we can assume a non-standard RTL scroll implementation.\r\nexport function getRTLOffsetType(recalculate?: boolean = false): RTLOffsetType {\r\n  if (cachedRTLResult === null || recalculate) {\r\n    const outerDiv = document.createElement('div');\r\n    const outerStyle = outerDiv.style;\r\n    outerStyle.width = '50px';\r\n    outerStyle.height = '50px';\r\n    outerStyle.overflow = 'scroll';\r\n    outerStyle.direction = 'rtl';\r\n\r\n    const innerDiv = document.createElement('div');\r\n    const innerStyle = innerDiv.style;\r\n    innerStyle.width = '100px';\r\n    innerStyle.height = '100px';\r\n\r\n    outerDiv.appendChild(innerDiv);\r\n\r\n    ((document.body: any): HTMLBodyElement).appendChild(outerDiv);\r\n\r\n    if (outerDiv.scrollLeft > 0) {\r\n      cachedRTLResult = 'positive-descending';\r\n    } else {\r\n      outerDiv.scrollLeft = 1;\r\n      if (outerDiv.scrollLeft === 0) {\r\n        cachedRTLResult = 'negative';\r\n      } else {\r\n        cachedRTLResult = 'positive-ascending';\r\n      }\r\n    }\r\n\r\n    ((document.body: any): HTMLBodyElement).removeChild(outerDiv);\r\n\r\n    return cachedRTLResult;\r\n  }\r\n\r\n  return cachedRTLResult;\r\n}\r\n","// @flow\r\n\r\nimport memoizeOne from 'memoize-one';\r\nimport { createElement, PureComponent } from 'react';\r\nimport { cancelTimeout, requestTimeout } from './timer';\r\nimport { getScrollbarSize, getRTLOffsetType } from './domHelpers';\r\n\r\nimport type { TimeoutID } from './timer';\r\n\r\ntype Direction = 'ltr' | 'rtl';\r\nexport type ScrollToAlign = 'auto' | 'smart' | 'center' | 'start' | 'end';\r\n\r\ntype itemSize = number | ((index: number) => number);\r\n\r\ntype RenderComponentProps<T> = {|\r\n  columnIndex: number,\r\n  data: T,\r\n  isScrolling?: boolean,\r\n  rowIndex: number,\r\n  style: Object,\r\n|};\r\nexport type RenderComponent<T> = React$ComponentType<\r\n  $Shape<RenderComponentProps<T>>\r\n>;\r\n\r\ntype ScrollDirection = 'forward' | 'backward';\r\n\r\ntype OnItemsRenderedCallback = ({\r\n  overscanColumnStartIndex: number,\r\n  overscanColumnStopIndex: number,\r\n  overscanRowStartIndex: number,\r\n  overscanRowStopIndex: number,\r\n  visibleColumnStartIndex: number,\r\n  visibleColumnStopIndex: number,\r\n  visibleRowStartIndex: number,\r\n  visibleRowStopIndex: number,\r\n}) => void;\r\ntype OnScrollCallback = ({\r\n  horizontalScrollDirection: ScrollDirection,\r\n  scrollLeft: number,\r\n  scrollTop: number,\r\n  scrollUpdateWasRequested: boolean,\r\n  verticalScrollDirection: ScrollDirection,\r\n}) => void;\r\n\r\ntype ScrollEvent = SyntheticEvent<HTMLDivElement>;\r\ntype ItemStyleCache = { [key: string]: Object };\r\n\r\ntype OuterProps = {|\r\n  children: React$Node,\r\n  className: string | void,\r\n  onScroll: ScrollEvent => void,\r\n  style: {\r\n    [string]: mixed,\r\n  },\r\n|};\r\n\r\ntype InnerProps = {|\r\n  children: React$Node,\r\n  style: {\r\n    [string]: mixed,\r\n  },\r\n|};\r\n\r\nexport type Props<T> = {|\r\n  children: RenderComponent<T>,\r\n  className?: string,\r\n  columnCount: number,\r\n  columnWidth: itemSize,\r\n  direction: Direction,\r\n  height: number,\r\n  initialScrollLeft?: number,\r\n  initialScrollTop?: number,\r\n  innerRef?: any,\r\n  innerElementType?: string | React$AbstractComponent<InnerProps, any>,\r\n  innerTagName?: string, // deprecated\r\n  itemData: T,\r\n  itemKey?: (params: {|\r\n    columnIndex: number,\r\n    data: T,\r\n    rowIndex: number,\r\n  |}) => any,\r\n  onItemsRendered?: OnItemsRenderedCallback,\r\n  onScroll?: OnScrollCallback,\r\n  outerRef?: any,\r\n  outerElementType?: string | React$AbstractComponent<OuterProps, any>,\r\n  outerTagName?: string, // deprecated\r\n  overscanColumnCount?: number,\r\n  overscanColumnsCount?: number, // deprecated\r\n  overscanCount?: number, // deprecated\r\n  overscanRowCount?: number,\r\n  overscanRowsCount?: number, // deprecated\r\n  rowCount: number,\r\n  rowHeight: itemSize,\r\n  style?: Object,\r\n  useIsScrolling: boolean,\r\n  width: number,\r\n|};\r\n\r\ntype State = {|\r\n  instance: any,\r\n  isScrolling: boolean,\r\n  horizontalScrollDirection: ScrollDirection,\r\n  scrollLeft: number,\r\n  scrollTop: number,\r\n  scrollUpdateWasRequested: boolean,\r\n  verticalScrollDirection: ScrollDirection,\r\n|};\r\n\r\ntype getItemOffset = (\r\n  props: Props<any>,\r\n  index: number,\r\n  instanceProps: any\r\n) => number;\r\ntype getItemSize = (\r\n  props: Props<any>,\r\n  index: number,\r\n  instanceProps: any\r\n) => number;\r\ntype getEstimatedTotalSize = (props: Props<any>, instanceProps: any) => number;\r\ntype GetOffsetForItemAndAlignment = (\r\n  props: Props<any>,\r\n  index: number,\r\n  align: ScrollToAlign,\r\n  scrollOffset: number,\r\n  instanceProps: any,\r\n  scrollbarSize: number\r\n) => number;\r\ntype GetStartIndexForOffset = (\r\n  props: Props<any>,\r\n  offset: number,\r\n  instanceProps: any\r\n) => number;\r\ntype GetStopIndexForStartIndex = (\r\n  props: Props<any>,\r\n  startIndex: number,\r\n  scrollOffset: number,\r\n  instanceProps: any\r\n) => number;\r\ntype InitInstanceProps = (props: Props<any>, instance: any) => any;\r\ntype ValidateProps = (props: Props<any>) => void;\r\n\r\nconst IS_SCROLLING_DEBOUNCE_INTERVAL = 150;\r\n\r\nconst defaultItemKey = ({ columnIndex, data, rowIndex }) =>\r\n  `${rowIndex}:${columnIndex}`;\r\n\r\n// In DEV mode, this Set helps us only log a warning once per component instance.\r\n// This avoids spamming the console every time a render happens.\r\nlet devWarningsOverscanCount = null;\r\nlet devWarningsOverscanRowsColumnsCount = null;\r\nlet devWarningsTagName = null;\r\nif (process.env.NODE_ENV !== 'production') {\r\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\r\n    devWarningsOverscanCount = new WeakSet();\r\n    devWarningsOverscanRowsColumnsCount = new WeakSet();\r\n    devWarningsTagName = new WeakSet();\r\n  }\r\n}\r\n\r\nexport default function createGridComponent({\r\n  getColumnOffset,\r\n  getColumnStartIndexForOffset,\r\n  getColumnStopIndexForStartIndex,\r\n  getColumnWidth,\r\n  getEstimatedTotalHeight,\r\n  getEstimatedTotalWidth,\r\n  getOffsetForColumnAndAlignment,\r\n  getOffsetForRowAndAlignment,\r\n  getRowHeight,\r\n  getRowOffset,\r\n  getRowStartIndexForOffset,\r\n  getRowStopIndexForStartIndex,\r\n  initInstanceProps,\r\n  shouldResetStyleCacheOnItemSizeChange,\r\n  validateProps,\r\n}: {|\r\n  getColumnOffset: getItemOffset,\r\n  getColumnStartIndexForOffset: GetStartIndexForOffset,\r\n  getColumnStopIndexForStartIndex: GetStopIndexForStartIndex,\r\n  getColumnWidth: getItemSize,\r\n  getEstimatedTotalHeight: getEstimatedTotalSize,\r\n  getEstimatedTotalWidth: getEstimatedTotalSize,\r\n  getOffsetForColumnAndAlignment: GetOffsetForItemAndAlignment,\r\n  getOffsetForRowAndAlignment: GetOffsetForItemAndAlignment,\r\n  getRowOffset: getItemOffset,\r\n  getRowHeight: getItemSize,\r\n  getRowStartIndexForOffset: GetStartIndexForOffset,\r\n  getRowStopIndexForStartIndex: GetStopIndexForStartIndex,\r\n  initInstanceProps: InitInstanceProps,\r\n  shouldResetStyleCacheOnItemSizeChange: boolean,\r\n  validateProps: ValidateProps,\r\n|}) {\r\n  return class Grid<T> extends PureComponent<Props<T>, State> {\r\n    _instanceProps: any = initInstanceProps(this.props, this);\r\n    _resetIsScrollingTimeoutId: TimeoutID | null = null;\r\n    _outerRef: ?HTMLDivElement;\r\n\r\n    static defaultProps = {\r\n      direction: 'ltr',\r\n      itemData: undefined,\r\n      useIsScrolling: false,\r\n    };\r\n\r\n    state: State = {\r\n      instance: this,\r\n      isScrolling: false,\r\n      horizontalScrollDirection: 'forward',\r\n      scrollLeft:\r\n        typeof this.props.initialScrollLeft === 'number'\r\n          ? this.props.initialScrollLeft\r\n          : 0,\r\n      scrollTop:\r\n        typeof this.props.initialScrollTop === 'number'\r\n          ? this.props.initialScrollTop\r\n          : 0,\r\n      scrollUpdateWasRequested: false,\r\n      verticalScrollDirection: 'forward',\r\n    };\r\n\r\n    // Always use explicit constructor for React components.\r\n    // It produces less code after transpilation. (#26)\r\n    // eslint-disable-next-line no-useless-constructor\r\n    constructor(props: Props<T>) {\r\n      super(props);\r\n    }\r\n\r\n    static getDerivedStateFromProps(\r\n      nextProps: Props<T>,\r\n      prevState: State\r\n    ): $Shape<State> | null {\r\n      validateSharedProps(nextProps, prevState);\r\n      validateProps(nextProps);\r\n      return null;\r\n    }\r\n\r\n    scrollTo({\r\n      scrollLeft,\r\n      scrollTop,\r\n    }: {\r\n      scrollLeft: number,\r\n      scrollTop: number,\r\n    }): void {\r\n      if (scrollLeft !== undefined) {\r\n        scrollLeft = Math.max(0, scrollLeft);\r\n      }\r\n      if (scrollTop !== undefined) {\r\n        scrollTop = Math.max(0, scrollTop);\r\n      }\r\n\r\n      this.setState(prevState => {\r\n        if (scrollLeft === undefined) {\r\n          scrollLeft = prevState.scrollLeft;\r\n        }\r\n        if (scrollTop === undefined) {\r\n          scrollTop = prevState.scrollTop;\r\n        }\r\n\r\n        if (\r\n          prevState.scrollLeft === scrollLeft &&\r\n          prevState.scrollTop === scrollTop\r\n        ) {\r\n          return null;\r\n        }\r\n\r\n        return {\r\n          horizontalScrollDirection:\r\n            prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\r\n          scrollLeft: scrollLeft,\r\n          scrollTop: scrollTop,\r\n          scrollUpdateWasRequested: true,\r\n          verticalScrollDirection:\r\n            prevState.scrollTop < scrollTop ? 'forward' : 'backward',\r\n        };\r\n      }, this._resetIsScrollingDebounced);\r\n    }\r\n\r\n    scrollToItem({\r\n      align = 'auto',\r\n      columnIndex,\r\n      rowIndex,\r\n    }: {\r\n      align: ScrollToAlign,\r\n      columnIndex?: number,\r\n      rowIndex?: number,\r\n    }): void {\r\n      const { columnCount, height, rowCount, width } = this.props;\r\n      const { scrollLeft, scrollTop } = this.state;\r\n      const scrollbarSize = getScrollbarSize();\r\n\r\n      if (columnIndex !== undefined) {\r\n        columnIndex = Math.max(0, Math.min(columnIndex, columnCount - 1));\r\n      }\r\n      if (rowIndex !== undefined) {\r\n        rowIndex = Math.max(0, Math.min(rowIndex, rowCount - 1));\r\n      }\r\n\r\n      const estimatedTotalHeight = getEstimatedTotalHeight(\r\n        this.props,\r\n        this._instanceProps\r\n      );\r\n      const estimatedTotalWidth = getEstimatedTotalWidth(\r\n        this.props,\r\n        this._instanceProps\r\n      );\r\n\r\n      // The scrollbar size should be considered when scrolling an item into view,\r\n      // to ensure it's fully visible.\r\n      // But we only need to account for its size when it's actually visible.\r\n      const horizontalScrollbarSize =\r\n        estimatedTotalWidth > width ? scrollbarSize : 0;\r\n      const verticalScrollbarSize =\r\n        estimatedTotalHeight > height ? scrollbarSize : 0;\r\n\r\n      this.scrollTo({\r\n        scrollLeft:\r\n          columnIndex !== undefined\r\n            ? getOffsetForColumnAndAlignment(\r\n                this.props,\r\n                columnIndex,\r\n                align,\r\n                scrollLeft,\r\n                this._instanceProps,\r\n                verticalScrollbarSize\r\n              )\r\n            : scrollLeft,\r\n        scrollTop:\r\n          rowIndex !== undefined\r\n            ? getOffsetForRowAndAlignment(\r\n                this.props,\r\n                rowIndex,\r\n                align,\r\n                scrollTop,\r\n                this._instanceProps,\r\n                horizontalScrollbarSize\r\n              )\r\n            : scrollTop,\r\n      });\r\n    }\r\n\r\n    componentDidMount() {\r\n      const { initialScrollLeft, initialScrollTop } = this.props;\r\n\r\n      if (this._outerRef != null) {\r\n        const outerRef = ((this._outerRef: any): HTMLElement);\r\n        if (typeof initialScrollLeft === 'number') {\r\n          outerRef.scrollLeft = initialScrollLeft;\r\n        }\r\n        if (typeof initialScrollTop === 'number') {\r\n          outerRef.scrollTop = initialScrollTop;\r\n        }\r\n      }\r\n\r\n      this._callPropsCallbacks();\r\n    }\r\n\r\n    componentDidUpdate() {\r\n      const { direction } = this.props;\r\n      const { scrollLeft, scrollTop, scrollUpdateWasRequested } = this.state;\r\n\r\n      if (scrollUpdateWasRequested && this._outerRef != null) {\r\n        // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\r\n        // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\r\n        // So we need to determine which browser behavior we're dealing with, and mimic it.\r\n        const outerRef = ((this._outerRef: any): HTMLElement);\r\n        if (direction === 'rtl') {\r\n          switch (getRTLOffsetType()) {\r\n            case 'negative':\r\n              outerRef.scrollLeft = -scrollLeft;\r\n              break;\r\n            case 'positive-ascending':\r\n              outerRef.scrollLeft = scrollLeft;\r\n              break;\r\n            default:\r\n              const { clientWidth, scrollWidth } = outerRef;\r\n              outerRef.scrollLeft = scrollWidth - clientWidth - scrollLeft;\r\n              break;\r\n          }\r\n        } else {\r\n          outerRef.scrollLeft = Math.max(0, scrollLeft);\r\n        }\r\n\r\n        outerRef.scrollTop = Math.max(0, scrollTop);\r\n      }\r\n\r\n      this._callPropsCallbacks();\r\n    }\r\n\r\n    componentWillUnmount() {\r\n      if (this._resetIsScrollingTimeoutId !== null) {\r\n        cancelTimeout(this._resetIsScrollingTimeoutId);\r\n      }\r\n    }\r\n\r\n    render() {\r\n      const {\r\n        children,\r\n        className,\r\n        columnCount,\r\n        direction,\r\n        height,\r\n        innerRef,\r\n        innerElementType,\r\n        innerTagName,\r\n        itemData,\r\n        itemKey = defaultItemKey,\r\n        outerElementType,\r\n        outerTagName,\r\n        rowCount,\r\n        style,\r\n        useIsScrolling,\r\n        width,\r\n        disableColVirtualized,\r\n        disableRowVirtualized\r\n      } = this.props;\r\n      const { isScrolling } = this.state;\r\n\r\n      let [\r\n        columnStartIndex,\r\n        columnStopIndex,\r\n      ] = this._getHorizontalRangeToRender();\r\n      let [rowStartIndex, rowStopIndex] = this._getVerticalRangeToRender();\r\n\r\n      if(disableColVirtualized) columnStartIndex = 0;\r\n      if(disableRowVirtualized) rowStartIndex = 0;\r\n      \r\n      const items = [];\r\n      if (columnCount > 0 && rowCount) {\r\n        for (\r\n          let rowIndex = rowStartIndex;\r\n          rowIndex <= rowStopIndex;\r\n          rowIndex++\r\n        ) {\r\n          for (\r\n            let columnIndex = columnStartIndex;\r\n            columnIndex <= columnStopIndex;\r\n            columnIndex++\r\n          ) {\r\n            items.push(\r\n              createElement(children, {\r\n                columnIndex,\r\n                data: itemData,\r\n                isScrolling: useIsScrolling ? isScrolling : undefined,\r\n                key: itemKey({ columnIndex, data: itemData, rowIndex }),\r\n                rowIndex,\r\n                style: this._getItemStyle(rowIndex, columnIndex),\r\n              })\r\n            );\r\n          }\r\n        }\r\n      }\r\n\r\n      // Read this value AFTER items have been created,\r\n      // So their actual sizes (if variable) are taken into consideration.\r\n      const estimatedTotalHeight = getEstimatedTotalHeight(\r\n        this.props,\r\n        this._instanceProps\r\n      );\r\n      const estimatedTotalWidth = getEstimatedTotalWidth(\r\n        this.props,\r\n        this._instanceProps\r\n      );\r\n\r\n      return createElement(\r\n        outerElementType || outerTagName || 'div',\r\n        {\r\n          className,\r\n          onScroll: this._onScroll,\r\n          ref: this._outerRefSetter,\r\n          style: {\r\n            position: 'relative',\r\n            height,\r\n            width,\r\n            overflow: 'auto',\r\n            WebkitOverflowScrolling: 'touch',\r\n            willChange: 'transform',\r\n            direction,\r\n            ...style,\r\n          },\r\n        },\r\n        createElement(innerElementType || innerTagName || 'div', {\r\n          children: items,\r\n          ref: innerRef,\r\n          style: {\r\n            height: estimatedTotalHeight,\r\n            pointerEvents: isScrolling ? 'none' : undefined,\r\n            width: estimatedTotalWidth,\r\n          },\r\n        })\r\n      );\r\n    }\r\n\r\n    _callOnItemsRendered: (\r\n      overscanColumnStartIndex: number,\r\n      overscanColumnStopIndex: number,\r\n      overscanRowStartIndex: number,\r\n      overscanRowStopIndex: number,\r\n      visibleColumnStartIndex: number,\r\n      visibleColumnStopIndex: number,\r\n      visibleRowStartIndex: number,\r\n      visibleRowStopIndex: number\r\n    ) => void;\r\n    _callOnItemsRendered = memoizeOne(\r\n      (\r\n        overscanColumnStartIndex: number,\r\n        overscanColumnStopIndex: number,\r\n        overscanRowStartIndex: number,\r\n        overscanRowStopIndex: number,\r\n        visibleColumnStartIndex: number,\r\n        visibleColumnStopIndex: number,\r\n        visibleRowStartIndex: number,\r\n        visibleRowStopIndex: number\r\n      ) =>\r\n        ((this.props.onItemsRendered: any): OnItemsRenderedCallback)({\r\n          overscanColumnStartIndex,\r\n          overscanColumnStopIndex,\r\n          overscanRowStartIndex,\r\n          overscanRowStopIndex,\r\n          visibleColumnStartIndex,\r\n          visibleColumnStopIndex,\r\n          visibleRowStartIndex,\r\n          visibleRowStopIndex,\r\n        })\r\n    );\r\n\r\n    _callOnScroll: (\r\n      scrollLeft: number,\r\n      scrollTop: number,\r\n      horizontalScrollDirection: ScrollDirection,\r\n      verticalScrollDirection: ScrollDirection,\r\n      scrollUpdateWasRequested: boolean\r\n    ) => void;\r\n    _callOnScroll = memoizeOne(\r\n      (\r\n        scrollLeft: number,\r\n        scrollTop: number,\r\n        horizontalScrollDirection: ScrollDirection,\r\n        verticalScrollDirection: ScrollDirection,\r\n        scrollUpdateWasRequested: boolean\r\n      ) =>\r\n        ((this.props.onScroll: any): OnScrollCallback)({\r\n          horizontalScrollDirection,\r\n          scrollLeft,\r\n          scrollTop,\r\n          verticalScrollDirection,\r\n          scrollUpdateWasRequested,\r\n        })\r\n    );\r\n\r\n    _callPropsCallbacks() {\r\n      const { columnCount, onItemsRendered, onScroll, rowCount } = this.props;\r\n\r\n      if (typeof onItemsRendered === 'function') {\r\n        if (columnCount > 0 && rowCount > 0) {\r\n          const [\r\n            overscanColumnStartIndex,\r\n            overscanColumnStopIndex,\r\n            visibleColumnStartIndex,\r\n            visibleColumnStopIndex,\r\n          ] = this._getHorizontalRangeToRender();\r\n          const [\r\n            overscanRowStartIndex,\r\n            overscanRowStopIndex,\r\n            visibleRowStartIndex,\r\n            visibleRowStopIndex,\r\n          ] = this._getVerticalRangeToRender();\r\n          this._callOnItemsRendered(\r\n            overscanColumnStartIndex,\r\n            overscanColumnStopIndex,\r\n            overscanRowStartIndex,\r\n            overscanRowStopIndex,\r\n            visibleColumnStartIndex,\r\n            visibleColumnStopIndex,\r\n            visibleRowStartIndex,\r\n            visibleRowStopIndex\r\n          );\r\n        }\r\n      }\r\n\r\n      if (typeof onScroll === 'function') {\r\n        const {\r\n          horizontalScrollDirection,\r\n          scrollLeft,\r\n          scrollTop,\r\n          scrollUpdateWasRequested,\r\n          verticalScrollDirection,\r\n        } = this.state;\r\n        this._callOnScroll(\r\n          scrollLeft,\r\n          scrollTop,\r\n          horizontalScrollDirection,\r\n          verticalScrollDirection,\r\n          scrollUpdateWasRequested\r\n        );\r\n      }\r\n    }\r\n\r\n    // Lazily create and cache item styles while scrolling,\r\n    // So that pure component sCU will prevent re-renders.\r\n    // We maintain this cache, and pass a style prop rather than index,\r\n    // So that List can clear cached styles and force item re-render if necessary.\r\n    _getItemStyle: (rowIndex: number, columnIndex: number) => Object;\r\n    _getItemStyle = (rowIndex: number, columnIndex: number): Object => {\r\n      const { columnWidth, direction, rowHeight } = this.props;\r\n\r\n      const itemStyleCache = this._getItemStyleCache(\r\n        shouldResetStyleCacheOnItemSizeChange && columnWidth,\r\n        shouldResetStyleCacheOnItemSizeChange && direction,\r\n        shouldResetStyleCacheOnItemSizeChange && rowHeight\r\n      );\r\n\r\n      const key = `${rowIndex}:${columnIndex}`;\r\n\r\n      let style;\r\n      if (itemStyleCache.hasOwnProperty(key)) {\r\n        style = itemStyleCache[key];\r\n      } else {\r\n        const offset = getColumnOffset(\r\n          this.props,\r\n          columnIndex,\r\n          this._instanceProps\r\n        );\r\n        const isRtl = direction === 'rtl';\r\n        itemStyleCache[key] = style = {\r\n          position: 'absolute',\r\n          left: isRtl ? undefined : offset,\r\n          right: isRtl ? offset : undefined,\r\n          top: getRowOffset(this.props, rowIndex, this._instanceProps),\r\n          height: getRowHeight(this.props, rowIndex, this._instanceProps),\r\n          width: getColumnWidth(this.props, columnIndex, this._instanceProps),\r\n        };\r\n      }\r\n\r\n      return style;\r\n    };\r\n\r\n    _getItemStyleCache: (_: any, __: any, ___: any) => ItemStyleCache;\r\n    _getItemStyleCache = memoizeOne((_: any, __: any, ___: any) => ({}));\r\n\r\n    _getHorizontalRangeToRender(): [number, number, number, number] {\r\n      const {\r\n        columnCount,\r\n        overscanColumnCount,\r\n        overscanColumnsCount,\r\n        overscanCount,\r\n        rowCount,\r\n      } = this.props;\r\n      const { horizontalScrollDirection, isScrolling, scrollLeft } = this.state;\r\n\r\n      const overscanCountResolved: number =\r\n        overscanColumnCount || overscanColumnsCount || overscanCount || 1;\r\n\r\n      if (columnCount === 0 || rowCount === 0) {\r\n        return [0, 0, 0, 0];\r\n      }\r\n\r\n      const startIndex = getColumnStartIndexForOffset(\r\n        this.props,\r\n        scrollLeft,\r\n        this._instanceProps\r\n      );\r\n      const stopIndex = getColumnStopIndexForStartIndex(\r\n        this.props,\r\n        startIndex,\r\n        scrollLeft,\r\n        this._instanceProps\r\n      );\r\n\r\n      // Overscan by one item in each direction so that tab/focus works.\r\n      // If there isn't at least one extra item, tab loops back around.\r\n      const overscanBackward =\r\n        !isScrolling || horizontalScrollDirection === 'backward'\r\n          ? Math.max(1, overscanCountResolved)\r\n          : 1;\r\n      const overscanForward =\r\n        !isScrolling || horizontalScrollDirection === 'forward'\r\n          ? Math.max(1, overscanCountResolved)\r\n          : 1;\r\n\r\n      return [\r\n        Math.max(0, startIndex - overscanBackward),\r\n        Math.max(0, Math.min(columnCount - 1, stopIndex + overscanForward)),\r\n        startIndex,\r\n        stopIndex,\r\n      ];\r\n    }\r\n\r\n    _getVerticalRangeToRender(): [number, number, number, number] {\r\n      const {\r\n        columnCount,\r\n        overscanCount,\r\n        overscanRowCount,\r\n        overscanRowsCount,\r\n        rowCount,\r\n      } = this.props;\r\n      const { isScrolling, verticalScrollDirection, scrollTop } = this.state;\r\n\r\n      const overscanCountResolved: number =\r\n        overscanRowCount || overscanRowsCount || overscanCount || 1;\r\n\r\n      if (columnCount === 0 || rowCount === 0) {\r\n        return [0, 0, 0, 0];\r\n      }\r\n\r\n      const startIndex = getRowStartIndexForOffset(\r\n        this.props,\r\n        scrollTop,\r\n        this._instanceProps\r\n      );\r\n      const stopIndex = getRowStopIndexForStartIndex(\r\n        this.props,\r\n        startIndex,\r\n        scrollTop,\r\n        this._instanceProps\r\n      );\r\n\r\n      // Overscan by one item in each direction so that tab/focus works.\r\n      // If there isn't at least one extra item, tab loops back around.\r\n      const overscanBackward =\r\n        !isScrolling || verticalScrollDirection === 'backward'\r\n          ? Math.max(1, overscanCountResolved)\r\n          : 1;\r\n      const overscanForward =\r\n        !isScrolling || verticalScrollDirection === 'forward'\r\n          ? Math.max(1, overscanCountResolved)\r\n          : 1;\r\n\r\n      return [\r\n        Math.max(0, startIndex - overscanBackward),\r\n        Math.max(0, Math.min(rowCount - 1, stopIndex + overscanForward)),\r\n        startIndex,\r\n        stopIndex,\r\n      ];\r\n    }\r\n\r\n    _onScroll = (event: ScrollEvent): void => {\r\n      const {\r\n        clientHeight,\r\n        clientWidth,\r\n        scrollLeft,\r\n        scrollTop,\r\n        scrollHeight,\r\n        scrollWidth,\r\n      } = event.currentTarget;\r\n      this.setState(prevState => {\r\n        if (\r\n          prevState.scrollLeft === scrollLeft &&\r\n          prevState.scrollTop === scrollTop\r\n        ) {\r\n          // Scroll position may have been updated by cDM/cDU,\r\n          // In which case we don't need to trigger another render,\r\n          // And we don't want to update state.isScrolling.\r\n          return null;\r\n        }\r\n\r\n        const { direction } = this.props;\r\n\r\n        // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\r\n        // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\r\n        // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\r\n        // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\r\n        let calculatedScrollLeft = scrollLeft;\r\n        if (direction === 'rtl') {\r\n          switch (getRTLOffsetType()) {\r\n            case 'negative':\r\n              calculatedScrollLeft = -scrollLeft;\r\n              break;\r\n            case 'positive-descending':\r\n              calculatedScrollLeft = scrollWidth - clientWidth - scrollLeft;\r\n              break;\r\n          }\r\n        }\r\n\r\n        // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\r\n        calculatedScrollLeft = Math.max(\r\n          0,\r\n          Math.min(calculatedScrollLeft, scrollWidth - clientWidth)\r\n        );\r\n        const calculatedScrollTop = Math.max(\r\n          0,\r\n          Math.min(scrollTop, scrollHeight - clientHeight)\r\n        );\r\n\r\n        return {\r\n          isScrolling: true,\r\n          horizontalScrollDirection:\r\n            prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\r\n          scrollLeft: calculatedScrollLeft,\r\n          scrollTop: calculatedScrollTop,\r\n          verticalScrollDirection:\r\n            prevState.scrollTop < scrollTop ? 'forward' : 'backward',\r\n          scrollUpdateWasRequested: false,\r\n        };\r\n      }, this._resetIsScrollingDebounced);\r\n    };\r\n\r\n    _outerRefSetter = (ref: any): void => {\r\n      const { outerRef } = this.props;\r\n\r\n      this._outerRef = ((ref: any): HTMLDivElement);\r\n\r\n      if (typeof outerRef === 'function') {\r\n        outerRef(ref);\r\n      } else if (\r\n        outerRef != null &&\r\n        typeof outerRef === 'object' &&\r\n        outerRef.hasOwnProperty('current')\r\n      ) {\r\n        outerRef.current = ref;\r\n      }\r\n    };\r\n\r\n    _resetIsScrollingDebounced = () => {\r\n      if (this._resetIsScrollingTimeoutId !== null) {\r\n        cancelTimeout(this._resetIsScrollingTimeoutId);\r\n      }\r\n\r\n      this._resetIsScrollingTimeoutId = requestTimeout(\r\n        this._resetIsScrolling,\r\n        IS_SCROLLING_DEBOUNCE_INTERVAL\r\n      );\r\n    };\r\n\r\n    _resetIsScrolling = () => {\r\n      this._resetIsScrollingTimeoutId = null;\r\n\r\n      this.setState({ isScrolling: false }, () => {\r\n        // Clear style cache after state update has been committed.\r\n        // This way we don't break pure sCU for items that don't use isScrolling param.\r\n        this._getItemStyleCache(-1);\r\n      });\r\n    };\r\n  };\r\n}\r\n\r\nconst validateSharedProps = (\r\n  {\r\n    children,\r\n    direction,\r\n    height,\r\n    innerTagName,\r\n    outerTagName,\r\n    overscanColumnsCount,\r\n    overscanCount,\r\n    overscanRowsCount,\r\n    width,\r\n  }: Props<any>,\r\n  { instance }: State\r\n): void => {\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    if (typeof overscanCount === 'number') {\r\n      if (devWarningsOverscanCount && !devWarningsOverscanCount.has(instance)) {\r\n        devWarningsOverscanCount.add(instance);\r\n        console.warn(\r\n          'The overscanCount prop has been deprecated. ' +\r\n            'Please use the overscanColumnCount and overscanRowCount props instead.'\r\n        );\r\n      }\r\n    }\r\n\r\n    if (\r\n      typeof overscanColumnsCount === 'number' ||\r\n      typeof overscanRowsCount === 'number'\r\n    ) {\r\n      if (\r\n        devWarningsOverscanRowsColumnsCount &&\r\n        !devWarningsOverscanRowsColumnsCount.has(instance)\r\n      ) {\r\n        devWarningsOverscanRowsColumnsCount.add(instance);\r\n        console.warn(\r\n          'The overscanColumnsCount and overscanRowsCount props have been deprecated. ' +\r\n            'Please use the overscanColumnCount and overscanRowCount props instead.'\r\n        );\r\n      }\r\n    }\r\n\r\n    if (innerTagName != null || outerTagName != null) {\r\n      if (devWarningsTagName && !devWarningsTagName.has(instance)) {\r\n        devWarningsTagName.add(instance);\r\n        console.warn(\r\n          'The innerTagName and outerTagName props have been deprecated. ' +\r\n            'Please use the innerElementType and outerElementType props instead.'\r\n        );\r\n      }\r\n    }\r\n\r\n    if (children == null) {\r\n      throw Error(\r\n        'An invalid \"children\" prop has been specified. ' +\r\n          'Value should be a React component. ' +\r\n          `\"${children === null ? 'null' : typeof children}\" was specified.`\r\n      );\r\n    }\r\n\r\n    switch (direction) {\r\n      case 'ltr':\r\n      case 'rtl':\r\n        // Valid values\r\n        break;\r\n      default:\r\n        throw Error(\r\n          'An invalid \"direction\" prop has been specified. ' +\r\n            'Value should be either \"ltr\" or \"rtl\". ' +\r\n            `\"${direction}\" was specified.`\r\n        );\r\n    }\r\n\r\n    if (typeof width !== 'number') {\r\n      throw Error(\r\n        'An invalid \"width\" prop has been specified. ' +\r\n          'Grids must specify a number for width. ' +\r\n          `\"${width === null ? 'null' : typeof width}\" was specified.`\r\n      );\r\n    }\r\n\r\n    if (typeof height !== 'number') {\r\n      throw Error(\r\n        'An invalid \"height\" prop has been specified. ' +\r\n          'Grids must specify a number for height. ' +\r\n          `\"${height === null ? 'null' : typeof height}\" was specified.`\r\n      );\r\n    }\r\n  }\r\n};\r\n","// @flow\r\n\r\nimport createGridComponent from './createGridComponent';\r\n\r\nimport type { Props, ScrollToAlign } from './createGridComponent';\r\n\r\nconst DEFAULT_ESTIMATED_ITEM_SIZE = 50;\r\n\r\ntype VariableSizeProps = {|\r\n  estimatedColumnWidth: number,\r\n  estimatedRowHeight: number,\r\n  disableColVirtualized?: boolean,\r\n  disableRowVirtualized?: boolean,\r\n  ...Props<any>,\r\n|};\r\n\r\ntype itemSizeGetter = (index: number) => number;\r\ntype ItemType = 'column' | 'row';\r\n\r\ntype ItemMetadata = {|\r\n  offset: number,\r\n  size: number,\r\n|};\r\ntype ItemMetadataMap = { [index: number]: ItemMetadata };\r\ntype InstanceProps = {|\r\n  columnMetadataMap: ItemMetadataMap,\r\n  estimatedColumnWidth: number,\r\n  estimatedRowHeight: number,\r\n  lastMeasuredColumnIndex: number,\r\n  lastMeasuredRowIndex: number,\r\n  rowMetadataMap: ItemMetadataMap,\r\n|};\r\n\r\nconst getEstimatedTotalHeight = (\r\n  { rowCount }: Props<any>,\r\n  { rowMetadataMap, estimatedRowHeight, lastMeasuredRowIndex }: InstanceProps\r\n) => {\r\n  let totalSizeOfMeasuredRows = 0;\r\n\r\n  // Edge case check for when the number of items decreases while a scroll is in progress.\r\n  // https://github.com/bvaughn/react-window/pull/138\r\n  if (lastMeasuredRowIndex >= rowCount) {\r\n    lastMeasuredRowIndex = rowCount - 1;\r\n  }\r\n\r\n  if (lastMeasuredRowIndex >= 0) {\r\n    const itemMetadata = rowMetadataMap[lastMeasuredRowIndex];\r\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\r\n  }\r\n\r\n  const numUnmeasuredItems = rowCount - lastMeasuredRowIndex - 1;\r\n  const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedRowHeight;\r\n\r\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\r\n};\r\n\r\nconst getEstimatedTotalWidth = (\r\n  { columnCount }: Props<any>,\r\n  {\r\n    columnMetadataMap,\r\n    estimatedColumnWidth,\r\n    lastMeasuredColumnIndex,\r\n  }: InstanceProps\r\n) => {\r\n  let totalSizeOfMeasuredRows = 0;\r\n\r\n  // Edge case check for when the number of items decreases while a scroll is in progress.\r\n  // https://github.com/bvaughn/react-window/pull/138\r\n  if (lastMeasuredColumnIndex >= columnCount) {\r\n    lastMeasuredColumnIndex = columnCount - 1;\r\n  }\r\n\r\n  if (lastMeasuredColumnIndex >= 0) {\r\n    const itemMetadata = columnMetadataMap[lastMeasuredColumnIndex];\r\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\r\n  }\r\n\r\n  const numUnmeasuredItems = columnCount - lastMeasuredColumnIndex - 1;\r\n  const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedColumnWidth;\r\n\r\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\r\n};\r\n\r\nconst getItemMetadata = (\r\n  itemType: ItemType,\r\n  props: Props<any>,\r\n  index: number,\r\n  instanceProps: InstanceProps\r\n): ItemMetadata => {\r\n  let itemMetadataMap, itemSize, lastMeasuredIndex;\r\n  if (itemType === 'column') {\r\n    itemMetadataMap = instanceProps.columnMetadataMap;\r\n    itemSize = ((props.columnWidth: any): itemSizeGetter);\r\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\r\n  } else {\r\n    itemMetadataMap = instanceProps.rowMetadataMap;\r\n    itemSize = ((props.rowHeight: any): itemSizeGetter);\r\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\r\n  }\r\n\r\n  if (index > lastMeasuredIndex) {\r\n    let offset = 0;\r\n    if (lastMeasuredIndex >= 0) {\r\n      const itemMetadata = itemMetadataMap[lastMeasuredIndex];\r\n      offset = itemMetadata.offset + itemMetadata.size;\r\n    }\r\n\r\n    for (let i = lastMeasuredIndex + 1; i <= index; i++) {\r\n      let size = itemSize(i);\r\n\r\n      itemMetadataMap[i] = {\r\n        offset,\r\n        size,\r\n      };\r\n\r\n      offset += size;\r\n    }\r\n\r\n    if (itemType === 'column') {\r\n      instanceProps.lastMeasuredColumnIndex = index;\r\n    } else {\r\n      instanceProps.lastMeasuredRowIndex = index;\r\n    }\r\n  }\r\n\r\n  return itemMetadataMap[index];\r\n};\r\n\r\nconst findNearestItem = (\r\n  itemType: ItemType,\r\n  props: Props<any>,\r\n  instanceProps: InstanceProps,\r\n  offset: number\r\n) => {\r\n  let itemMetadataMap, lastMeasuredIndex;\r\n  if (itemType === 'column') {\r\n    itemMetadataMap = instanceProps.columnMetadataMap;\r\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\r\n  } else {\r\n    itemMetadataMap = instanceProps.rowMetadataMap;\r\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\r\n  }\r\n\r\n  const lastMeasuredItemOffset =\r\n    lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\r\n\r\n  if (lastMeasuredItemOffset >= offset) {\r\n    // If we've already measured items within this range just use a binary search as it's faster.\r\n    return findNearestItemBinarySearch(\r\n      itemType,\r\n      props,\r\n      instanceProps,\r\n      lastMeasuredIndex,\r\n      0,\r\n      offset\r\n    );\r\n  } else {\r\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\r\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\r\n    // The overall complexity for this approach is O(log n).\r\n    return findNearestItemExponentialSearch(\r\n      itemType,\r\n      props,\r\n      instanceProps,\r\n      Math.max(0, lastMeasuredIndex),\r\n      offset\r\n    );\r\n  }\r\n};\r\n\r\nconst findNearestItemBinarySearch = (\r\n  itemType: ItemType,\r\n  props: Props<any>,\r\n  instanceProps: InstanceProps,\r\n  high: number,\r\n  low: number,\r\n  offset: number\r\n): number => {\r\n  while (low <= high) {\r\n    const middle = low + Math.floor((high - low) / 2);\r\n    const currentOffset = getItemMetadata(\r\n      itemType,\r\n      props,\r\n      middle,\r\n      instanceProps\r\n    ).offset;\r\n\r\n    if (currentOffset === offset) {\r\n      return middle;\r\n    } else if (currentOffset < offset) {\r\n      low = middle + 1;\r\n    } else if (currentOffset > offset) {\r\n      high = middle - 1;\r\n    }\r\n  }\r\n\r\n  if (low > 0) {\r\n    return low - 1;\r\n  } else {\r\n    return 0;\r\n  }\r\n};\r\n\r\nconst findNearestItemExponentialSearch = (\r\n  itemType: ItemType,\r\n  props: Props<any>,\r\n  instanceProps: InstanceProps,\r\n  index: number,\r\n  offset: number\r\n): number => {\r\n  const itemCount = itemType === 'column' ? props.columnCount : props.rowCount;\r\n  let interval = 1;\r\n\r\n  while (\r\n    index < itemCount &&\r\n    getItemMetadata(itemType, props, index, instanceProps).offset < offset\r\n  ) {\r\n    index += interval;\r\n    interval *= 2;\r\n  }\r\n\r\n  return findNearestItemBinarySearch(\r\n    itemType,\r\n    props,\r\n    instanceProps,\r\n    Math.min(index, itemCount - 1),\r\n    Math.floor(index / 2),\r\n    offset\r\n  );\r\n};\r\n\r\nconst getOffsetForIndexAndAlignment = (\r\n  itemType: ItemType,\r\n  props: Props<any>,\r\n  index: number,\r\n  align: ScrollToAlign,\r\n  scrollOffset: number,\r\n  instanceProps: InstanceProps,\r\n  scrollbarSize: number\r\n): number => {\r\n  const size = itemType === 'column' ? props.width : props.height;\r\n  const itemMetadata = getItemMetadata(itemType, props, index, instanceProps);\r\n\r\n  // Get estimated total size after ItemMetadata is computed,\r\n  // To ensure it reflects actual measurements instead of just estimates.\r\n  const estimatedTotalSize =\r\n    itemType === 'column'\r\n      ? getEstimatedTotalWidth(props, instanceProps)\r\n      : getEstimatedTotalHeight(props, instanceProps);\r\n\r\n  const maxOffset = Math.max(\r\n    0,\r\n    Math.min(estimatedTotalSize - size, itemMetadata.offset)\r\n  );\r\n  const minOffset = Math.max(\r\n    0,\r\n    itemMetadata.offset - size + scrollbarSize + itemMetadata.size\r\n  );\r\n\r\n  if (align === 'smart') {\r\n    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\r\n      align = 'auto';\r\n    } else {\r\n      align = 'center';\r\n    }\r\n  }\r\n\r\n  switch (align) {\r\n    case 'start':\r\n      return maxOffset;\r\n    case 'end':\r\n      return minOffset;\r\n    case 'center':\r\n      return Math.round(minOffset + (maxOffset - minOffset) / 2);\r\n    case 'auto':\r\n    default:\r\n      if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\r\n        return scrollOffset;\r\n      } else if (minOffset > maxOffset) {\r\n        // Because we only take into account the scrollbar size when calculating minOffset\r\n        // this value can be larger than maxOffset when at the end of the list\r\n        return minOffset;\r\n      } else if (scrollOffset < minOffset) {\r\n        return minOffset;\r\n      } else {\r\n        return maxOffset;\r\n      }\r\n  }\r\n};\r\n\r\nconst VariableSizeGrid = createGridComponent({\r\n  getColumnOffset: (\r\n    props: Props<any>,\r\n    index: number,\r\n    instanceProps: InstanceProps\r\n  ): number => getItemMetadata('column', props, index, instanceProps).offset,\r\n\r\n  getColumnStartIndexForOffset: (\r\n    props: Props<any>,\r\n    scrollLeft: number,\r\n    instanceProps: InstanceProps\r\n  ): number => findNearestItem('column', props, instanceProps, scrollLeft),\r\n\r\n  getColumnStopIndexForStartIndex: (\r\n    props: Props<any>,\r\n    startIndex: number,\r\n    scrollLeft: number,\r\n    instanceProps: InstanceProps\r\n  ): number => {\r\n    const { columnCount, width } = props;\r\n\r\n    const itemMetadata = getItemMetadata(\r\n      'column',\r\n      props,\r\n      startIndex,\r\n      instanceProps\r\n    );\r\n    const maxOffset = scrollLeft + width;\r\n\r\n    let offset = itemMetadata.offset + itemMetadata.size;\r\n    let stopIndex = startIndex;\r\n\r\n    while (stopIndex < columnCount - 1 && offset < maxOffset) {\r\n      stopIndex++;\r\n      offset += getItemMetadata('column', props, stopIndex, instanceProps).size;\r\n    }\r\n\r\n    return stopIndex;\r\n  },\r\n\r\n  getColumnWidth: (\r\n    props: Props<any>,\r\n    index: number,\r\n    instanceProps: InstanceProps\r\n  ): number => instanceProps.columnMetadataMap[index].size,\r\n\r\n  getEstimatedTotalHeight,\r\n  getEstimatedTotalWidth,\r\n\r\n  getOffsetForColumnAndAlignment: (\r\n    props: Props<any>,\r\n    index: number,\r\n    align: ScrollToAlign,\r\n    scrollOffset: number,\r\n    instanceProps: InstanceProps,\r\n    scrollbarSize: number\r\n  ): number =>\r\n    getOffsetForIndexAndAlignment(\r\n      'column',\r\n      props,\r\n      index,\r\n      align,\r\n      scrollOffset,\r\n      instanceProps,\r\n      scrollbarSize\r\n    ),\r\n\r\n  getOffsetForRowAndAlignment: (\r\n    props: Props<any>,\r\n    index: number,\r\n    align: ScrollToAlign,\r\n    scrollOffset: number,\r\n    instanceProps: InstanceProps,\r\n    scrollbarSize: number\r\n  ): number =>\r\n    getOffsetForIndexAndAlignment(\r\n      'row',\r\n      props,\r\n      index,\r\n      align,\r\n      scrollOffset,\r\n      instanceProps,\r\n      scrollbarSize\r\n    ),\r\n\r\n  getRowOffset: (\r\n    props: Props<any>,\r\n    index: number,\r\n    instanceProps: InstanceProps\r\n  ): number => getItemMetadata('row', props, index, instanceProps).offset,\r\n\r\n  getRowHeight: (\r\n    props: Props<any>,\r\n    index: number,\r\n    instanceProps: InstanceProps\r\n  ): number => instanceProps.rowMetadataMap[index].size,\r\n\r\n  getRowStartIndexForOffset: (\r\n    props: Props<any>,\r\n    scrollTop: number,\r\n    instanceProps: InstanceProps\r\n  ): number => findNearestItem('row', props, instanceProps, scrollTop),\r\n\r\n  getRowStopIndexForStartIndex: (\r\n    props: Props<any>,\r\n    startIndex: number,\r\n    scrollTop: number,\r\n    instanceProps: InstanceProps\r\n  ): number => {\r\n    const { rowCount, height } = props;\r\n\r\n    const itemMetadata = getItemMetadata(\r\n      'row',\r\n      props,\r\n      startIndex,\r\n      instanceProps\r\n    );\r\n    const maxOffset = scrollTop + height;\r\n\r\n    let offset = itemMetadata.offset + itemMetadata.size;\r\n    let stopIndex = startIndex;\r\n\r\n    while (stopIndex < rowCount - 1 && offset < maxOffset) {\r\n      stopIndex++;\r\n      offset += getItemMetadata('row', props, stopIndex, instanceProps).size;\r\n    }\r\n\r\n    return stopIndex;\r\n  },\r\n\r\n  initInstanceProps(props: Props<any>, instance: any): InstanceProps {\r\n    const {\r\n      estimatedColumnWidth,\r\n      estimatedRowHeight,\r\n    } = ((props: any): VariableSizeProps);\r\n\r\n    const instanceProps = {\r\n      columnMetadataMap: {},\r\n      estimatedColumnWidth: estimatedColumnWidth || DEFAULT_ESTIMATED_ITEM_SIZE,\r\n      estimatedRowHeight: estimatedRowHeight || DEFAULT_ESTIMATED_ITEM_SIZE,\r\n      lastMeasuredColumnIndex: -1,\r\n      lastMeasuredRowIndex: -1,\r\n      rowMetadataMap: {},\r\n    };\r\n\r\n    instance.resetAfterColumnIndex = (\r\n      columnIndex: number,\r\n      shouldForceUpdate?: boolean = true\r\n    ) => {\r\n      instance.resetAfterIndices({ columnIndex, shouldForceUpdate });\r\n    };\r\n\r\n    instance.resetAfterRowIndex = (\r\n      rowIndex: number,\r\n      shouldForceUpdate?: boolean = true\r\n    ) => {\r\n      instance.resetAfterIndices({ rowIndex, shouldForceUpdate });\r\n    };\r\n\r\n    instance.resetAfterIndices = ({\r\n      columnIndex,\r\n      rowIndex,\r\n      shouldForceUpdate = true,\r\n    }: {\r\n      columnIndex?: number,\r\n      rowIndex?: number,\r\n      shouldForceUpdate: boolean,\r\n    }) => {\r\n      if (typeof columnIndex === 'number') {\r\n        instanceProps.lastMeasuredColumnIndex = Math.min(\r\n          instanceProps.lastMeasuredColumnIndex,\r\n          columnIndex - 1\r\n        );\r\n      }\r\n      if (typeof rowIndex === 'number') {\r\n        instanceProps.lastMeasuredRowIndex = Math.min(\r\n          instanceProps.lastMeasuredRowIndex,\r\n          rowIndex - 1\r\n        );\r\n      }\r\n\r\n      // We could potentially optimize further by only evicting styles after this index,\r\n      // But since styles are only cached while scrolling is in progress-\r\n      // It seems an unnecessary optimization.\r\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\r\n      instance._getItemStyleCache(-1);\r\n\r\n      if (shouldForceUpdate) {\r\n        instance.forceUpdate();\r\n      }\r\n    };\r\n\r\n    return instanceProps;\r\n  },\r\n\r\n  shouldResetStyleCacheOnItemSizeChange: false,\r\n\r\n  validateProps: ({ columnWidth, rowHeight }: Props<any>): void => {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      if (typeof columnWidth !== 'function') {\r\n        throw Error(\r\n          'An invalid \"columnWidth\" prop has been specified. ' +\r\n            'Value should be a function. ' +\r\n            `\"${\r\n              columnWidth === null ? 'null' : typeof columnWidth\r\n            }\" was specified.`\r\n        );\r\n      } else if (typeof rowHeight !== 'function') {\r\n        throw Error(\r\n          'An invalid \"rowHeight\" prop has been specified. ' +\r\n            'Value should be a function. ' +\r\n            `\"${rowHeight === null ? 'null' : typeof rowHeight}\" was specified.`\r\n        );\r\n      }\r\n    }\r\n  },\r\n});\r\n\r\nexport default VariableSizeGrid;\r\n","// @flow\r\n\r\nimport memoizeOne from 'memoize-one';\r\nimport { createElement, PureComponent } from 'react';\r\nimport { cancelTimeout, requestTimeout } from './timer';\r\nimport { getScrollbarSize, getRTLOffsetType } from './domHelpers';\r\n\r\nimport type { TimeoutID } from './timer';\r\n\r\nexport type ScrollToAlign = 'auto' | 'smart' | 'center' | 'start' | 'end';\r\n\r\ntype itemSize = number | ((index: number) => number);\r\n// TODO Deprecate directions \"horizontal\" and \"vertical\"\r\ntype Direction = 'ltr' | 'rtl' | 'horizontal' | 'vertical';\r\ntype Layout = 'horizontal' | 'vertical';\r\n\r\ntype RenderComponentProps<T> = {|\r\n  data: T,\r\n  index: number,\r\n  isScrolling?: boolean,\r\n  style: Object,\r\n|};\r\ntype RenderComponent<T> = React$ComponentType<$Shape<RenderComponentProps<T>>>;\r\n\r\ntype ScrollDirection = 'forward' | 'backward';\r\n\r\ntype onItemsRenderedCallback = ({\r\n  overscanStartIndex: number,\r\n  overscanStopIndex: number,\r\n  visibleStartIndex: number,\r\n  visibleStopIndex: number,\r\n}) => void;\r\ntype onScrollCallback = ({\r\n  scrollDirection: ScrollDirection,\r\n  scrollOffset: number,\r\n  scrollUpdateWasRequested: boolean,\r\n}) => void;\r\n\r\ntype ScrollEvent = SyntheticEvent<HTMLDivElement>;\r\ntype ItemStyleCache = { [index: number]: Object };\r\n\r\ntype OuterProps = {|\r\n  children: React$Node,\r\n  className: string | void,\r\n  onScroll: ScrollEvent => void,\r\n  style: {\r\n    [string]: mixed,\r\n  },\r\n|};\r\n\r\ntype InnerProps = {|\r\n  children: React$Node,\r\n  style: {\r\n    [string]: mixed,\r\n  },\r\n|};\r\n\r\nexport type Props<T> = {|\r\n  children: RenderComponent<T>,\r\n  className?: string,\r\n  direction: Direction,\r\n  height: number | string,\r\n  initialScrollOffset?: number,\r\n  innerRef?: any,\r\n  innerElementType?: string | React$AbstractComponent<InnerProps, any>,\r\n  innerTagName?: string, // deprecated\r\n  itemCount: number,\r\n  itemData: T,\r\n  itemKey?: (index: number, data: T) => any,\r\n  itemSize: itemSize,\r\n  layout: Layout,\r\n  onItemsRendered?: onItemsRenderedCallback,\r\n  onScroll?: onScrollCallback,\r\n  outerRef?: any,\r\n  outerElementType?: string | React$AbstractComponent<OuterProps, any>,\r\n  outerTagName?: string, // deprecated\r\n  overscanCount: number,\r\n  style?: Object,\r\n  useIsScrolling: boolean,\r\n  width: number | string,\r\n|};\r\n\r\ntype State = {|\r\n  instance: any,\r\n  isScrolling: boolean,\r\n  scrollDirection: ScrollDirection,\r\n  scrollOffset: number,\r\n  scrollUpdateWasRequested: boolean,\r\n|};\r\n\r\ntype GetItemOffset = (\r\n  props: Props<any>,\r\n  index: number,\r\n  instanceProps: any\r\n) => number;\r\ntype GetItemSize = (\r\n  props: Props<any>,\r\n  index: number,\r\n  instanceProps: any\r\n) => number;\r\ntype GetEstimatedTotalSize = (props: Props<any>, instanceProps: any) => number;\r\ntype GetOffsetForIndexAndAlignment = (\r\n  props: Props<any>,\r\n  index: number,\r\n  align: ScrollToAlign,\r\n  scrollOffset: number,\r\n  instanceProps: any\r\n) => number;\r\ntype GetStartIndexForOffset = (\r\n  props: Props<any>,\r\n  offset: number,\r\n  instanceProps: any\r\n) => number;\r\ntype GetStopIndexForStartIndex = (\r\n  props: Props<any>,\r\n  startIndex: number,\r\n  scrollOffset: number,\r\n  instanceProps: any\r\n) => number;\r\ntype InitInstanceProps = (props: Props<any>, instance: any) => any;\r\ntype ValidateProps = (props: Props<any>) => void;\r\n\r\nconst IS_SCROLLING_DEBOUNCE_INTERVAL = 150;\r\n\r\nconst defaultItemKey = (index: number, data: any) => index;\r\n\r\n// In DEV mode, this Set helps us only log a warning once per component instance.\r\n// This avoids spamming the console every time a render happens.\r\nlet devWarningsDirection = null;\r\nlet devWarningsTagName = null;\r\nif (process.env.NODE_ENV !== 'production') {\r\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\r\n    devWarningsDirection = new WeakSet();\r\n    devWarningsTagName = new WeakSet();\r\n  }\r\n}\r\n\r\nexport default function createListComponent({\r\n  getItemOffset,\r\n  getEstimatedTotalSize,\r\n  getItemSize,\r\n  getOffsetForIndexAndAlignment,\r\n  getStartIndexForOffset,\r\n  getStopIndexForStartIndex,\r\n  initInstanceProps,\r\n  shouldResetStyleCacheOnItemSizeChange,\r\n  validateProps,\r\n}: {|\r\n  getItemOffset: GetItemOffset,\r\n  getEstimatedTotalSize: GetEstimatedTotalSize,\r\n  getItemSize: GetItemSize,\r\n  getOffsetForIndexAndAlignment: GetOffsetForIndexAndAlignment,\r\n  getStartIndexForOffset: GetStartIndexForOffset,\r\n  getStopIndexForStartIndex: GetStopIndexForStartIndex,\r\n  initInstanceProps: InitInstanceProps,\r\n  shouldResetStyleCacheOnItemSizeChange: boolean,\r\n  validateProps: ValidateProps,\r\n|}) {\r\n  return class List<T> extends PureComponent<Props<T>, State> {\r\n    _instanceProps: any = initInstanceProps(this.props, this);\r\n    _outerRef: ?HTMLDivElement;\r\n    _resetIsScrollingTimeoutId: TimeoutID | null = null;\r\n\r\n    static defaultProps = {\r\n      direction: 'ltr',\r\n      itemData: undefined,\r\n      layout: 'vertical',\r\n      overscanCount: 2,\r\n      useIsScrolling: false,\r\n    };\r\n\r\n    state: State = {\r\n      instance: this,\r\n      isScrolling: false,\r\n      scrollDirection: 'forward',\r\n      scrollOffset:\r\n        typeof this.props.initialScrollOffset === 'number'\r\n          ? this.props.initialScrollOffset\r\n          : 0,\r\n      scrollUpdateWasRequested: false,\r\n    };\r\n\r\n    // Always use explicit constructor for React components.\r\n    // It produces less code after transpilation. (#26)\r\n    // eslint-disable-next-line no-useless-constructor\r\n    constructor(props: Props<T>) {\r\n      super(props);\r\n    }\r\n\r\n    static getDerivedStateFromProps(\r\n      nextProps: Props<T>,\r\n      prevState: State\r\n    ): $Shape<State> | null {\r\n      validateSharedProps(nextProps, prevState);\r\n      validateProps(nextProps);\r\n      return null;\r\n    }\r\n\r\n    scrollTo(scrollOffset: number): void {\r\n      scrollOffset = Math.max(0, scrollOffset);\r\n\r\n      this.setState(prevState => {\r\n        if (prevState.scrollOffset === scrollOffset) {\r\n          return null;\r\n        }\r\n        return {\r\n          scrollDirection:\r\n            prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\r\n          scrollOffset: scrollOffset,\r\n          scrollUpdateWasRequested: true,\r\n        };\r\n      }, this._resetIsScrollingDebounced);\r\n    }\r\n\r\n    scrollToItem(index: number, align: ScrollToAlign = 'auto'): void {\r\n      const { itemCount, layout } = this.props;\r\n      const { scrollOffset } = this.state;\r\n\r\n      index = Math.max(0, Math.min(index, itemCount - 1));\r\n\r\n      // The scrollbar size should be considered when scrolling an item into view, to ensure it's fully visible.\r\n      // But we only need to account for its size when it's actually visible.\r\n      // This is an edge case for lists; normally they only scroll in the dominant direction.\r\n      let scrollbarSize = 0;\r\n      if (this._outerRef) {\r\n        const outerRef = ((this._outerRef: any): HTMLElement);\r\n        if (layout === 'vertical') {\r\n          scrollbarSize =\r\n            outerRef.scrollWidth > outerRef.clientWidth\r\n              ? getScrollbarSize()\r\n              : 0;\r\n        } else {\r\n          scrollbarSize =\r\n            outerRef.scrollHeight > outerRef.clientHeight\r\n              ? getScrollbarSize()\r\n              : 0;\r\n        }\r\n      }\r\n\r\n      this.scrollTo(\r\n        getOffsetForIndexAndAlignment(\r\n          this.props,\r\n          index,\r\n          align,\r\n          scrollOffset,\r\n          this._instanceProps,\r\n          scrollbarSize\r\n        )\r\n      );\r\n    }\r\n\r\n    componentDidMount() {\r\n      const { direction, initialScrollOffset, layout } = this.props;\r\n\r\n      if (typeof initialScrollOffset === 'number' && this._outerRef != null) {\r\n        const outerRef = ((this._outerRef: any): HTMLElement);\r\n        // TODO Deprecate direction \"horizontal\"\r\n        if (direction === 'horizontal' || layout === 'horizontal') {\r\n          outerRef.scrollLeft = initialScrollOffset;\r\n        } else {\r\n          outerRef.scrollTop = initialScrollOffset;\r\n        }\r\n      }\r\n\r\n      this._callPropsCallbacks();\r\n    }\r\n\r\n    componentDidUpdate() {\r\n      const { direction, layout } = this.props;\r\n      const { scrollOffset, scrollUpdateWasRequested } = this.state;\r\n\r\n      if (scrollUpdateWasRequested && this._outerRef != null) {\r\n        const outerRef = ((this._outerRef: any): HTMLElement);\r\n\r\n        // TODO Deprecate direction \"horizontal\"\r\n        if (direction === 'horizontal' || layout === 'horizontal') {\r\n          if (direction === 'rtl') {\r\n            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\r\n            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\r\n            // So we need to determine which browser behavior we're dealing with, and mimic it.\r\n            switch (getRTLOffsetType()) {\r\n              case 'negative':\r\n                outerRef.scrollLeft = -scrollOffset;\r\n                break;\r\n              case 'positive-ascending':\r\n                outerRef.scrollLeft = scrollOffset;\r\n                break;\r\n              default:\r\n                const { clientWidth, scrollWidth } = outerRef;\r\n                outerRef.scrollLeft = scrollWidth - clientWidth - scrollOffset;\r\n                break;\r\n            }\r\n          } else {\r\n            outerRef.scrollLeft = scrollOffset;\r\n          }\r\n        } else {\r\n          outerRef.scrollTop = scrollOffset;\r\n        }\r\n      }\r\n\r\n      this._callPropsCallbacks();\r\n    }\r\n\r\n    componentWillUnmount() {\r\n      if (this._resetIsScrollingTimeoutId !== null) {\r\n        cancelTimeout(this._resetIsScrollingTimeoutId);\r\n      }\r\n    }\r\n\r\n    render() {\r\n      const {\r\n        children,\r\n        className,\r\n        direction,\r\n        height,\r\n        innerRef,\r\n        innerElementType,\r\n        innerTagName,\r\n        itemCount,\r\n        itemData,\r\n        itemKey = defaultItemKey,\r\n        layout,\r\n        outerElementType,\r\n        outerTagName,\r\n        style,\r\n        useIsScrolling,\r\n        width,\r\n      } = this.props;\r\n      const { isScrolling } = this.state;\r\n\r\n      // TODO Deprecate direction \"horizontal\"\r\n      const isHorizontal =\r\n        direction === 'horizontal' || layout === 'horizontal';\r\n\r\n      const onScroll = isHorizontal\r\n        ? this._onScrollHorizontal\r\n        : this._onScrollVertical;\r\n\r\n      const [startIndex, stopIndex] = this._getRangeToRender();\r\n\r\n      const items = [];\r\n      if (itemCount > 0) {\r\n        for (let index = startIndex; index <= stopIndex; index++) {\r\n          items.push(\r\n            createElement(children, {\r\n              data: itemData,\r\n              key: itemKey(index, itemData),\r\n              index,\r\n              isScrolling: useIsScrolling ? isScrolling : undefined,\r\n              style: this._getItemStyle(index),\r\n            })\r\n          );\r\n        }\r\n      }\r\n\r\n      // Read this value AFTER items have been created,\r\n      // So their actual sizes (if variable) are taken into consideration.\r\n      const estimatedTotalSize = getEstimatedTotalSize(\r\n        this.props,\r\n        this._instanceProps\r\n      );\r\n\r\n      return createElement(\r\n        outerElementType || outerTagName || 'div',\r\n        {\r\n          className,\r\n          onScroll,\r\n          ref: this._outerRefSetter,\r\n          style: {\r\n            position: 'relative',\r\n            height,\r\n            width,\r\n            overflow: 'auto',\r\n            WebkitOverflowScrolling: 'touch',\r\n            willChange: 'transform',\r\n            direction,\r\n            ...style,\r\n          },\r\n        },\r\n        createElement(innerElementType || innerTagName || 'div', {\r\n          children: items,\r\n          ref: innerRef,\r\n          style: {\r\n            height: isHorizontal ? '100%' : estimatedTotalSize,\r\n            pointerEvents: isScrolling ? 'none' : undefined,\r\n            width: isHorizontal ? estimatedTotalSize : '100%',\r\n          },\r\n        })\r\n      );\r\n    }\r\n\r\n    _callOnItemsRendered: (\r\n      overscanStartIndex: number,\r\n      overscanStopIndex: number,\r\n      visibleStartIndex: number,\r\n      visibleStopIndex: number\r\n    ) => void;\r\n    _callOnItemsRendered = memoizeOne(\r\n      (\r\n        overscanStartIndex: number,\r\n        overscanStopIndex: number,\r\n        visibleStartIndex: number,\r\n        visibleStopIndex: number\r\n      ) =>\r\n        ((this.props.onItemsRendered: any): onItemsRenderedCallback)({\r\n          overscanStartIndex,\r\n          overscanStopIndex,\r\n          visibleStartIndex,\r\n          visibleStopIndex,\r\n        })\r\n    );\r\n\r\n    _callOnScroll: (\r\n      scrollDirection: ScrollDirection,\r\n      scrollOffset: number,\r\n      scrollUpdateWasRequested: boolean\r\n    ) => void;\r\n    _callOnScroll = memoizeOne(\r\n      (\r\n        scrollDirection: ScrollDirection,\r\n        scrollOffset: number,\r\n        scrollUpdateWasRequested: boolean\r\n      ) =>\r\n        ((this.props.onScroll: any): onScrollCallback)({\r\n          scrollDirection,\r\n          scrollOffset,\r\n          scrollUpdateWasRequested,\r\n        })\r\n    );\r\n\r\n    _callPropsCallbacks() {\r\n      if (typeof this.props.onItemsRendered === 'function') {\r\n        const { itemCount } = this.props;\r\n        if (itemCount > 0) {\r\n          const [\r\n            overscanStartIndex,\r\n            overscanStopIndex,\r\n            visibleStartIndex,\r\n            visibleStopIndex,\r\n          ] = this._getRangeToRender();\r\n          this._callOnItemsRendered(\r\n            overscanStartIndex,\r\n            overscanStopIndex,\r\n            visibleStartIndex,\r\n            visibleStopIndex\r\n          );\r\n        }\r\n      }\r\n\r\n      if (typeof this.props.onScroll === 'function') {\r\n        const {\r\n          scrollDirection,\r\n          scrollOffset,\r\n          scrollUpdateWasRequested,\r\n        } = this.state;\r\n        this._callOnScroll(\r\n          scrollDirection,\r\n          scrollOffset,\r\n          scrollUpdateWasRequested\r\n        );\r\n      }\r\n    }\r\n\r\n    // Lazily create and cache item styles while scrolling,\r\n    // So that pure component sCU will prevent re-renders.\r\n    // We maintain this cache, and pass a style prop rather than index,\r\n    // So that List can clear cached styles and force item re-render if necessary.\r\n    _getItemStyle: (index: number) => Object;\r\n    _getItemStyle = (index: number): Object => {\r\n      const { direction, itemSize, layout } = this.props;\r\n\r\n      const itemStyleCache = this._getItemStyleCache(\r\n        shouldResetStyleCacheOnItemSizeChange && itemSize,\r\n        shouldResetStyleCacheOnItemSizeChange && layout,\r\n        shouldResetStyleCacheOnItemSizeChange && direction\r\n      );\r\n\r\n      let style;\r\n      if (itemStyleCache.hasOwnProperty(index)) {\r\n        style = itemStyleCache[index];\r\n      } else {\r\n        const offset = getItemOffset(this.props, index, this._instanceProps);\r\n        const size = getItemSize(this.props, index, this._instanceProps);\r\n\r\n        // TODO Deprecate direction \"horizontal\"\r\n        const isHorizontal =\r\n          direction === 'horizontal' || layout === 'horizontal';\r\n\r\n        const isRtl = direction === 'rtl';\r\n        const offsetHorizontal = isHorizontal ? offset : 0;\r\n        itemStyleCache[index] = style = {\r\n          position: 'absolute',\r\n          left: isRtl ? undefined : offsetHorizontal,\r\n          right: isRtl ? offsetHorizontal : undefined,\r\n          top: !isHorizontal ? offset : 0,\r\n          height: !isHorizontal ? size : '100%',\r\n          width: isHorizontal ? size : '100%',\r\n        };\r\n      }\r\n\r\n      return style;\r\n    };\r\n\r\n    _getItemStyleCache: (_: any, __: any, ___: any) => ItemStyleCache;\r\n    _getItemStyleCache = memoizeOne((_: any, __: any, ___: any) => ({}));\r\n\r\n    _getRangeToRender(): [number, number, number, number] {\r\n      const { itemCount, overscanCount } = this.props;\r\n      const { isScrolling, scrollDirection, scrollOffset } = this.state;\r\n\r\n      if (itemCount === 0) {\r\n        return [0, 0, 0, 0];\r\n      }\r\n\r\n      const startIndex = getStartIndexForOffset(\r\n        this.props,\r\n        scrollOffset,\r\n        this._instanceProps\r\n      );\r\n      const stopIndex = getStopIndexForStartIndex(\r\n        this.props,\r\n        startIndex,\r\n        scrollOffset,\r\n        this._instanceProps\r\n      );\r\n\r\n      // Overscan by one item in each direction so that tab/focus works.\r\n      // If there isn't at least one extra item, tab loops back around.\r\n      const overscanBackward =\r\n        !isScrolling || scrollDirection === 'backward'\r\n          ? Math.max(1, overscanCount)\r\n          : 1;\r\n      const overscanForward =\r\n        !isScrolling || scrollDirection === 'forward'\r\n          ? Math.max(1, overscanCount)\r\n          : 1;\r\n\r\n      return [\r\n        Math.max(0, startIndex - overscanBackward),\r\n        Math.max(0, Math.min(itemCount - 1, stopIndex + overscanForward)),\r\n        startIndex,\r\n        stopIndex,\r\n      ];\r\n    }\r\n\r\n    _onScrollHorizontal = (event: ScrollEvent): void => {\r\n      const { clientWidth, scrollLeft, scrollWidth } = event.currentTarget;\r\n      this.setState(prevState => {\r\n        if (prevState.scrollOffset === scrollLeft) {\r\n          // Scroll position may have been updated by cDM/cDU,\r\n          // In which case we don't need to trigger another render,\r\n          // And we don't want to update state.isScrolling.\r\n          return null;\r\n        }\r\n\r\n        const { direction } = this.props;\r\n\r\n        let scrollOffset = scrollLeft;\r\n        if (direction === 'rtl') {\r\n          // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\r\n          // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\r\n          // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\r\n          // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\r\n          switch (getRTLOffsetType()) {\r\n            case 'negative':\r\n              scrollOffset = -scrollLeft;\r\n              break;\r\n            case 'positive-descending':\r\n              scrollOffset = scrollWidth - clientWidth - scrollLeft;\r\n              break;\r\n          }\r\n        }\r\n\r\n        // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\r\n        scrollOffset = Math.max(\r\n          0,\r\n          Math.min(scrollOffset, scrollWidth - clientWidth)\r\n        );\r\n\r\n        return {\r\n          isScrolling: true,\r\n          scrollDirection:\r\n            prevState.scrollOffset < scrollLeft ? 'forward' : 'backward',\r\n          scrollOffset,\r\n          scrollUpdateWasRequested: false,\r\n        };\r\n      }, this._resetIsScrollingDebounced);\r\n    };\r\n\r\n    _onScrollVertical = (event: ScrollEvent): void => {\r\n      const { clientHeight, scrollHeight, scrollTop } = event.currentTarget;\r\n      this.setState(prevState => {\r\n        if (prevState.scrollOffset === scrollTop) {\r\n          // Scroll position may have been updated by cDM/cDU,\r\n          // In which case we don't need to trigger another render,\r\n          // And we don't want to update state.isScrolling.\r\n          return null;\r\n        }\r\n\r\n        // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\r\n        const scrollOffset = Math.max(\r\n          0,\r\n          Math.min(scrollTop, scrollHeight - clientHeight)\r\n        );\r\n\r\n        return {\r\n          isScrolling: true,\r\n          scrollDirection:\r\n            prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\r\n          scrollOffset,\r\n          scrollUpdateWasRequested: false,\r\n        };\r\n      }, this._resetIsScrollingDebounced);\r\n    };\r\n\r\n    _outerRefSetter = (ref: any): void => {\r\n      const { outerRef } = this.props;\r\n\r\n      this._outerRef = ((ref: any): HTMLDivElement);\r\n\r\n      if (typeof outerRef === 'function') {\r\n        outerRef(ref);\r\n      } else if (\r\n        outerRef != null &&\r\n        typeof outerRef === 'object' &&\r\n        outerRef.hasOwnProperty('current')\r\n      ) {\r\n        outerRef.current = ref;\r\n      }\r\n    };\r\n\r\n    _resetIsScrollingDebounced = () => {\r\n      if (this._resetIsScrollingTimeoutId !== null) {\r\n        cancelTimeout(this._resetIsScrollingTimeoutId);\r\n      }\r\n\r\n      this._resetIsScrollingTimeoutId = requestTimeout(\r\n        this._resetIsScrolling,\r\n        IS_SCROLLING_DEBOUNCE_INTERVAL\r\n      );\r\n    };\r\n\r\n    _resetIsScrolling = () => {\r\n      this._resetIsScrollingTimeoutId = null;\r\n\r\n      this.setState({ isScrolling: false }, () => {\r\n        // Clear style cache after state update has been committed.\r\n        // This way we don't break pure sCU for items that don't use isScrolling param.\r\n        this._getItemStyleCache(-1, null);\r\n      });\r\n    };\r\n  };\r\n}\r\n\r\n// NOTE: I considered further wrapping individual items with a pure ListItem component.\r\n// This would avoid ever calling the render function for the same index more than once,\r\n// But it would also add the overhead of a lot of components/fibers.\r\n// I assume people already do this (render function returning a class component),\r\n// So my doing it would just unnecessarily double the wrappers.\r\n\r\nconst validateSharedProps = (\r\n  {\r\n    children,\r\n    direction,\r\n    height,\r\n    layout,\r\n    innerTagName,\r\n    outerTagName,\r\n    width,\r\n  }: Props<any>,\r\n  { instance }: State\r\n): void => {\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    if (innerTagName != null || outerTagName != null) {\r\n      if (devWarningsTagName && !devWarningsTagName.has(instance)) {\r\n        devWarningsTagName.add(instance);\r\n        console.warn(\r\n          'The innerTagName and outerTagName props have been deprecated. ' +\r\n            'Please use the innerElementType and outerElementType props instead.'\r\n        );\r\n      }\r\n    }\r\n\r\n    // TODO Deprecate direction \"horizontal\"\r\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\r\n\r\n    switch (direction) {\r\n      case 'horizontal':\r\n      case 'vertical':\r\n        if (devWarningsDirection && !devWarningsDirection.has(instance)) {\r\n          devWarningsDirection.add(instance);\r\n          console.warn(\r\n            'The direction prop should be either \"ltr\" (default) or \"rtl\". ' +\r\n              'Please use the layout prop to specify \"vertical\" (default) or \"horizontal\" orientation.'\r\n          );\r\n        }\r\n        break;\r\n      case 'ltr':\r\n      case 'rtl':\r\n        // Valid values\r\n        break;\r\n      default:\r\n        throw Error(\r\n          'An invalid \"direction\" prop has been specified. ' +\r\n            'Value should be either \"ltr\" or \"rtl\". ' +\r\n            `\"${direction}\" was specified.`\r\n        );\r\n    }\r\n\r\n    switch (layout) {\r\n      case 'horizontal':\r\n      case 'vertical':\r\n        // Valid values\r\n        break;\r\n      default:\r\n        throw Error(\r\n          'An invalid \"layout\" prop has been specified. ' +\r\n            'Value should be either \"horizontal\" or \"vertical\". ' +\r\n            `\"${layout}\" was specified.`\r\n        );\r\n    }\r\n\r\n    if (children == null) {\r\n      throw Error(\r\n        'An invalid \"children\" prop has been specified. ' +\r\n          'Value should be a React component. ' +\r\n          `\"${children === null ? 'null' : typeof children}\" was specified.`\r\n      );\r\n    }\r\n\r\n    if (isHorizontal && typeof width !== 'number') {\r\n      throw Error(\r\n        'An invalid \"width\" prop has been specified. ' +\r\n          'Horizontal lists must specify a number for width. ' +\r\n          `\"${width === null ? 'null' : typeof width}\" was specified.`\r\n      );\r\n    } else if (!isHorizontal && typeof height !== 'number') {\r\n      throw Error(\r\n        'An invalid \"height\" prop has been specified. ' +\r\n          'Vertical lists must specify a number for height. ' +\r\n          `\"${height === null ? 'null' : typeof height}\" was specified.`\r\n      );\r\n    }\r\n  }\r\n};\r\n","// @flow\r\n\r\nimport createListComponent from './createListComponent';\r\n\r\nimport type { Props, ScrollToAlign } from './createListComponent';\r\n\r\nconst DEFAULT_ESTIMATED_ITEM_SIZE = 50;\r\n\r\ntype VariableSizeProps = {|\r\n  estimatedItemSize: number,\r\n  ...Props<any>,\r\n|};\r\n\r\ntype itemSizeGetter = (index: number) => number;\r\n\r\ntype ItemMetadata = {|\r\n  offset: number,\r\n  size: number,\r\n|};\r\ntype InstanceProps = {|\r\n  itemMetadataMap: { [index: number]: ItemMetadata },\r\n  estimatedItemSize: number,\r\n  lastMeasuredIndex: number,\r\n|};\r\n\r\nconst getItemMetadata = (\r\n  props: Props<any>,\r\n  index: number,\r\n  instanceProps: InstanceProps\r\n): ItemMetadata => {\r\n  const { itemSize } = ((props: any): VariableSizeProps);\r\n  const { itemMetadataMap, lastMeasuredIndex } = instanceProps;\r\n\r\n  if (index > lastMeasuredIndex) {\r\n    let offset = 0;\r\n    if (lastMeasuredIndex >= 0) {\r\n      const itemMetadata = itemMetadataMap[lastMeasuredIndex];\r\n      offset = itemMetadata.offset + itemMetadata.size;\r\n    }\r\n\r\n    for (let i = lastMeasuredIndex + 1; i <= index; i++) {\r\n      let size = ((itemSize: any): itemSizeGetter)(i);\r\n\r\n      itemMetadataMap[i] = {\r\n        offset,\r\n        size,\r\n      };\r\n\r\n      offset += size;\r\n    }\r\n\r\n    instanceProps.lastMeasuredIndex = index;\r\n  }\r\n\r\n  return itemMetadataMap[index];\r\n};\r\n\r\nconst findNearestItem = (\r\n  props: Props<any>,\r\n  instanceProps: InstanceProps,\r\n  offset: number\r\n) => {\r\n  const { itemMetadataMap, lastMeasuredIndex } = instanceProps;\r\n\r\n  const lastMeasuredItemOffset =\r\n    lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\r\n\r\n  if (lastMeasuredItemOffset >= offset) {\r\n    // If we've already measured items within this range just use a binary search as it's faster.\r\n    return findNearestItemBinarySearch(\r\n      props,\r\n      instanceProps,\r\n      lastMeasuredIndex,\r\n      0,\r\n      offset\r\n    );\r\n  } else {\r\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\r\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\r\n    // The overall complexity for this approach is O(log n).\r\n    return findNearestItemExponentialSearch(\r\n      props,\r\n      instanceProps,\r\n      Math.max(0, lastMeasuredIndex),\r\n      offset\r\n    );\r\n  }\r\n};\r\n\r\nconst findNearestItemBinarySearch = (\r\n  props: Props<any>,\r\n  instanceProps: InstanceProps,\r\n  high: number,\r\n  low: number,\r\n  offset: number\r\n): number => {\r\n  while (low <= high) {\r\n    const middle = low + Math.floor((high - low) / 2);\r\n    const currentOffset = getItemMetadata(props, middle, instanceProps).offset;\r\n\r\n    if (currentOffset === offset) {\r\n      return middle;\r\n    } else if (currentOffset < offset) {\r\n      low = middle + 1;\r\n    } else if (currentOffset > offset) {\r\n      high = middle - 1;\r\n    }\r\n  }\r\n\r\n  if (low > 0) {\r\n    return low - 1;\r\n  } else {\r\n    return 0;\r\n  }\r\n};\r\n\r\nconst findNearestItemExponentialSearch = (\r\n  props: Props<any>,\r\n  instanceProps: InstanceProps,\r\n  index: number,\r\n  offset: number\r\n): number => {\r\n  const { itemCount } = props;\r\n  let interval = 1;\r\n\r\n  while (\r\n    index < itemCount &&\r\n    getItemMetadata(props, index, instanceProps).offset < offset\r\n  ) {\r\n    index += interval;\r\n    interval *= 2;\r\n  }\r\n\r\n  return findNearestItemBinarySearch(\r\n    props,\r\n    instanceProps,\r\n    Math.min(index, itemCount - 1),\r\n    Math.floor(index / 2),\r\n    offset\r\n  );\r\n};\r\n\r\nconst getEstimatedTotalSize = (\r\n  { itemCount }: Props<any>,\r\n  { itemMetadataMap, estimatedItemSize, lastMeasuredIndex }: InstanceProps\r\n) => {\r\n  let totalSizeOfMeasuredItems = 0;\r\n\r\n  // Edge case check for when the number of items decreases while a scroll is in progress.\r\n  // https://github.com/bvaughn/react-window/pull/138\r\n  if (lastMeasuredIndex >= itemCount) {\r\n    lastMeasuredIndex = itemCount - 1;\r\n  }\r\n\r\n  if (lastMeasuredIndex >= 0) {\r\n    const itemMetadata = itemMetadataMap[lastMeasuredIndex];\r\n    totalSizeOfMeasuredItems = itemMetadata.offset + itemMetadata.size;\r\n  }\r\n\r\n  const numUnmeasuredItems = itemCount - lastMeasuredIndex - 1;\r\n  const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;\r\n\r\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;\r\n};\r\n\r\nconst VariableSizeList = createListComponent({\r\n  getItemOffset: (\r\n    props: Props<any>,\r\n    index: number,\r\n    instanceProps: InstanceProps\r\n  ): number => getItemMetadata(props, index, instanceProps).offset,\r\n\r\n  getItemSize: (\r\n    props: Props<any>,\r\n    index: number,\r\n    instanceProps: InstanceProps\r\n  ): number => instanceProps.itemMetadataMap[index].size,\r\n\r\n  getEstimatedTotalSize,\r\n\r\n  getOffsetForIndexAndAlignment: (\r\n    props: Props<any>,\r\n    index: number,\r\n    align: ScrollToAlign,\r\n    scrollOffset: number,\r\n    instanceProps: InstanceProps,\r\n    scrollbarSize: number\r\n  ): number => {\r\n    const { direction, height, layout, width } = props;\r\n\r\n    // TODO Deprecate direction \"horizontal\"\r\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\r\n    const size = (((isHorizontal ? width : height): any): number);\r\n    const itemMetadata = getItemMetadata(props, index, instanceProps);\r\n\r\n    // Get estimated total size after ItemMetadata is computed,\r\n    // To ensure it reflects actual measurements instead of just estimates.\r\n    const estimatedTotalSize = getEstimatedTotalSize(props, instanceProps);\r\n\r\n    const maxOffset = Math.max(\r\n      0,\r\n      Math.min(estimatedTotalSize - size, itemMetadata.offset)\r\n    );\r\n    const minOffset = Math.max(\r\n      0,\r\n      itemMetadata.offset - size + itemMetadata.size + scrollbarSize\r\n    );\r\n\r\n    if (align === 'smart') {\r\n      if (\r\n        scrollOffset >= minOffset - size &&\r\n        scrollOffset <= maxOffset + size\r\n      ) {\r\n        align = 'auto';\r\n      } else {\r\n        align = 'center';\r\n      }\r\n    }\r\n\r\n    switch (align) {\r\n      case 'start':\r\n        return maxOffset;\r\n      case 'end':\r\n        return minOffset;\r\n      case 'center':\r\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\r\n      case 'auto':\r\n      default:\r\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\r\n          return scrollOffset;\r\n        } else if (scrollOffset < minOffset) {\r\n          return minOffset;\r\n        } else {\r\n          return maxOffset;\r\n        }\r\n    }\r\n  },\r\n\r\n  getStartIndexForOffset: (\r\n    props: Props<any>,\r\n    offset: number,\r\n    instanceProps: InstanceProps\r\n  ): number => findNearestItem(props, instanceProps, offset),\r\n\r\n  getStopIndexForStartIndex: (\r\n    props: Props<any>,\r\n    startIndex: number,\r\n    scrollOffset: number,\r\n    instanceProps: InstanceProps\r\n  ): number => {\r\n    const { direction, height, itemCount, layout, width } = props;\r\n\r\n    // TODO Deprecate direction \"horizontal\"\r\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\r\n    const size = (((isHorizontal ? width : height): any): number);\r\n    const itemMetadata = getItemMetadata(props, startIndex, instanceProps);\r\n    const maxOffset = scrollOffset + size;\r\n\r\n    let offset = itemMetadata.offset + itemMetadata.size;\r\n    let stopIndex = startIndex;\r\n\r\n    while (stopIndex < itemCount - 1 && offset < maxOffset) {\r\n      stopIndex++;\r\n      offset += getItemMetadata(props, stopIndex, instanceProps).size;\r\n    }\r\n\r\n    return stopIndex;\r\n  },\r\n\r\n  initInstanceProps(props: Props<any>, instance: any): InstanceProps {\r\n    const { estimatedItemSize } = ((props: any): VariableSizeProps);\r\n\r\n    const instanceProps = {\r\n      itemMetadataMap: {},\r\n      estimatedItemSize: estimatedItemSize || DEFAULT_ESTIMATED_ITEM_SIZE,\r\n      lastMeasuredIndex: -1,\r\n    };\r\n\r\n    instance.resetAfterIndex = (\r\n      index: number,\r\n      shouldForceUpdate?: boolean = true\r\n    ) => {\r\n      instanceProps.lastMeasuredIndex = Math.min(\r\n        instanceProps.lastMeasuredIndex,\r\n        index - 1\r\n      );\r\n\r\n      // We could potentially optimize further by only evicting styles after this index,\r\n      // But since styles are only cached while scrolling is in progress-\r\n      // It seems an unnecessary optimization.\r\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\r\n      instance._getItemStyleCache(-1);\r\n\r\n      if (shouldForceUpdate) {\r\n        instance.forceUpdate();\r\n      }\r\n    };\r\n\r\n    return instanceProps;\r\n  },\r\n\r\n  shouldResetStyleCacheOnItemSizeChange: false,\r\n\r\n  validateProps: ({ itemSize }: Props<any>): void => {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      if (typeof itemSize !== 'function') {\r\n        throw Error(\r\n          'An invalid \"itemSize\" prop has been specified. ' +\r\n            'Value should be a function. ' +\r\n            `\"${itemSize === null ? 'null' : typeof itemSize}\" was specified.`\r\n        );\r\n      }\r\n    }\r\n  },\r\n});\r\n\r\nexport default VariableSizeList;\r\n","// @flow\r\n\r\nimport createGridComponent from './createGridComponent';\r\n\r\nimport type { Props, ScrollToAlign } from './createGridComponent';\r\n\r\nconst FixedSizeGrid = createGridComponent({\r\n  getColumnOffset: ({ columnWidth }: Props<any>, index: number): number =>\r\n    index * ((columnWidth: any): number),\r\n\r\n  getColumnWidth: ({ columnWidth }: Props<any>, index: number): number =>\r\n    ((columnWidth: any): number),\r\n\r\n  getRowOffset: ({ rowHeight }: Props<any>, index: number): number =>\r\n    index * ((rowHeight: any): number),\r\n\r\n  getRowHeight: ({ rowHeight }: Props<any>, index: number): number =>\r\n    ((rowHeight: any): number),\r\n\r\n  getEstimatedTotalHeight: ({ rowCount, rowHeight }: Props<any>) =>\r\n    ((rowHeight: any): number) * rowCount,\r\n\r\n  getEstimatedTotalWidth: ({ columnCount, columnWidth }: Props<any>) =>\r\n    ((columnWidth: any): number) * columnCount,\r\n\r\n  getOffsetForColumnAndAlignment: (\r\n    { columnCount, columnWidth, width }: Props<any>,\r\n    columnIndex: number,\r\n    align: ScrollToAlign,\r\n    scrollLeft: number,\r\n    instanceProps: typeof undefined,\r\n    scrollbarSize: number\r\n  ): number => {\r\n    const lastColumnOffset = Math.max(\r\n      0,\r\n      columnCount * ((columnWidth: any): number) - width\r\n    );\r\n    const maxOffset = Math.min(\r\n      lastColumnOffset,\r\n      columnIndex * ((columnWidth: any): number)\r\n    );\r\n    const minOffset = Math.max(\r\n      0,\r\n      columnIndex * ((columnWidth: any): number) -\r\n        width +\r\n        scrollbarSize +\r\n        ((columnWidth: any): number)\r\n    );\r\n\r\n    if (align === 'smart') {\r\n      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {\r\n        align = 'auto';\r\n      } else {\r\n        align = 'center';\r\n      }\r\n    }\r\n\r\n    switch (align) {\r\n      case 'start':\r\n        return maxOffset;\r\n      case 'end':\r\n        return minOffset;\r\n      case 'center':\r\n        // \"Centered\" offset is usually the average of the min and max.\r\n        // But near the edges of the list, this doesn't hold true.\r\n        const middleOffset = Math.round(\r\n          minOffset + (maxOffset - minOffset) / 2\r\n        );\r\n        if (middleOffset < Math.ceil(width / 2)) {\r\n          return 0; // near the beginning\r\n        } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {\r\n          return lastColumnOffset; // near the end\r\n        } else {\r\n          return middleOffset;\r\n        }\r\n      case 'auto':\r\n      default:\r\n        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {\r\n          return scrollLeft;\r\n        } else if (minOffset > maxOffset) {\r\n          // Because we only take into account the scrollbar size when calculating minOffset\r\n          // this value can be larger than maxOffset when at the end of the list\r\n          return minOffset;\r\n        } else if (scrollLeft < minOffset) {\r\n          return minOffset;\r\n        } else {\r\n          return maxOffset;\r\n        }\r\n    }\r\n  },\r\n\r\n  getOffsetForRowAndAlignment: (\r\n    { rowHeight, height, rowCount }: Props<any>,\r\n    rowIndex: number,\r\n    align: ScrollToAlign,\r\n    scrollTop: number,\r\n    instanceProps: typeof undefined,\r\n    scrollbarSize: number\r\n  ): number => {\r\n    const lastRowOffset = Math.max(\r\n      0,\r\n      rowCount * ((rowHeight: any): number) - height\r\n    );\r\n    const maxOffset = Math.min(\r\n      lastRowOffset,\r\n      rowIndex * ((rowHeight: any): number)\r\n    );\r\n    const minOffset = Math.max(\r\n      0,\r\n      rowIndex * ((rowHeight: any): number) -\r\n        height +\r\n        scrollbarSize +\r\n        ((rowHeight: any): number)\r\n    );\r\n\r\n    if (align === 'smart') {\r\n      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {\r\n        align = 'auto';\r\n      } else {\r\n        align = 'center';\r\n      }\r\n    }\r\n\r\n    switch (align) {\r\n      case 'start':\r\n        return maxOffset;\r\n      case 'end':\r\n        return minOffset;\r\n      case 'center':\r\n        // \"Centered\" offset is usually the average of the min and max.\r\n        // But near the edges of the list, this doesn't hold true.\r\n        const middleOffset = Math.round(\r\n          minOffset + (maxOffset - minOffset) / 2\r\n        );\r\n        if (middleOffset < Math.ceil(height / 2)) {\r\n          return 0; // near the beginning\r\n        } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {\r\n          return lastRowOffset; // near the end\r\n        } else {\r\n          return middleOffset;\r\n        }\r\n      case 'auto':\r\n      default:\r\n        if (scrollTop >= minOffset && scrollTop <= maxOffset) {\r\n          return scrollTop;\r\n        } else if (minOffset > maxOffset) {\r\n          // Because we only take into account the scrollbar size when calculating minOffset\r\n          // this value can be larger than maxOffset when at the end of the list\r\n          return minOffset;\r\n        } else if (scrollTop < minOffset) {\r\n          return minOffset;\r\n        } else {\r\n          return maxOffset;\r\n        }\r\n    }\r\n  },\r\n\r\n  getColumnStartIndexForOffset: (\r\n    { columnWidth, columnCount }: Props<any>,\r\n    scrollLeft: number\r\n  ): number =>\r\n    Math.max(\r\n      0,\r\n      Math.min(\r\n        columnCount - 1,\r\n        Math.floor(scrollLeft / ((columnWidth: any): number))\r\n      )\r\n    ),\r\n\r\n  getColumnStopIndexForStartIndex: (\r\n    { columnWidth, columnCount, width }: Props<any>,\r\n    startIndex: number,\r\n    scrollLeft: number\r\n  ): number => {\r\n    const left = startIndex * ((columnWidth: any): number);\r\n    const numVisibleColumns = Math.ceil(\r\n      (width + scrollLeft - left) / ((columnWidth: any): number)\r\n    );\r\n    return Math.max(\r\n      0,\r\n      Math.min(\r\n        columnCount - 1,\r\n        startIndex + numVisibleColumns - 1 // -1 is because stop index is inclusive\r\n      )\r\n    );\r\n  },\r\n\r\n  getRowStartIndexForOffset: (\r\n    { rowHeight, rowCount }: Props<any>,\r\n    scrollTop: number\r\n  ): number =>\r\n    Math.max(\r\n      0,\r\n      Math.min(rowCount - 1, Math.floor(scrollTop / ((rowHeight: any): number)))\r\n    ),\r\n\r\n  getRowStopIndexForStartIndex: (\r\n    { rowHeight, rowCount, height }: Props<any>,\r\n    startIndex: number,\r\n    scrollTop: number\r\n  ): number => {\r\n    const top = startIndex * ((rowHeight: any): number);\r\n    const numVisibleRows = Math.ceil(\r\n      (height + scrollTop - top) / ((rowHeight: any): number)\r\n    );\r\n    return Math.max(\r\n      0,\r\n      Math.min(\r\n        rowCount - 1,\r\n        startIndex + numVisibleRows - 1 // -1 is because stop index is inclusive\r\n      )\r\n    );\r\n  },\r\n\r\n  initInstanceProps(props: Props<any>): any {\r\n    // Noop\r\n  },\r\n\r\n  shouldResetStyleCacheOnItemSizeChange: true,\r\n\r\n  validateProps: ({ columnWidth, rowHeight }: Props<any>): void => {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      if (typeof columnWidth !== 'number') {\r\n        throw Error(\r\n          'An invalid \"columnWidth\" prop has been specified. ' +\r\n            'Value should be a number. ' +\r\n            `\"${\r\n              columnWidth === null ? 'null' : typeof columnWidth\r\n            }\" was specified.`\r\n        );\r\n      }\r\n\r\n      if (typeof rowHeight !== 'number') {\r\n        throw Error(\r\n          'An invalid \"rowHeight\" prop has been specified. ' +\r\n            'Value should be a number. ' +\r\n            `\"${rowHeight === null ? 'null' : typeof rowHeight}\" was specified.`\r\n        );\r\n      }\r\n    }\r\n  },\r\n});\r\n\r\nexport default FixedSizeGrid;\r\n","// @flow\r\n\r\nimport createListComponent from './createListComponent';\r\n\r\nimport type { Props, ScrollToAlign } from './createListComponent';\r\n\r\ntype InstanceProps = any;\r\n\r\nconst FixedSizeList = createListComponent({\r\n  getItemOffset: ({ itemSize }: Props<any>, index: number): number =>\r\n    index * ((itemSize: any): number),\r\n\r\n  getItemSize: ({ itemSize }: Props<any>, index: number): number =>\r\n    ((itemSize: any): number),\r\n\r\n  getEstimatedTotalSize: ({ itemCount, itemSize }: Props<any>) =>\r\n    ((itemSize: any): number) * itemCount,\r\n\r\n  getOffsetForIndexAndAlignment: (\r\n    { direction, height, itemCount, itemSize, layout, width }: Props<any>,\r\n    index: number,\r\n    align: ScrollToAlign,\r\n    scrollOffset: number,\r\n    instanceProps: InstanceProps,\r\n    scrollbarSize: number\r\n  ): number => {\r\n    // TODO Deprecate direction \"horizontal\"\r\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\r\n    const size = (((isHorizontal ? width : height): any): number);\r\n    const lastItemOffset = Math.max(\r\n      0,\r\n      itemCount * ((itemSize: any): number) - size\r\n    );\r\n    const maxOffset = Math.min(\r\n      lastItemOffset,\r\n      index * ((itemSize: any): number)\r\n    );\r\n    const minOffset = Math.max(\r\n      0,\r\n      index * ((itemSize: any): number) -\r\n        size +\r\n        ((itemSize: any): number) +\r\n        scrollbarSize\r\n    );\r\n\r\n    if (align === 'smart') {\r\n      if (\r\n        scrollOffset >= minOffset - size &&\r\n        scrollOffset <= maxOffset + size\r\n      ) {\r\n        align = 'auto';\r\n      } else {\r\n        align = 'center';\r\n      }\r\n    }\r\n\r\n    switch (align) {\r\n      case 'start':\r\n        return maxOffset;\r\n      case 'end':\r\n        return minOffset;\r\n      case 'center': {\r\n        // \"Centered\" offset is usually the average of the min and max.\r\n        // But near the edges of the list, this doesn't hold true.\r\n        const middleOffset = Math.round(\r\n          minOffset + (maxOffset - minOffset) / 2\r\n        );\r\n        if (middleOffset < Math.ceil(size / 2)) {\r\n          return 0; // near the beginning\r\n        } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {\r\n          return lastItemOffset; // near the end\r\n        } else {\r\n          return middleOffset;\r\n        }\r\n      }\r\n      case 'auto':\r\n      default:\r\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\r\n          return scrollOffset;\r\n        } else if (scrollOffset < minOffset) {\r\n          return minOffset;\r\n        } else {\r\n          return maxOffset;\r\n        }\r\n    }\r\n  },\r\n\r\n  getStartIndexForOffset: (\r\n    { itemCount, itemSize }: Props<any>,\r\n    offset: number\r\n  ): number =>\r\n    Math.max(\r\n      0,\r\n      Math.min(itemCount - 1, Math.floor(offset / ((itemSize: any): number)))\r\n    ),\r\n\r\n  getStopIndexForStartIndex: (\r\n    { direction, height, itemCount, itemSize, layout, width }: Props<any>,\r\n    startIndex: number,\r\n    scrollOffset: number\r\n  ): number => {\r\n    // TODO Deprecate direction \"horizontal\"\r\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\r\n    const offset = startIndex * ((itemSize: any): number);\r\n    const size = (((isHorizontal ? width : height): any): number);\r\n    const numVisibleItems = Math.ceil(\r\n      (size + scrollOffset - offset) / ((itemSize: any): number)\r\n    );\r\n    return Math.max(\r\n      0,\r\n      Math.min(\r\n        itemCount - 1,\r\n        startIndex + numVisibleItems - 1 // -1 is because stop index is inclusive\r\n      )\r\n    );\r\n  },\r\n\r\n  initInstanceProps(props: Props<any>): any {\r\n    // Noop\r\n  },\r\n\r\n  shouldResetStyleCacheOnItemSizeChange: true,\r\n\r\n  validateProps: ({ itemSize }: Props<any>): void => {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      if (typeof itemSize !== 'number') {\r\n        throw Error(\r\n          'An invalid \"itemSize\" prop has been specified. ' +\r\n            'Value should be a number. ' +\r\n            `\"${itemSize === null ? 'null' : typeof itemSize}\" was specified.`\r\n        );\r\n      }\r\n    }\r\n  },\r\n});\r\n\r\nexport default FixedSizeList;\r\n","// @flow\r\n\r\n// Pulled from react-compat\r\n// https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349\r\nexport default function shallowDiffers(prev: Object, next: Object): boolean {\r\n  for (let attribute in prev) {\r\n    if (!(attribute in next)) {\r\n      return true;\r\n    }\r\n  }\r\n  for (let attribute in next) {\r\n    if (prev[attribute] !== next[attribute]) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n","// @flow\r\n\r\nimport shallowDiffers from './shallowDiffers';\r\n\r\n// Custom comparison function for React.memo().\r\n// It knows to compare individual style props and ignore the wrapper object.\r\n// See https://reactjs.org/docs/react-api.html#reactmemo\r\nexport default function areEqual(\r\n  prevProps: Object,\r\n  nextProps: Object\r\n): boolean {\r\n  const { style: prevStyle, ...prevRest } = prevProps;\r\n  const { style: nextStyle, ...nextRest } = nextProps;\r\n\r\n  return (\r\n    !shallowDiffers(prevStyle, nextStyle) && !shallowDiffers(prevRest, nextRest)\r\n  );\r\n}\r\n","// @flow\r\n\r\nimport areEqual from './areEqual';\r\nimport shallowDiffers from './shallowDiffers';\r\n\r\n// Custom shouldComponentUpdate for class components.\r\n// It knows to compare individual style props and ignore the wrapper object.\r\n// See https://reactjs.org/docs/react-component.html#shouldcomponentupdate\r\nexport default function shouldComponentUpdate(\r\n  nextProps: Object,\r\n  nextState: Object\r\n): boolean {\r\n  return (\r\n    !areEqual(this.props, nextProps) || shallowDiffers(this.state, nextState)\r\n  );\r\n}\r\n"],"names":["hasNativePerformanceNow","performance","now","Date","cancelTimeout","timeoutID","cancelAnimationFrame","id","requestTimeout","callback","delay","start","tick","call","requestAnimationFrame","size","getScrollbarSize","recalculate","div","document","createElement","style","width","height","overflow","body","appendChild","offsetWidth","clientWidth","removeChild","cachedRTLResult","getRTLOffsetType","outerDiv","outerStyle","direction","innerDiv","innerStyle","scrollLeft","IS_SCROLLING_DEBOUNCE_INTERVAL","defaultItemKey","columnIndex","data","rowIndex","devWarningsOverscanCount","devWarningsOverscanRowsColumnsCount","devWarningsTagName","process","env","NODE_ENV","window","WeakSet","createGridComponent","getColumnOffset","getColumnStartIndexForOffset","getColumnStopIndexForStartIndex","getColumnWidth","getEstimatedTotalHeight","getEstimatedTotalWidth","getOffsetForColumnAndAlignment","getOffsetForRowAndAlignment","getRowHeight","getRowOffset","getRowStartIndexForOffset","getRowStopIndexForStartIndex","initInstanceProps","shouldResetStyleCacheOnItemSizeChange","validateProps","props","_instanceProps","_resetIsScrollingTimeoutId","_outerRef","state","instance","isScrolling","horizontalScrollDirection","initialScrollLeft","scrollTop","initialScrollTop","scrollUpdateWasRequested","verticalScrollDirection","_callOnItemsRendered","memoizeOne","overscanColumnStartIndex","overscanColumnStopIndex","overscanRowStartIndex","overscanRowStopIndex","visibleColumnStartIndex","visibleColumnStopIndex","visibleRowStartIndex","visibleRowStopIndex","onItemsRendered","_callOnScroll","onScroll","_getItemStyle","columnWidth","rowHeight","itemStyleCache","_getItemStyleCache","key","hasOwnProperty","offset","isRtl","position","left","undefined","right","top","_","__","___","_onScroll","event","currentTarget","clientHeight","scrollHeight","scrollWidth","setState","prevState","calculatedScrollLeft","Math","max","min","calculatedScrollTop","_resetIsScrollingDebounced","_outerRefSetter","ref","outerRef","current","_resetIsScrolling","getDerivedStateFromProps","nextProps","validateSharedProps","scrollTo","scrollToItem","align","columnCount","rowCount","scrollbarSize","estimatedTotalHeight","estimatedTotalWidth","horizontalScrollbarSize","verticalScrollbarSize","componentDidMount","_callPropsCallbacks","componentDidUpdate","componentWillUnmount","render","children","className","innerRef","innerElementType","innerTagName","itemData","itemKey","outerElementType","outerTagName","useIsScrolling","disableColVirtualized","disableRowVirtualized","_getHorizontalRangeToRender","columnStartIndex","columnStopIndex","_getVerticalRangeToRender","rowStartIndex","rowStopIndex","items","push","WebkitOverflowScrolling","willChange","pointerEvents","overscanColumnCount","overscanColumnsCount","overscanCount","overscanCountResolved","startIndex","stopIndex","overscanBackward","overscanForward","overscanRowCount","overscanRowsCount","PureComponent","defaultProps","has","add","console","warn","Error","DEFAULT_ESTIMATED_ITEM_SIZE","rowMetadataMap","estimatedRowHeight","lastMeasuredRowIndex","totalSizeOfMeasuredRows","itemMetadata","numUnmeasuredItems","totalSizeOfUnmeasuredItems","columnMetadataMap","estimatedColumnWidth","lastMeasuredColumnIndex","getItemMetadata","itemType","index","instanceProps","itemMetadataMap","itemSize","lastMeasuredIndex","i","findNearestItem","lastMeasuredItemOffset","findNearestItemBinarySearch","findNearestItemExponentialSearch","high","low","middle","floor","currentOffset","itemCount","interval","getOffsetForIndexAndAlignment","scrollOffset","estimatedTotalSize","maxOffset","minOffset","round","VariableSizeGrid","resetAfterColumnIndex","shouldForceUpdate","resetAfterIndices","resetAfterRowIndex","forceUpdate","devWarningsDirection","createListComponent","getItemOffset","getEstimatedTotalSize","getItemSize","getStartIndexForOffset","getStopIndexForStartIndex","scrollDirection","initialScrollOffset","overscanStartIndex","overscanStopIndex","visibleStartIndex","visibleStopIndex","layout","isHorizontal","offsetHorizontal","_onScrollHorizontal","_onScrollVertical","_getRangeToRender","estimatedItemSize","totalSizeOfMeasuredItems","VariableSizeList","resetAfterIndex","FixedSizeGrid","lastColumnOffset","middleOffset","ceil","lastRowOffset","numVisibleColumns","numVisibleRows","FixedSizeList","lastItemOffset","numVisibleItems","shallowDiffers","prev","next","attribute","areEqual","prevProps","prevStyle","prevRest","nextStyle","nextRest","shouldComponentUpdate","nextState"],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/react-window/dist/index.esm.js b/node_modules/react-window/dist/index.esm.js
index dfea961..1c30578 100644
--- a/node_modules/react-window/dist/index.esm.js
+++ b/node_modules/react-window/dist/index.esm.js
@@ -1,6 +1,6 @@
 import _extends from '@babel/runtime/helpers/esm/extends';
-import _inheritsLoose from '@babel/runtime/helpers/esm/inheritsLoose';
 import _assertThisInitialized from '@babel/runtime/helpers/esm/assertThisInitialized';
+import _inheritsLoose from '@babel/runtime/helpers/esm/inheritsLoose';
 import memoizeOne from 'memoize-one';
 import { createElement, PureComponent } from 'react';
 import _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';
@@ -115,20 +115,14 @@ var devWarningsTagName = null;
 
 if (process.env.NODE_ENV !== 'production') {
   if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {
-    devWarningsOverscanCount =
-    /*#__PURE__*/
-    new WeakSet();
-    devWarningsOverscanRowsColumnsCount =
-    /*#__PURE__*/
-    new WeakSet();
-    devWarningsTagName =
-    /*#__PURE__*/
-    new WeakSet();
+    devWarningsOverscanCount = /*#__PURE__*/new WeakSet();
+    devWarningsOverscanRowsColumnsCount = /*#__PURE__*/new WeakSet();
+    devWarningsTagName = /*#__PURE__*/new WeakSet();
   }
 }
 
 function createGridComponent(_ref2) {
-  var _class, _temp;
+  var _class;
 
   var getColumnOffset = _ref2.getColumnOffset,
       getColumnStartIndexForOffset = _ref2.getColumnStartIndexForOffset,
@@ -145,9 +139,7 @@ function createGridComponent(_ref2) {
       initInstanceProps = _ref2.initInstanceProps,
       shouldResetStyleCacheOnItemSizeChange = _ref2.shouldResetStyleCacheOnItemSizeChange,
       validateProps = _ref2.validateProps;
-  return _temp = _class =
-  /*#__PURE__*/
-  function (_PureComponent) {
+  return _class = /*#__PURE__*/function (_PureComponent) {
     _inheritsLoose(Grid, _PureComponent);
 
     // Always use explicit constructor for React components.
@@ -157,11 +149,11 @@ function createGridComponent(_ref2) {
       var _this;
 
       _this = _PureComponent.call(this, props) || this;
-      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_assertThisInitialized(_this)));
+      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_this));
       _this._resetIsScrollingTimeoutId = null;
       _this._outerRef = void 0;
       _this.state = {
-        instance: _assertThisInitialized(_assertThisInitialized(_this)),
+        instance: _assertThisInitialized(_this),
         isScrolling: false,
         horizontalScrollDirection: 'forward',
         scrollLeft: typeof _this.props.initialScrollLeft === 'number' ? _this.props.initialScrollLeft : 0,
@@ -475,7 +467,9 @@ function createGridComponent(_ref2) {
           rowCount = _this$props4.rowCount,
           style = _this$props4.style,
           useIsScrolling = _this$props4.useIsScrolling,
-          width = _this$props4.width;
+          width = _this$props4.width,
+          disableColVirtualized = _this$props4.disableColVirtualized,
+          disableRowVirtualized = _this$props4.disableRowVirtualized;
       var isScrolling = this.state.isScrolling;
 
       var _this$_getHorizontalR = this._getHorizontalRangeToRender(),
@@ -486,6 +480,8 @@ function createGridComponent(_ref2) {
           rowStartIndex = _this$_getVerticalRan[0],
           rowStopIndex = _this$_getVerticalRan[1];
 
+      if (disableColVirtualized) columnStartIndex = 0;
+      if (disableRowVirtualized) rowStartIndex = 0;
       var items = [];
 
       if (columnCount > 0 && rowCount) {
@@ -570,11 +566,11 @@ function createGridComponent(_ref2) {
 
         this._callOnScroll(_scrollLeft, _scrollTop, _horizontalScrollDirection, _verticalScrollDirection, _scrollUpdateWasRequested);
       }
-    }; // Lazily create and cache item styles while scrolling,
+    } // Lazily create and cache item styles while scrolling,
     // So that pure component sCU will prevent re-renders.
     // We maintain this cache, and pass a style prop rather than index,
     // So that List can clear cached styles and force item re-render if necessary.
-
+    ;
 
     _proto._getHorizontalRangeToRender = function _getHorizontalRangeToRender() {
       var _this$props6 = this.props,
@@ -633,7 +629,7 @@ function createGridComponent(_ref2) {
     direction: 'ltr',
     itemData: undefined,
     useIsScrolling: false
-  }, _temp;
+  }, _class;
 }
 
 var validateSharedProps = function validateSharedProps(_ref5, _ref6) {
@@ -881,9 +877,7 @@ var getOffsetForIndexAndAlignment = function getOffsetForIndexAndAlignment(itemT
   }
 };
 
-var VariableSizeGrid =
-/*#__PURE__*/
-createGridComponent({
+var VariableSizeGrid = /*#__PURE__*/createGridComponent({
   getColumnOffset: function getColumnOffset(props, index, instanceProps) {
     return getItemMetadata('column', props, index, instanceProps).offset;
   },
@@ -1030,17 +1024,13 @@ var devWarningsTagName$1 = null;
 
 if (process.env.NODE_ENV !== 'production') {
   if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {
-    devWarningsDirection =
-    /*#__PURE__*/
-    new WeakSet();
-    devWarningsTagName$1 =
-    /*#__PURE__*/
-    new WeakSet();
+    devWarningsDirection = /*#__PURE__*/new WeakSet();
+    devWarningsTagName$1 = /*#__PURE__*/new WeakSet();
   }
 }
 
 function createListComponent(_ref) {
-  var _class, _temp;
+  var _class;
 
   var getItemOffset = _ref.getItemOffset,
       getEstimatedTotalSize = _ref.getEstimatedTotalSize,
@@ -1051,9 +1041,7 @@ function createListComponent(_ref) {
       initInstanceProps = _ref.initInstanceProps,
       shouldResetStyleCacheOnItemSizeChange = _ref.shouldResetStyleCacheOnItemSizeChange,
       validateProps = _ref.validateProps;
-  return _temp = _class =
-  /*#__PURE__*/
-  function (_PureComponent) {
+  return _class = /*#__PURE__*/function (_PureComponent) {
     _inheritsLoose(List, _PureComponent);
 
     // Always use explicit constructor for React components.
@@ -1063,11 +1051,11 @@ function createListComponent(_ref) {
       var _this;
 
       _this = _PureComponent.call(this, props) || this;
-      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_assertThisInitialized(_this)));
+      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_this));
       _this._outerRef = void 0;
       _this._resetIsScrollingTimeoutId = null;
       _this.state = {
-        instance: _assertThisInitialized(_assertThisInitialized(_this)),
+        instance: _assertThisInitialized(_this),
         isScrolling: false,
         scrollDirection: 'forward',
         scrollOffset: typeof _this.props.initialScrollOffset === 'number' ? _this.props.initialScrollOffset : 0,
@@ -1261,17 +1249,34 @@ function createListComponent(_ref) {
         align = 'auto';
       }
 
-      var itemCount = this.props.itemCount;
+      var _this$props2 = this.props,
+          itemCount = _this$props2.itemCount,
+          layout = _this$props2.layout;
       var scrollOffset = this.state.scrollOffset;
-      index = Math.max(0, Math.min(index, itemCount - 1));
-      this.scrollTo(getOffsetForIndexAndAlignment(this.props, index, align, scrollOffset, this._instanceProps));
+      index = Math.max(0, Math.min(index, itemCount - 1)); // The scrollbar size should be considered when scrolling an item into view, to ensure it's fully visible.
+      // But we only need to account for its size when it's actually visible.
+      // This is an edge case for lists; normally they only scroll in the dominant direction.
+
+      var scrollbarSize = 0;
+
+      if (this._outerRef) {
+        var outerRef = this._outerRef;
+
+        if (layout === 'vertical') {
+          scrollbarSize = outerRef.scrollWidth > outerRef.clientWidth ? getScrollbarSize() : 0;
+        } else {
+          scrollbarSize = outerRef.scrollHeight > outerRef.clientHeight ? getScrollbarSize() : 0;
+        }
+      }
+
+      this.scrollTo(getOffsetForIndexAndAlignment(this.props, index, align, scrollOffset, this._instanceProps, scrollbarSize));
     };
 
     _proto.componentDidMount = function componentDidMount() {
-      var _this$props2 = this.props,
-          direction = _this$props2.direction,
-          initialScrollOffset = _this$props2.initialScrollOffset,
-          layout = _this$props2.layout;
+      var _this$props3 = this.props,
+          direction = _this$props3.direction,
+          initialScrollOffset = _this$props3.initialScrollOffset,
+          layout = _this$props3.layout;
 
       if (typeof initialScrollOffset === 'number' && this._outerRef != null) {
         var outerRef = this._outerRef; // TODO Deprecate direction "horizontal"
@@ -1287,9 +1292,9 @@ function createListComponent(_ref) {
     };
 
     _proto.componentDidUpdate = function componentDidUpdate() {
-      var _this$props3 = this.props,
-          direction = _this$props3.direction,
-          layout = _this$props3.layout;
+      var _this$props4 = this.props,
+          direction = _this$props4.direction,
+          layout = _this$props4.layout;
       var _this$state = this.state,
           scrollOffset = _this$state.scrollOffset,
           scrollUpdateWasRequested = _this$state.scrollUpdateWasRequested;
@@ -1335,24 +1340,24 @@ function createListComponent(_ref) {
     };
 
     _proto.render = function render() {
-      var _this$props4 = this.props,
-          children = _this$props4.children,
-          className = _this$props4.className,
-          direction = _this$props4.direction,
-          height = _this$props4.height,
-          innerRef = _this$props4.innerRef,
-          innerElementType = _this$props4.innerElementType,
-          innerTagName = _this$props4.innerTagName,
-          itemCount = _this$props4.itemCount,
-          itemData = _this$props4.itemData,
-          _this$props4$itemKey = _this$props4.itemKey,
-          itemKey = _this$props4$itemKey === void 0 ? defaultItemKey$1 : _this$props4$itemKey,
-          layout = _this$props4.layout,
-          outerElementType = _this$props4.outerElementType,
-          outerTagName = _this$props4.outerTagName,
-          style = _this$props4.style,
-          useIsScrolling = _this$props4.useIsScrolling,
-          width = _this$props4.width;
+      var _this$props5 = this.props,
+          children = _this$props5.children,
+          className = _this$props5.className,
+          direction = _this$props5.direction,
+          height = _this$props5.height,
+          innerRef = _this$props5.innerRef,
+          innerElementType = _this$props5.innerElementType,
+          innerTagName = _this$props5.innerTagName,
+          itemCount = _this$props5.itemCount,
+          itemData = _this$props5.itemData,
+          _this$props5$itemKey = _this$props5.itemKey,
+          itemKey = _this$props5$itemKey === void 0 ? defaultItemKey$1 : _this$props5$itemKey,
+          layout = _this$props5.layout,
+          outerElementType = _this$props5.outerElementType,
+          outerTagName = _this$props5.outerTagName,
+          style = _this$props5.style,
+          useIsScrolling = _this$props5.useIsScrolling,
+          width = _this$props5.width;
       var isScrolling = this.state.isScrolling; // TODO Deprecate direction "horizontal"
 
       var isHorizontal = direction === 'horizontal' || layout === 'horizontal';
@@ -1426,16 +1431,16 @@ function createListComponent(_ref) {
 
         this._callOnScroll(_scrollDirection, _scrollOffset, _scrollUpdateWasRequested);
       }
-    }; // Lazily create and cache item styles while scrolling,
+    } // Lazily create and cache item styles while scrolling,
     // So that pure component sCU will prevent re-renders.
     // We maintain this cache, and pass a style prop rather than index,
     // So that List can clear cached styles and force item re-render if necessary.
-
+    ;
 
     _proto._getRangeToRender = function _getRangeToRender() {
-      var _this$props5 = this.props,
-          itemCount = _this$props5.itemCount,
-          overscanCount = _this$props5.overscanCount;
+      var _this$props6 = this.props,
+          itemCount = _this$props6.itemCount,
+          overscanCount = _this$props6.overscanCount;
       var _this$state3 = this.state,
           isScrolling = _this$state3.isScrolling,
           scrollDirection = _this$state3.scrollDirection,
@@ -1461,7 +1466,7 @@ function createListComponent(_ref) {
     layout: 'vertical',
     overscanCount: 2,
     useIsScrolling: false
-  }, _temp;
+  }, _class;
 } // NOTE: I considered further wrapping individual items with a pure ListItem component.
 // This would avoid ever calling the render function for the same index more than once,
 // But it would also add the overhead of a lot of components/fibers.
@@ -1632,9 +1637,7 @@ var getEstimatedTotalSize = function getEstimatedTotalSize(_ref2, _ref3) {
   return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;
 };
 
-var VariableSizeList =
-/*#__PURE__*/
-createListComponent({
+var VariableSizeList = /*#__PURE__*/createListComponent({
   getItemOffset: function getItemOffset(props, index, instanceProps) {
     return getItemMetadata$1(props, index, instanceProps).offset;
   },
@@ -1642,7 +1645,7 @@ createListComponent({
     return instanceProps.itemMetadataMap[index].size;
   },
   getEstimatedTotalSize: getEstimatedTotalSize,
-  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(props, index, align, scrollOffset, instanceProps) {
+  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {
     var direction = props.direction,
         height = props.height,
         layout = props.layout,
@@ -1655,7 +1658,7 @@ createListComponent({
 
     var estimatedTotalSize = getEstimatedTotalSize(props, instanceProps);
     var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));
-    var minOffset = Math.max(0, itemMetadata.offset - size + itemMetadata.size);
+    var minOffset = Math.max(0, itemMetadata.offset - size + itemMetadata.size + scrollbarSize);
 
     if (align === 'smart') {
       if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {
@@ -1751,9 +1754,7 @@ createListComponent({
   }
 });
 
-var FixedSizeGrid =
-/*#__PURE__*/
-createGridComponent({
+var FixedSizeGrid = /*#__PURE__*/createGridComponent({
   getColumnOffset: function getColumnOffset(_ref, index) {
     var columnWidth = _ref.columnWidth;
     return index * columnWidth;
@@ -1931,9 +1932,7 @@ createGridComponent({
   }
 });
 
-var FixedSizeList =
-/*#__PURE__*/
-createListComponent({
+var FixedSizeList = /*#__PURE__*/createListComponent({
   getItemOffset: function getItemOffset(_ref, index) {
     var itemSize = _ref.itemSize;
     return index * itemSize;
@@ -1947,7 +1946,7 @@ createListComponent({
         itemSize = _ref3.itemSize;
     return itemSize * itemCount;
   },
-  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(_ref4, index, align, scrollOffset) {
+  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(_ref4, index, align, scrollOffset, instanceProps, scrollbarSize) {
     var direction = _ref4.direction,
         height = _ref4.height,
         itemCount = _ref4.itemCount,
@@ -1959,7 +1958,7 @@ createListComponent({
     var size = isHorizontal ? width : height;
     var lastItemOffset = Math.max(0, itemCount * itemSize - size);
     var maxOffset = Math.min(lastItemOffset, index * itemSize);
-    var minOffset = Math.max(0, index * itemSize - size + itemSize);
+    var minOffset = Math.max(0, index * itemSize - size + itemSize + scrollbarSize);
 
     if (align === 'smart') {
       if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {
@@ -2055,15 +2054,17 @@ function shallowDiffers(prev, next) {
   return false;
 }
 
+var _excluded = ["style"],
+    _excluded2 = ["style"];
 // It knows to compare individual style props and ignore the wrapper object.
 // See https://reactjs.org/docs/react-api.html#reactmemo
 
 function areEqual(prevProps, nextProps) {
   var prevStyle = prevProps.style,
-      prevRest = _objectWithoutPropertiesLoose(prevProps, ["style"]);
+      prevRest = _objectWithoutPropertiesLoose(prevProps, _excluded);
 
   var nextStyle = nextProps.style,
-      nextRest = _objectWithoutPropertiesLoose(nextProps, ["style"]);
+      nextRest = _objectWithoutPropertiesLoose(nextProps, _excluded2);
 
   return !shallowDiffers(prevStyle, nextStyle) && !shallowDiffers(prevRest, nextRest);
 }
@@ -2075,5 +2076,5 @@ function shouldComponentUpdate(nextProps, nextState) {
   return !areEqual(this.props, nextProps) || shallowDiffers(this.state, nextState);
 }
 
-export { VariableSizeGrid, VariableSizeList, FixedSizeGrid, FixedSizeList, areEqual, shouldComponentUpdate };
+export { FixedSizeGrid, FixedSizeList, VariableSizeGrid, VariableSizeList, areEqual, shouldComponentUpdate };
 //# sourceMappingURL=index.esm.js.map
diff --git a/node_modules/react-window/dist/index.esm.js.map b/node_modules/react-window/dist/index.esm.js.map
index 038d31f..d43e1a7 100644
--- a/node_modules/react-window/dist/index.esm.js.map
+++ b/node_modules/react-window/dist/index.esm.js.map
@@ -1 +1 @@
-{"version":3,"file":"index.esm.js","sources":["../src/timer.js","../src/domHelpers.js","../src/createGridComponent.js","../src/VariableSizeGrid.js","../src/createListComponent.js","../src/VariableSizeList.js","../src/FixedSizeGrid.js","../src/FixedSizeList.js","../src/shallowDiffers.js","../src/areEqual.js","../src/shouldComponentUpdate.js"],"sourcesContent":["// @flow\n\n// Animation frame based implementation of setTimeout.\n// Inspired by Joe Lambert, https://gist.github.com/joelambert/1002116#file-requesttimeout-js\n\nconst hasNativePerformanceNow =\n  typeof performance === 'object' && typeof performance.now === 'function';\n\nconst now = hasNativePerformanceNow\n  ? () => performance.now()\n  : () => Date.now();\n\nexport type TimeoutID = {|\n  id: AnimationFrameID,\n|};\n\nexport function cancelTimeout(timeoutID: TimeoutID) {\n  cancelAnimationFrame(timeoutID.id);\n}\n\nexport function requestTimeout(callback: Function, delay: number): TimeoutID {\n  const start = now();\n\n  function tick() {\n    if (now() - start >= delay) {\n      callback.call(null);\n    } else {\n      timeoutID.id = requestAnimationFrame(tick);\n    }\n  }\n\n  const timeoutID: TimeoutID = {\n    id: requestAnimationFrame(tick),\n  };\n\n  return timeoutID;\n}\n","// @flow\n\nlet size: number = -1;\n\n// This utility copied from \"dom-helpers\" package.\nexport function getScrollbarSize(recalculate?: boolean = false): number {\n  if (size === -1 || recalculate) {\n    const div = document.createElement('div');\n    const style = div.style;\n    style.width = '50px';\n    style.height = '50px';\n    style.overflow = 'scroll';\n\n    ((document.body: any): HTMLBodyElement).appendChild(div);\n\n    size = div.offsetWidth - div.clientWidth;\n\n    ((document.body: any): HTMLBodyElement).removeChild(div);\n  }\n\n  return size;\n}\n\nexport type RTLOffsetType =\n  | 'negative'\n  | 'positive-descending'\n  | 'positive-ascending';\n\nlet cachedRTLResult: RTLOffsetType | null = null;\n\n// TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n// Chrome does not seem to adhere; its scrollLeft values are positive (measured relative to the left).\n// Safari's elastic bounce makes detecting this even more complicated wrt potential false positives.\n// The safest way to check this is to intentionally set a negative offset,\n// and then verify that the subsequent \"scroll\" event matches the negative offset.\n// If it does not match, then we can assume a non-standard RTL scroll implementation.\nexport function getRTLOffsetType(recalculate?: boolean = false): RTLOffsetType {\n  if (cachedRTLResult === null || recalculate) {\n    const outerDiv = document.createElement('div');\n    const outerStyle = outerDiv.style;\n    outerStyle.width = '50px';\n    outerStyle.height = '50px';\n    outerStyle.overflow = 'scroll';\n    outerStyle.direction = 'rtl';\n\n    const innerDiv = document.createElement('div');\n    const innerStyle = innerDiv.style;\n    innerStyle.width = '100px';\n    innerStyle.height = '100px';\n\n    outerDiv.appendChild(innerDiv);\n\n    ((document.body: any): HTMLBodyElement).appendChild(outerDiv);\n\n    if (outerDiv.scrollLeft > 0) {\n      cachedRTLResult = 'positive-descending';\n    } else {\n      outerDiv.scrollLeft = 1;\n      if (outerDiv.scrollLeft === 0) {\n        cachedRTLResult = 'negative';\n      } else {\n        cachedRTLResult = 'positive-ascending';\n      }\n    }\n\n    ((document.body: any): HTMLBodyElement).removeChild(outerDiv);\n\n    return cachedRTLResult;\n  }\n\n  return cachedRTLResult;\n}\n","// @flow\n\nimport memoizeOne from 'memoize-one';\nimport { createElement, PureComponent } from 'react';\nimport { cancelTimeout, requestTimeout } from './timer';\nimport { getScrollbarSize, getRTLOffsetType } from './domHelpers';\n\nimport type { TimeoutID } from './timer';\n\ntype Direction = 'ltr' | 'rtl';\nexport type ScrollToAlign = 'auto' | 'smart' | 'center' | 'start' | 'end';\n\ntype itemSize = number | ((index: number) => number);\n\ntype RenderComponentProps<T> = {|\n  columnIndex: number,\n  data: T,\n  isScrolling?: boolean,\n  rowIndex: number,\n  style: Object,\n|};\nexport type RenderComponent<T> = React$ComponentType<\n  $Shape<RenderComponentProps<T>>\n>;\n\ntype ScrollDirection = 'forward' | 'backward';\n\ntype OnItemsRenderedCallback = ({\n  overscanColumnStartIndex: number,\n  overscanColumnStopIndex: number,\n  overscanRowStartIndex: number,\n  overscanRowStopIndex: number,\n  visibleColumnStartIndex: number,\n  visibleColumnStopIndex: number,\n  visibleRowStartIndex: number,\n  visibleRowStopIndex: number,\n}) => void;\ntype OnScrollCallback = ({\n  horizontalScrollDirection: ScrollDirection,\n  scrollLeft: number,\n  scrollTop: number,\n  scrollUpdateWasRequested: boolean,\n  verticalScrollDirection: ScrollDirection,\n}) => void;\n\ntype ScrollEvent = SyntheticEvent<HTMLDivElement>;\ntype ItemStyleCache = { [key: string]: Object };\n\ntype OuterProps = {|\n  children: React$Node,\n  className: string | void,\n  onScroll: ScrollEvent => void,\n  style: {\n    [string]: mixed,\n  },\n|};\n\ntype InnerProps = {|\n  children: React$Node,\n  style: {\n    [string]: mixed,\n  },\n|};\n\nexport type Props<T> = {|\n  children: RenderComponent<T>,\n  className?: string,\n  columnCount: number,\n  columnWidth: itemSize,\n  direction: Direction,\n  height: number,\n  initialScrollLeft?: number,\n  initialScrollTop?: number,\n  innerRef?: any,\n  innerElementType?: string | React$AbstractComponent<InnerProps, any>,\n  innerTagName?: string, // deprecated\n  itemData: T,\n  itemKey?: (params: {|\n    columnIndex: number,\n    data: T,\n    rowIndex: number,\n  |}) => any,\n  onItemsRendered?: OnItemsRenderedCallback,\n  onScroll?: OnScrollCallback,\n  outerRef?: any,\n  outerElementType?: string | React$AbstractComponent<OuterProps, any>,\n  outerTagName?: string, // deprecated\n  overscanColumnCount?: number,\n  overscanColumnsCount?: number, // deprecated\n  overscanCount?: number, // deprecated\n  overscanRowCount?: number,\n  overscanRowsCount?: number, // deprecated\n  rowCount: number,\n  rowHeight: itemSize,\n  style?: Object,\n  useIsScrolling: boolean,\n  width: number,\n|};\n\ntype State = {|\n  instance: any,\n  isScrolling: boolean,\n  horizontalScrollDirection: ScrollDirection,\n  scrollLeft: number,\n  scrollTop: number,\n  scrollUpdateWasRequested: boolean,\n  verticalScrollDirection: ScrollDirection,\n|};\n\ntype getItemOffset = (\n  props: Props<any>,\n  index: number,\n  instanceProps: any\n) => number;\ntype getItemSize = (\n  props: Props<any>,\n  index: number,\n  instanceProps: any\n) => number;\ntype getEstimatedTotalSize = (props: Props<any>, instanceProps: any) => number;\ntype GetOffsetForItemAndAlignment = (\n  props: Props<any>,\n  index: number,\n  align: ScrollToAlign,\n  scrollOffset: number,\n  instanceProps: any,\n  scrollbarSize: number\n) => number;\ntype GetStartIndexForOffset = (\n  props: Props<any>,\n  offset: number,\n  instanceProps: any\n) => number;\ntype GetStopIndexForStartIndex = (\n  props: Props<any>,\n  startIndex: number,\n  scrollOffset: number,\n  instanceProps: any\n) => number;\ntype InitInstanceProps = (props: Props<any>, instance: any) => any;\ntype ValidateProps = (props: Props<any>) => void;\n\nconst IS_SCROLLING_DEBOUNCE_INTERVAL = 150;\n\nconst defaultItemKey = ({ columnIndex, data, rowIndex }) =>\n  `${rowIndex}:${columnIndex}`;\n\n// In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\nlet devWarningsOverscanCount = null;\nlet devWarningsOverscanRowsColumnsCount = null;\nlet devWarningsTagName = null;\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsOverscanCount = new WeakSet();\n    devWarningsOverscanRowsColumnsCount = new WeakSet();\n    devWarningsTagName = new WeakSet();\n  }\n}\n\nexport default function createGridComponent({\n  getColumnOffset,\n  getColumnStartIndexForOffset,\n  getColumnStopIndexForStartIndex,\n  getColumnWidth,\n  getEstimatedTotalHeight,\n  getEstimatedTotalWidth,\n  getOffsetForColumnAndAlignment,\n  getOffsetForRowAndAlignment,\n  getRowHeight,\n  getRowOffset,\n  getRowStartIndexForOffset,\n  getRowStopIndexForStartIndex,\n  initInstanceProps,\n  shouldResetStyleCacheOnItemSizeChange,\n  validateProps,\n}: {|\n  getColumnOffset: getItemOffset,\n  getColumnStartIndexForOffset: GetStartIndexForOffset,\n  getColumnStopIndexForStartIndex: GetStopIndexForStartIndex,\n  getColumnWidth: getItemSize,\n  getEstimatedTotalHeight: getEstimatedTotalSize,\n  getEstimatedTotalWidth: getEstimatedTotalSize,\n  getOffsetForColumnAndAlignment: GetOffsetForItemAndAlignment,\n  getOffsetForRowAndAlignment: GetOffsetForItemAndAlignment,\n  getRowOffset: getItemOffset,\n  getRowHeight: getItemSize,\n  getRowStartIndexForOffset: GetStartIndexForOffset,\n  getRowStopIndexForStartIndex: GetStopIndexForStartIndex,\n  initInstanceProps: InitInstanceProps,\n  shouldResetStyleCacheOnItemSizeChange: boolean,\n  validateProps: ValidateProps,\n|}) {\n  return class Grid<T> extends PureComponent<Props<T>, State> {\n    _instanceProps: any = initInstanceProps(this.props, this);\n    _resetIsScrollingTimeoutId: TimeoutID | null = null;\n    _outerRef: ?HTMLDivElement;\n\n    static defaultProps = {\n      direction: 'ltr',\n      itemData: undefined,\n      useIsScrolling: false,\n    };\n\n    state: State = {\n      instance: this,\n      isScrolling: false,\n      horizontalScrollDirection: 'forward',\n      scrollLeft:\n        typeof this.props.initialScrollLeft === 'number'\n          ? this.props.initialScrollLeft\n          : 0,\n      scrollTop:\n        typeof this.props.initialScrollTop === 'number'\n          ? this.props.initialScrollTop\n          : 0,\n      scrollUpdateWasRequested: false,\n      verticalScrollDirection: 'forward',\n    };\n\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    constructor(props: Props<T>) {\n      super(props);\n    }\n\n    static getDerivedStateFromProps(\n      nextProps: Props<T>,\n      prevState: State\n    ): $Shape<State> | null {\n      validateSharedProps(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    }\n\n    scrollTo({\n      scrollLeft,\n      scrollTop,\n    }: {\n      scrollLeft: number,\n      scrollTop: number,\n    }): void {\n      if (scrollLeft !== undefined) {\n        scrollLeft = Math.max(0, scrollLeft);\n      }\n      if (scrollTop !== undefined) {\n        scrollTop = Math.max(0, scrollTop);\n      }\n\n      this.setState(prevState => {\n        if (scrollLeft === undefined) {\n          scrollLeft = prevState.scrollLeft;\n        }\n        if (scrollTop === undefined) {\n          scrollTop = prevState.scrollTop;\n        }\n\n        if (\n          prevState.scrollLeft === scrollLeft &&\n          prevState.scrollTop === scrollTop\n        ) {\n          return null;\n        }\n\n        return {\n          horizontalScrollDirection:\n            prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          scrollUpdateWasRequested: true,\n          verticalScrollDirection:\n            prevState.scrollTop < scrollTop ? 'forward' : 'backward',\n        };\n      }, this._resetIsScrollingDebounced);\n    }\n\n    scrollToItem({\n      align = 'auto',\n      columnIndex,\n      rowIndex,\n    }: {\n      align: ScrollToAlign,\n      columnIndex?: number,\n      rowIndex?: number,\n    }): void {\n      const { columnCount, height, rowCount, width } = this.props;\n      const { scrollLeft, scrollTop } = this.state;\n      const scrollbarSize = getScrollbarSize();\n\n      if (columnIndex !== undefined) {\n        columnIndex = Math.max(0, Math.min(columnIndex, columnCount - 1));\n      }\n      if (rowIndex !== undefined) {\n        rowIndex = Math.max(0, Math.min(rowIndex, rowCount - 1));\n      }\n\n      const estimatedTotalHeight = getEstimatedTotalHeight(\n        this.props,\n        this._instanceProps\n      );\n      const estimatedTotalWidth = getEstimatedTotalWidth(\n        this.props,\n        this._instanceProps\n      );\n\n      // The scrollbar size should be considered when scrolling an item into view,\n      // to ensure it's fully visible.\n      // But we only need to account for its size when it's actually visible.\n      const horizontalScrollbarSize =\n        estimatedTotalWidth > width ? scrollbarSize : 0;\n      const verticalScrollbarSize =\n        estimatedTotalHeight > height ? scrollbarSize : 0;\n\n      this.scrollTo({\n        scrollLeft:\n          columnIndex !== undefined\n            ? getOffsetForColumnAndAlignment(\n                this.props,\n                columnIndex,\n                align,\n                scrollLeft,\n                this._instanceProps,\n                verticalScrollbarSize\n              )\n            : scrollLeft,\n        scrollTop:\n          rowIndex !== undefined\n            ? getOffsetForRowAndAlignment(\n                this.props,\n                rowIndex,\n                align,\n                scrollTop,\n                this._instanceProps,\n                horizontalScrollbarSize\n              )\n            : scrollTop,\n      });\n    }\n\n    componentDidMount() {\n      const { initialScrollLeft, initialScrollTop } = this.props;\n\n      if (this._outerRef != null) {\n        const outerRef = ((this._outerRef: any): HTMLElement);\n        if (typeof initialScrollLeft === 'number') {\n          outerRef.scrollLeft = initialScrollLeft;\n        }\n        if (typeof initialScrollTop === 'number') {\n          outerRef.scrollTop = initialScrollTop;\n        }\n      }\n\n      this._callPropsCallbacks();\n    }\n\n    componentDidUpdate() {\n      const { direction } = this.props;\n      const { scrollLeft, scrollTop, scrollUpdateWasRequested } = this.state;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n        // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n        // So we need to determine which browser behavior we're dealing with, and mimic it.\n        const outerRef = ((this._outerRef: any): HTMLElement);\n        if (direction === 'rtl') {\n          switch (getRTLOffsetType()) {\n            case 'negative':\n              outerRef.scrollLeft = -scrollLeft;\n              break;\n            case 'positive-ascending':\n              outerRef.scrollLeft = scrollLeft;\n              break;\n            default:\n              const { clientWidth, scrollWidth } = outerRef;\n              outerRef.scrollLeft = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        } else {\n          outerRef.scrollLeft = Math.max(0, scrollLeft);\n        }\n\n        outerRef.scrollTop = Math.max(0, scrollTop);\n      }\n\n      this._callPropsCallbacks();\n    }\n\n    componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    }\n\n    render() {\n      const {\n        children,\n        className,\n        columnCount,\n        direction,\n        height,\n        innerRef,\n        innerElementType,\n        innerTagName,\n        itemData,\n        itemKey = defaultItemKey,\n        outerElementType,\n        outerTagName,\n        rowCount,\n        style,\n        useIsScrolling,\n        width,\n      } = this.props;\n      const { isScrolling } = this.state;\n\n      const [\n        columnStartIndex,\n        columnStopIndex,\n      ] = this._getHorizontalRangeToRender();\n      const [rowStartIndex, rowStopIndex] = this._getVerticalRangeToRender();\n\n      const items = [];\n      if (columnCount > 0 && rowCount) {\n        for (\n          let rowIndex = rowStartIndex;\n          rowIndex <= rowStopIndex;\n          rowIndex++\n        ) {\n          for (\n            let columnIndex = columnStartIndex;\n            columnIndex <= columnStopIndex;\n            columnIndex++\n          ) {\n            items.push(\n              createElement(children, {\n                columnIndex,\n                data: itemData,\n                isScrolling: useIsScrolling ? isScrolling : undefined,\n                key: itemKey({ columnIndex, data: itemData, rowIndex }),\n                rowIndex,\n                style: this._getItemStyle(rowIndex, columnIndex),\n              })\n            );\n          }\n        }\n      }\n\n      // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n      const estimatedTotalHeight = getEstimatedTotalHeight(\n        this.props,\n        this._instanceProps\n      );\n      const estimatedTotalWidth = getEstimatedTotalWidth(\n        this.props,\n        this._instanceProps\n      );\n\n      return createElement(\n        outerElementType || outerTagName || 'div',\n        {\n          className,\n          onScroll: this._onScroll,\n          ref: this._outerRefSetter,\n          style: {\n            position: 'relative',\n            height,\n            width,\n            overflow: 'auto',\n            WebkitOverflowScrolling: 'touch',\n            willChange: 'transform',\n            direction,\n            ...style,\n          },\n        },\n        createElement(innerElementType || innerTagName || 'div', {\n          children: items,\n          ref: innerRef,\n          style: {\n            height: estimatedTotalHeight,\n            pointerEvents: isScrolling ? 'none' : undefined,\n            width: estimatedTotalWidth,\n          },\n        })\n      );\n    }\n\n    _callOnItemsRendered: (\n      overscanColumnStartIndex: number,\n      overscanColumnStopIndex: number,\n      overscanRowStartIndex: number,\n      overscanRowStopIndex: number,\n      visibleColumnStartIndex: number,\n      visibleColumnStopIndex: number,\n      visibleRowStartIndex: number,\n      visibleRowStopIndex: number\n    ) => void;\n    _callOnItemsRendered = memoizeOne(\n      (\n        overscanColumnStartIndex: number,\n        overscanColumnStopIndex: number,\n        overscanRowStartIndex: number,\n        overscanRowStopIndex: number,\n        visibleColumnStartIndex: number,\n        visibleColumnStopIndex: number,\n        visibleRowStartIndex: number,\n        visibleRowStopIndex: number\n      ) =>\n        ((this.props.onItemsRendered: any): OnItemsRenderedCallback)({\n          overscanColumnStartIndex,\n          overscanColumnStopIndex,\n          overscanRowStartIndex,\n          overscanRowStopIndex,\n          visibleColumnStartIndex,\n          visibleColumnStopIndex,\n          visibleRowStartIndex,\n          visibleRowStopIndex,\n        })\n    );\n\n    _callOnScroll: (\n      scrollLeft: number,\n      scrollTop: number,\n      horizontalScrollDirection: ScrollDirection,\n      verticalScrollDirection: ScrollDirection,\n      scrollUpdateWasRequested: boolean\n    ) => void;\n    _callOnScroll = memoizeOne(\n      (\n        scrollLeft: number,\n        scrollTop: number,\n        horizontalScrollDirection: ScrollDirection,\n        verticalScrollDirection: ScrollDirection,\n        scrollUpdateWasRequested: boolean\n      ) =>\n        ((this.props.onScroll: any): OnScrollCallback)({\n          horizontalScrollDirection,\n          scrollLeft,\n          scrollTop,\n          verticalScrollDirection,\n          scrollUpdateWasRequested,\n        })\n    );\n\n    _callPropsCallbacks() {\n      const { columnCount, onItemsRendered, onScroll, rowCount } = this.props;\n\n      if (typeof onItemsRendered === 'function') {\n        if (columnCount > 0 && rowCount > 0) {\n          const [\n            overscanColumnStartIndex,\n            overscanColumnStopIndex,\n            visibleColumnStartIndex,\n            visibleColumnStopIndex,\n          ] = this._getHorizontalRangeToRender();\n          const [\n            overscanRowStartIndex,\n            overscanRowStopIndex,\n            visibleRowStartIndex,\n            visibleRowStopIndex,\n          ] = this._getVerticalRangeToRender();\n          this._callOnItemsRendered(\n            overscanColumnStartIndex,\n            overscanColumnStopIndex,\n            overscanRowStartIndex,\n            overscanRowStopIndex,\n            visibleColumnStartIndex,\n            visibleColumnStopIndex,\n            visibleRowStartIndex,\n            visibleRowStopIndex\n          );\n        }\n      }\n\n      if (typeof onScroll === 'function') {\n        const {\n          horizontalScrollDirection,\n          scrollLeft,\n          scrollTop,\n          scrollUpdateWasRequested,\n          verticalScrollDirection,\n        } = this.state;\n        this._callOnScroll(\n          scrollLeft,\n          scrollTop,\n          horizontalScrollDirection,\n          verticalScrollDirection,\n          scrollUpdateWasRequested\n        );\n      }\n    }\n\n    // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n    _getItemStyle: (rowIndex: number, columnIndex: number) => Object;\n    _getItemStyle = (rowIndex: number, columnIndex: number): Object => {\n      const { columnWidth, direction, rowHeight } = this.props;\n\n      const itemStyleCache = this._getItemStyleCache(\n        shouldResetStyleCacheOnItemSizeChange && columnWidth,\n        shouldResetStyleCacheOnItemSizeChange && direction,\n        shouldResetStyleCacheOnItemSizeChange && rowHeight\n      );\n\n      const key = `${rowIndex}:${columnIndex}`;\n\n      let style;\n      if (itemStyleCache.hasOwnProperty(key)) {\n        style = itemStyleCache[key];\n      } else {\n        const offset = getColumnOffset(\n          this.props,\n          columnIndex,\n          this._instanceProps\n        );\n        const isRtl = direction === 'rtl';\n        itemStyleCache[key] = style = {\n          position: 'absolute',\n          left: isRtl ? undefined : offset,\n          right: isRtl ? offset : undefined,\n          top: getRowOffset(this.props, rowIndex, this._instanceProps),\n          height: getRowHeight(this.props, rowIndex, this._instanceProps),\n          width: getColumnWidth(this.props, columnIndex, this._instanceProps),\n        };\n      }\n\n      return style;\n    };\n\n    _getItemStyleCache: (_: any, __: any, ___: any) => ItemStyleCache;\n    _getItemStyleCache = memoizeOne((_: any, __: any, ___: any) => ({}));\n\n    _getHorizontalRangeToRender(): [number, number, number, number] {\n      const {\n        columnCount,\n        overscanColumnCount,\n        overscanColumnsCount,\n        overscanCount,\n        rowCount,\n      } = this.props;\n      const { horizontalScrollDirection, isScrolling, scrollLeft } = this.state;\n\n      const overscanCountResolved: number =\n        overscanColumnCount || overscanColumnsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      const startIndex = getColumnStartIndexForOffset(\n        this.props,\n        scrollLeft,\n        this._instanceProps\n      );\n      const stopIndex = getColumnStopIndexForStartIndex(\n        this.props,\n        startIndex,\n        scrollLeft,\n        this._instanceProps\n      );\n\n      // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n      const overscanBackward =\n        !isScrolling || horizontalScrollDirection === 'backward'\n          ? Math.max(1, overscanCountResolved)\n          : 1;\n      const overscanForward =\n        !isScrolling || horizontalScrollDirection === 'forward'\n          ? Math.max(1, overscanCountResolved)\n          : 1;\n\n      return [\n        Math.max(0, startIndex - overscanBackward),\n        Math.max(0, Math.min(columnCount - 1, stopIndex + overscanForward)),\n        startIndex,\n        stopIndex,\n      ];\n    }\n\n    _getVerticalRangeToRender(): [number, number, number, number] {\n      const {\n        columnCount,\n        overscanCount,\n        overscanRowCount,\n        overscanRowsCount,\n        rowCount,\n      } = this.props;\n      const { isScrolling, verticalScrollDirection, scrollTop } = this.state;\n\n      const overscanCountResolved: number =\n        overscanRowCount || overscanRowsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      const startIndex = getRowStartIndexForOffset(\n        this.props,\n        scrollTop,\n        this._instanceProps\n      );\n      const stopIndex = getRowStopIndexForStartIndex(\n        this.props,\n        startIndex,\n        scrollTop,\n        this._instanceProps\n      );\n\n      // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n      const overscanBackward =\n        !isScrolling || verticalScrollDirection === 'backward'\n          ? Math.max(1, overscanCountResolved)\n          : 1;\n      const overscanForward =\n        !isScrolling || verticalScrollDirection === 'forward'\n          ? Math.max(1, overscanCountResolved)\n          : 1;\n\n      return [\n        Math.max(0, startIndex - overscanBackward),\n        Math.max(0, Math.min(rowCount - 1, stopIndex + overscanForward)),\n        startIndex,\n        stopIndex,\n      ];\n    }\n\n    _onScroll = (event: ScrollEvent): void => {\n      const {\n        clientHeight,\n        clientWidth,\n        scrollLeft,\n        scrollTop,\n        scrollHeight,\n        scrollWidth,\n      } = event.currentTarget;\n      this.setState(prevState => {\n        if (\n          prevState.scrollLeft === scrollLeft &&\n          prevState.scrollTop === scrollTop\n        ) {\n          // Scroll position may have been updated by cDM/cDU,\n          // In which case we don't need to trigger another render,\n          // And we don't want to update state.isScrolling.\n          return null;\n        }\n\n        const { direction } = this.props;\n\n        // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n        // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n        // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n        // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n        let calculatedScrollLeft = scrollLeft;\n        if (direction === 'rtl') {\n          switch (getRTLOffsetType()) {\n            case 'negative':\n              calculatedScrollLeft = -scrollLeft;\n              break;\n            case 'positive-descending':\n              calculatedScrollLeft = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        }\n\n        // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n        calculatedScrollLeft = Math.max(\n          0,\n          Math.min(calculatedScrollLeft, scrollWidth - clientWidth)\n        );\n        const calculatedScrollTop = Math.max(\n          0,\n          Math.min(scrollTop, scrollHeight - clientHeight)\n        );\n\n        return {\n          isScrolling: true,\n          horizontalScrollDirection:\n            prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n          scrollLeft: calculatedScrollLeft,\n          scrollTop: calculatedScrollTop,\n          verticalScrollDirection:\n            prevState.scrollTop < scrollTop ? 'forward' : 'backward',\n          scrollUpdateWasRequested: false,\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _outerRefSetter = (ref: any): void => {\n      const { outerRef } = this.props;\n\n      this._outerRef = ((ref: any): HTMLDivElement);\n\n      if (typeof outerRef === 'function') {\n        outerRef(ref);\n      } else if (\n        outerRef != null &&\n        typeof outerRef === 'object' &&\n        outerRef.hasOwnProperty('current')\n      ) {\n        outerRef.current = ref;\n      }\n    };\n\n    _resetIsScrollingDebounced = () => {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n\n      this._resetIsScrollingTimeoutId = requestTimeout(\n        this._resetIsScrolling,\n        IS_SCROLLING_DEBOUNCE_INTERVAL\n      );\n    };\n\n    _resetIsScrolling = () => {\n      this._resetIsScrollingTimeoutId = null;\n\n      this.setState({ isScrolling: false }, () => {\n        // Clear style cache after state update has been committed.\n        // This way we don't break pure sCU for items that don't use isScrolling param.\n        this._getItemStyleCache(-1);\n      });\n    };\n  };\n}\n\nconst validateSharedProps = (\n  {\n    children,\n    direction,\n    height,\n    innerTagName,\n    outerTagName,\n    overscanColumnsCount,\n    overscanCount,\n    overscanRowsCount,\n    width,\n  }: Props<any>,\n  { instance }: State\n): void => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof overscanCount === 'number') {\n      if (devWarningsOverscanCount && !devWarningsOverscanCount.has(instance)) {\n        devWarningsOverscanCount.add(instance);\n        console.warn(\n          'The overscanCount prop has been deprecated. ' +\n            'Please use the overscanColumnCount and overscanRowCount props instead.'\n        );\n      }\n    }\n\n    if (\n      typeof overscanColumnsCount === 'number' ||\n      typeof overscanRowsCount === 'number'\n    ) {\n      if (\n        devWarningsOverscanRowsColumnsCount &&\n        !devWarningsOverscanRowsColumnsCount.has(instance)\n      ) {\n        devWarningsOverscanRowsColumnsCount.add(instance);\n        console.warn(\n          'The overscanColumnsCount and overscanRowsCount props have been deprecated. ' +\n            'Please use the overscanColumnCount and overscanRowCount props instead.'\n        );\n      }\n    }\n\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName && !devWarningsTagName.has(instance)) {\n        devWarningsTagName.add(instance);\n        console.warn(\n          'The innerTagName and outerTagName props have been deprecated. ' +\n            'Please use the innerElementType and outerElementType props instead.'\n        );\n      }\n    }\n\n    if (children == null) {\n      throw Error(\n        'An invalid \"children\" prop has been specified. ' +\n          'Value should be a React component. ' +\n          `\"${children === null ? 'null' : typeof children}\" was specified.`\n      );\n    }\n\n    switch (direction) {\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n      default:\n        throw Error(\n          'An invalid \"direction\" prop has been specified. ' +\n            'Value should be either \"ltr\" or \"rtl\". ' +\n            `\"${direction}\" was specified.`\n        );\n    }\n\n    if (typeof width !== 'number') {\n      throw Error(\n        'An invalid \"width\" prop has been specified. ' +\n          'Grids must specify a number for width. ' +\n          `\"${width === null ? 'null' : typeof width}\" was specified.`\n      );\n    }\n\n    if (typeof height !== 'number') {\n      throw Error(\n        'An invalid \"height\" prop has been specified. ' +\n          'Grids must specify a number for height. ' +\n          `\"${height === null ? 'null' : typeof height}\" was specified.`\n      );\n    }\n  }\n};\n","// @flow\n\nimport createGridComponent from './createGridComponent';\n\nimport type { Props, ScrollToAlign } from './createGridComponent';\n\nconst DEFAULT_ESTIMATED_ITEM_SIZE = 50;\n\ntype VariableSizeProps = {|\n  estimatedColumnWidth: number,\n  estimatedRowHeight: number,\n  ...Props<any>,\n|};\n\ntype itemSizeGetter = (index: number) => number;\ntype ItemType = 'column' | 'row';\n\ntype ItemMetadata = {|\n  offset: number,\n  size: number,\n|};\ntype ItemMetadataMap = { [index: number]: ItemMetadata };\ntype InstanceProps = {|\n  columnMetadataMap: ItemMetadataMap,\n  estimatedColumnWidth: number,\n  estimatedRowHeight: number,\n  lastMeasuredColumnIndex: number,\n  lastMeasuredRowIndex: number,\n  rowMetadataMap: ItemMetadataMap,\n|};\n\nconst getEstimatedTotalHeight = (\n  { rowCount }: Props<any>,\n  { rowMetadataMap, estimatedRowHeight, lastMeasuredRowIndex }: InstanceProps\n) => {\n  let totalSizeOfMeasuredRows = 0;\n\n  // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n  if (lastMeasuredRowIndex >= rowCount) {\n    lastMeasuredRowIndex = rowCount - 1;\n  }\n\n  if (lastMeasuredRowIndex >= 0) {\n    const itemMetadata = rowMetadataMap[lastMeasuredRowIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  const numUnmeasuredItems = rowCount - lastMeasuredRowIndex - 1;\n  const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedRowHeight;\n\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nconst getEstimatedTotalWidth = (\n  { columnCount }: Props<any>,\n  {\n    columnMetadataMap,\n    estimatedColumnWidth,\n    lastMeasuredColumnIndex,\n  }: InstanceProps\n) => {\n  let totalSizeOfMeasuredRows = 0;\n\n  // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n  if (lastMeasuredColumnIndex >= columnCount) {\n    lastMeasuredColumnIndex = columnCount - 1;\n  }\n\n  if (lastMeasuredColumnIndex >= 0) {\n    const itemMetadata = columnMetadataMap[lastMeasuredColumnIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  const numUnmeasuredItems = columnCount - lastMeasuredColumnIndex - 1;\n  const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedColumnWidth;\n\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nconst getItemMetadata = (\n  itemType: ItemType,\n  props: Props<any>,\n  index: number,\n  instanceProps: InstanceProps\n): ItemMetadata => {\n  let itemMetadataMap, itemSize, lastMeasuredIndex;\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    itemSize = ((props.columnWidth: any): itemSizeGetter);\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    itemSize = ((props.rowHeight: any): itemSizeGetter);\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  if (index > lastMeasuredIndex) {\n    let offset = 0;\n    if (lastMeasuredIndex >= 0) {\n      const itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (let i = lastMeasuredIndex + 1; i <= index; i++) {\n      let size = itemSize(i);\n\n      itemMetadataMap[i] = {\n        offset,\n        size,\n      };\n\n      offset += size;\n    }\n\n    if (itemType === 'column') {\n      instanceProps.lastMeasuredColumnIndex = index;\n    } else {\n      instanceProps.lastMeasuredRowIndex = index;\n    }\n  }\n\n  return itemMetadataMap[index];\n};\n\nconst findNearestItem = (\n  itemType: ItemType,\n  props: Props<any>,\n  instanceProps: InstanceProps,\n  offset: number\n) => {\n  let itemMetadataMap, lastMeasuredIndex;\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  const lastMeasuredItemOffset =\n    lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch(\n      itemType,\n      props,\n      instanceProps,\n      lastMeasuredIndex,\n      0,\n      offset\n    );\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch(\n      itemType,\n      props,\n      instanceProps,\n      Math.max(0, lastMeasuredIndex),\n      offset\n    );\n  }\n};\n\nconst findNearestItemBinarySearch = (\n  itemType: ItemType,\n  props: Props<any>,\n  instanceProps: InstanceProps,\n  high: number,\n  low: number,\n  offset: number\n): number => {\n  while (low <= high) {\n    const middle = low + Math.floor((high - low) / 2);\n    const currentOffset = getItemMetadata(\n      itemType,\n      props,\n      middle,\n      instanceProps\n    ).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nconst findNearestItemExponentialSearch = (\n  itemType: ItemType,\n  props: Props<any>,\n  instanceProps: InstanceProps,\n  index: number,\n  offset: number\n): number => {\n  const itemCount = itemType === 'column' ? props.columnCount : props.rowCount;\n  let interval = 1;\n\n  while (\n    index < itemCount &&\n    getItemMetadata(itemType, props, index, instanceProps).offset < offset\n  ) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch(\n    itemType,\n    props,\n    instanceProps,\n    Math.min(index, itemCount - 1),\n    Math.floor(index / 2),\n    offset\n  );\n};\n\nconst getOffsetForIndexAndAlignment = (\n  itemType: ItemType,\n  props: Props<any>,\n  index: number,\n  align: ScrollToAlign,\n  scrollOffset: number,\n  instanceProps: InstanceProps,\n  scrollbarSize: number\n): number => {\n  const size = itemType === 'column' ? props.width : props.height;\n  const itemMetadata = getItemMetadata(itemType, props, index, instanceProps);\n\n  // Get estimated total size after ItemMetadata is computed,\n  // To ensure it reflects actual measurements instead of just estimates.\n  const estimatedTotalSize =\n    itemType === 'column'\n      ? getEstimatedTotalWidth(props, instanceProps)\n      : getEstimatedTotalHeight(props, instanceProps);\n\n  const maxOffset = Math.max(\n    0,\n    Math.min(estimatedTotalSize - size, itemMetadata.offset)\n  );\n  const minOffset = Math.max(\n    0,\n    itemMetadata.offset - size + scrollbarSize + itemMetadata.size\n  );\n\n  if (align === 'smart') {\n    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n      align = 'auto';\n    } else {\n      align = 'center';\n    }\n  }\n\n  switch (align) {\n    case 'start':\n      return maxOffset;\n    case 'end':\n      return minOffset;\n    case 'center':\n      return Math.round(minOffset + (maxOffset - minOffset) / 2);\n    case 'auto':\n    default:\n      if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n        return scrollOffset;\n      } else if (minOffset > maxOffset) {\n        // Because we only take into account the scrollbar size when calculating minOffset\n        // this value can be larger than maxOffset when at the end of the list\n        return minOffset;\n      } else if (scrollOffset < minOffset) {\n        return minOffset;\n      } else {\n        return maxOffset;\n      }\n  }\n};\n\nconst VariableSizeGrid = createGridComponent({\n  getColumnOffset: (\n    props: Props<any>,\n    index: number,\n    instanceProps: InstanceProps\n  ): number => getItemMetadata('column', props, index, instanceProps).offset,\n\n  getColumnStartIndexForOffset: (\n    props: Props<any>,\n    scrollLeft: number,\n    instanceProps: InstanceProps\n  ): number => findNearestItem('column', props, instanceProps, scrollLeft),\n\n  getColumnStopIndexForStartIndex: (\n    props: Props<any>,\n    startIndex: number,\n    scrollLeft: number,\n    instanceProps: InstanceProps\n  ): number => {\n    const { columnCount, width } = props;\n\n    const itemMetadata = getItemMetadata(\n      'column',\n      props,\n      startIndex,\n      instanceProps\n    );\n    const maxOffset = scrollLeft + width;\n\n    let offset = itemMetadata.offset + itemMetadata.size;\n    let stopIndex = startIndex;\n\n    while (stopIndex < columnCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata('column', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n\n  getColumnWidth: (\n    props: Props<any>,\n    index: number,\n    instanceProps: InstanceProps\n  ): number => instanceProps.columnMetadataMap[index].size,\n\n  getEstimatedTotalHeight,\n  getEstimatedTotalWidth,\n\n  getOffsetForColumnAndAlignment: (\n    props: Props<any>,\n    index: number,\n    align: ScrollToAlign,\n    scrollOffset: number,\n    instanceProps: InstanceProps,\n    scrollbarSize: number\n  ): number =>\n    getOffsetForIndexAndAlignment(\n      'column',\n      props,\n      index,\n      align,\n      scrollOffset,\n      instanceProps,\n      scrollbarSize\n    ),\n\n  getOffsetForRowAndAlignment: (\n    props: Props<any>,\n    index: number,\n    align: ScrollToAlign,\n    scrollOffset: number,\n    instanceProps: InstanceProps,\n    scrollbarSize: number\n  ): number =>\n    getOffsetForIndexAndAlignment(\n      'row',\n      props,\n      index,\n      align,\n      scrollOffset,\n      instanceProps,\n      scrollbarSize\n    ),\n\n  getRowOffset: (\n    props: Props<any>,\n    index: number,\n    instanceProps: InstanceProps\n  ): number => getItemMetadata('row', props, index, instanceProps).offset,\n\n  getRowHeight: (\n    props: Props<any>,\n    index: number,\n    instanceProps: InstanceProps\n  ): number => instanceProps.rowMetadataMap[index].size,\n\n  getRowStartIndexForOffset: (\n    props: Props<any>,\n    scrollTop: number,\n    instanceProps: InstanceProps\n  ): number => findNearestItem('row', props, instanceProps, scrollTop),\n\n  getRowStopIndexForStartIndex: (\n    props: Props<any>,\n    startIndex: number,\n    scrollTop: number,\n    instanceProps: InstanceProps\n  ): number => {\n    const { rowCount, height } = props;\n\n    const itemMetadata = getItemMetadata(\n      'row',\n      props,\n      startIndex,\n      instanceProps\n    );\n    const maxOffset = scrollTop + height;\n\n    let offset = itemMetadata.offset + itemMetadata.size;\n    let stopIndex = startIndex;\n\n    while (stopIndex < rowCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata('row', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n\n  initInstanceProps(props: Props<any>, instance: any): InstanceProps {\n    const {\n      estimatedColumnWidth,\n      estimatedRowHeight,\n    } = ((props: any): VariableSizeProps);\n\n    const instanceProps = {\n      columnMetadataMap: {},\n      estimatedColumnWidth: estimatedColumnWidth || DEFAULT_ESTIMATED_ITEM_SIZE,\n      estimatedRowHeight: estimatedRowHeight || DEFAULT_ESTIMATED_ITEM_SIZE,\n      lastMeasuredColumnIndex: -1,\n      lastMeasuredRowIndex: -1,\n      rowMetadataMap: {},\n    };\n\n    instance.resetAfterColumnIndex = (\n      columnIndex: number,\n      shouldForceUpdate?: boolean = true\n    ) => {\n      instance.resetAfterIndices({ columnIndex, shouldForceUpdate });\n    };\n\n    instance.resetAfterRowIndex = (\n      rowIndex: number,\n      shouldForceUpdate?: boolean = true\n    ) => {\n      instance.resetAfterIndices({ rowIndex, shouldForceUpdate });\n    };\n\n    instance.resetAfterIndices = ({\n      columnIndex,\n      rowIndex,\n      shouldForceUpdate = true,\n    }: {\n      columnIndex?: number,\n      rowIndex?: number,\n      shouldForceUpdate: boolean,\n    }) => {\n      if (typeof columnIndex === 'number') {\n        instanceProps.lastMeasuredColumnIndex = Math.min(\n          instanceProps.lastMeasuredColumnIndex,\n          columnIndex - 1\n        );\n      }\n      if (typeof rowIndex === 'number') {\n        instanceProps.lastMeasuredRowIndex = Math.min(\n          instanceProps.lastMeasuredRowIndex,\n          rowIndex - 1\n        );\n      }\n\n      // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n\n  shouldResetStyleCacheOnItemSizeChange: false,\n\n  validateProps: ({ columnWidth, rowHeight }: Props<any>): void => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'function') {\n        throw Error(\n          'An invalid \"columnWidth\" prop has been specified. ' +\n            'Value should be a function. ' +\n            `\"${\n              columnWidth === null ? 'null' : typeof columnWidth\n            }\" was specified.`\n        );\n      } else if (typeof rowHeight !== 'function') {\n        throw Error(\n          'An invalid \"rowHeight\" prop has been specified. ' +\n            'Value should be a function. ' +\n            `\"${rowHeight === null ? 'null' : typeof rowHeight}\" was specified.`\n        );\n      }\n    }\n  },\n});\n\nexport default VariableSizeGrid;\n","// @flow\n\nimport memoizeOne from 'memoize-one';\nimport { createElement, PureComponent } from 'react';\nimport { cancelTimeout, requestTimeout } from './timer';\nimport { getRTLOffsetType } from './domHelpers';\n\nimport type { TimeoutID } from './timer';\n\nexport type ScrollToAlign = 'auto' | 'smart' | 'center' | 'start' | 'end';\n\ntype itemSize = number | ((index: number) => number);\n// TODO Deprecate directions \"horizontal\" and \"vertical\"\ntype Direction = 'ltr' | 'rtl' | 'horizontal' | 'vertical';\ntype Layout = 'horizontal' | 'vertical';\n\ntype RenderComponentProps<T> = {|\n  data: T,\n  index: number,\n  isScrolling?: boolean,\n  style: Object,\n|};\ntype RenderComponent<T> = React$ComponentType<$Shape<RenderComponentProps<T>>>;\n\ntype ScrollDirection = 'forward' | 'backward';\n\ntype onItemsRenderedCallback = ({\n  overscanStartIndex: number,\n  overscanStopIndex: number,\n  visibleStartIndex: number,\n  visibleStopIndex: number,\n}) => void;\ntype onScrollCallback = ({\n  scrollDirection: ScrollDirection,\n  scrollOffset: number,\n  scrollUpdateWasRequested: boolean,\n}) => void;\n\ntype ScrollEvent = SyntheticEvent<HTMLDivElement>;\ntype ItemStyleCache = { [index: number]: Object };\n\ntype OuterProps = {|\n  children: React$Node,\n  className: string | void,\n  onScroll: ScrollEvent => void,\n  style: {\n    [string]: mixed,\n  },\n|};\n\ntype InnerProps = {|\n  children: React$Node,\n  style: {\n    [string]: mixed,\n  },\n|};\n\nexport type Props<T> = {|\n  children: RenderComponent<T>,\n  className?: string,\n  direction: Direction,\n  height: number | string,\n  initialScrollOffset?: number,\n  innerRef?: any,\n  innerElementType?: string | React$AbstractComponent<InnerProps, any>,\n  innerTagName?: string, // deprecated\n  itemCount: number,\n  itemData: T,\n  itemKey?: (index: number, data: T) => any,\n  itemSize: itemSize,\n  layout: Layout,\n  onItemsRendered?: onItemsRenderedCallback,\n  onScroll?: onScrollCallback,\n  outerRef?: any,\n  outerElementType?: string | React$AbstractComponent<OuterProps, any>,\n  outerTagName?: string, // deprecated\n  overscanCount: number,\n  style?: Object,\n  useIsScrolling: boolean,\n  width: number | string,\n|};\n\ntype State = {|\n  instance: any,\n  isScrolling: boolean,\n  scrollDirection: ScrollDirection,\n  scrollOffset: number,\n  scrollUpdateWasRequested: boolean,\n|};\n\ntype GetItemOffset = (\n  props: Props<any>,\n  index: number,\n  instanceProps: any\n) => number;\ntype GetItemSize = (\n  props: Props<any>,\n  index: number,\n  instanceProps: any\n) => number;\ntype GetEstimatedTotalSize = (props: Props<any>, instanceProps: any) => number;\ntype GetOffsetForIndexAndAlignment = (\n  props: Props<any>,\n  index: number,\n  align: ScrollToAlign,\n  scrollOffset: number,\n  instanceProps: any\n) => number;\ntype GetStartIndexForOffset = (\n  props: Props<any>,\n  offset: number,\n  instanceProps: any\n) => number;\ntype GetStopIndexForStartIndex = (\n  props: Props<any>,\n  startIndex: number,\n  scrollOffset: number,\n  instanceProps: any\n) => number;\ntype InitInstanceProps = (props: Props<any>, instance: any) => any;\ntype ValidateProps = (props: Props<any>) => void;\n\nconst IS_SCROLLING_DEBOUNCE_INTERVAL = 150;\n\nconst defaultItemKey = (index: number, data: any) => index;\n\n// In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\nlet devWarningsDirection = null;\nlet devWarningsTagName = null;\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsDirection = new WeakSet();\n    devWarningsTagName = new WeakSet();\n  }\n}\n\nexport default function createListComponent({\n  getItemOffset,\n  getEstimatedTotalSize,\n  getItemSize,\n  getOffsetForIndexAndAlignment,\n  getStartIndexForOffset,\n  getStopIndexForStartIndex,\n  initInstanceProps,\n  shouldResetStyleCacheOnItemSizeChange,\n  validateProps,\n}: {|\n  getItemOffset: GetItemOffset,\n  getEstimatedTotalSize: GetEstimatedTotalSize,\n  getItemSize: GetItemSize,\n  getOffsetForIndexAndAlignment: GetOffsetForIndexAndAlignment,\n  getStartIndexForOffset: GetStartIndexForOffset,\n  getStopIndexForStartIndex: GetStopIndexForStartIndex,\n  initInstanceProps: InitInstanceProps,\n  shouldResetStyleCacheOnItemSizeChange: boolean,\n  validateProps: ValidateProps,\n|}) {\n  return class List<T> extends PureComponent<Props<T>, State> {\n    _instanceProps: any = initInstanceProps(this.props, this);\n    _outerRef: ?HTMLDivElement;\n    _resetIsScrollingTimeoutId: TimeoutID | null = null;\n\n    static defaultProps = {\n      direction: 'ltr',\n      itemData: undefined,\n      layout: 'vertical',\n      overscanCount: 2,\n      useIsScrolling: false,\n    };\n\n    state: State = {\n      instance: this,\n      isScrolling: false,\n      scrollDirection: 'forward',\n      scrollOffset:\n        typeof this.props.initialScrollOffset === 'number'\n          ? this.props.initialScrollOffset\n          : 0,\n      scrollUpdateWasRequested: false,\n    };\n\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    constructor(props: Props<T>) {\n      super(props);\n    }\n\n    static getDerivedStateFromProps(\n      nextProps: Props<T>,\n      prevState: State\n    ): $Shape<State> | null {\n      validateSharedProps(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    }\n\n    scrollTo(scrollOffset: number): void {\n      scrollOffset = Math.max(0, scrollOffset);\n\n      this.setState(prevState => {\n        if (prevState.scrollOffset === scrollOffset) {\n          return null;\n        }\n        return {\n          scrollDirection:\n            prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n          scrollOffset: scrollOffset,\n          scrollUpdateWasRequested: true,\n        };\n      }, this._resetIsScrollingDebounced);\n    }\n\n    scrollToItem(index: number, align: ScrollToAlign = 'auto'): void {\n      const { itemCount } = this.props;\n      const { scrollOffset } = this.state;\n\n      index = Math.max(0, Math.min(index, itemCount - 1));\n\n      this.scrollTo(\n        getOffsetForIndexAndAlignment(\n          this.props,\n          index,\n          align,\n          scrollOffset,\n          this._instanceProps\n        )\n      );\n    }\n\n    componentDidMount() {\n      const { direction, initialScrollOffset, layout } = this.props;\n\n      if (typeof initialScrollOffset === 'number' && this._outerRef != null) {\n        const outerRef = ((this._outerRef: any): HTMLElement);\n        // TODO Deprecate direction \"horizontal\"\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          outerRef.scrollLeft = initialScrollOffset;\n        } else {\n          outerRef.scrollTop = initialScrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    }\n\n    componentDidUpdate() {\n      const { direction, layout } = this.props;\n      const { scrollOffset, scrollUpdateWasRequested } = this.state;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        const outerRef = ((this._outerRef: any): HTMLElement);\n\n        // TODO Deprecate direction \"horizontal\"\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          if (direction === 'rtl') {\n            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n            // So we need to determine which browser behavior we're dealing with, and mimic it.\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                outerRef.scrollLeft = -scrollOffset;\n                break;\n              case 'positive-ascending':\n                outerRef.scrollLeft = scrollOffset;\n                break;\n              default:\n                const { clientWidth, scrollWidth } = outerRef;\n                outerRef.scrollLeft = scrollWidth - clientWidth - scrollOffset;\n                break;\n            }\n          } else {\n            outerRef.scrollLeft = scrollOffset;\n          }\n        } else {\n          outerRef.scrollTop = scrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    }\n\n    componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    }\n\n    render() {\n      const {\n        children,\n        className,\n        direction,\n        height,\n        innerRef,\n        innerElementType,\n        innerTagName,\n        itemCount,\n        itemData,\n        itemKey = defaultItemKey,\n        layout,\n        outerElementType,\n        outerTagName,\n        style,\n        useIsScrolling,\n        width,\n      } = this.props;\n      const { isScrolling } = this.state;\n\n      // TODO Deprecate direction \"horizontal\"\n      const isHorizontal =\n        direction === 'horizontal' || layout === 'horizontal';\n\n      const onScroll = isHorizontal\n        ? this._onScrollHorizontal\n        : this._onScrollVertical;\n\n      const [startIndex, stopIndex] = this._getRangeToRender();\n\n      const items = [];\n      if (itemCount > 0) {\n        for (let index = startIndex; index <= stopIndex; index++) {\n          items.push(\n            createElement(children, {\n              data: itemData,\n              key: itemKey(index, itemData),\n              index,\n              isScrolling: useIsScrolling ? isScrolling : undefined,\n              style: this._getItemStyle(index),\n            })\n          );\n        }\n      }\n\n      // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n      const estimatedTotalSize = getEstimatedTotalSize(\n        this.props,\n        this._instanceProps\n      );\n\n      return createElement(\n        outerElementType || outerTagName || 'div',\n        {\n          className,\n          onScroll,\n          ref: this._outerRefSetter,\n          style: {\n            position: 'relative',\n            height,\n            width,\n            overflow: 'auto',\n            WebkitOverflowScrolling: 'touch',\n            willChange: 'transform',\n            direction,\n            ...style,\n          },\n        },\n        createElement(innerElementType || innerTagName || 'div', {\n          children: items,\n          ref: innerRef,\n          style: {\n            height: isHorizontal ? '100%' : estimatedTotalSize,\n            pointerEvents: isScrolling ? 'none' : undefined,\n            width: isHorizontal ? estimatedTotalSize : '100%',\n          },\n        })\n      );\n    }\n\n    _callOnItemsRendered: (\n      overscanStartIndex: number,\n      overscanStopIndex: number,\n      visibleStartIndex: number,\n      visibleStopIndex: number\n    ) => void;\n    _callOnItemsRendered = memoizeOne(\n      (\n        overscanStartIndex: number,\n        overscanStopIndex: number,\n        visibleStartIndex: number,\n        visibleStopIndex: number\n      ) =>\n        ((this.props.onItemsRendered: any): onItemsRenderedCallback)({\n          overscanStartIndex,\n          overscanStopIndex,\n          visibleStartIndex,\n          visibleStopIndex,\n        })\n    );\n\n    _callOnScroll: (\n      scrollDirection: ScrollDirection,\n      scrollOffset: number,\n      scrollUpdateWasRequested: boolean\n    ) => void;\n    _callOnScroll = memoizeOne(\n      (\n        scrollDirection: ScrollDirection,\n        scrollOffset: number,\n        scrollUpdateWasRequested: boolean\n      ) =>\n        ((this.props.onScroll: any): onScrollCallback)({\n          scrollDirection,\n          scrollOffset,\n          scrollUpdateWasRequested,\n        })\n    );\n\n    _callPropsCallbacks() {\n      if (typeof this.props.onItemsRendered === 'function') {\n        const { itemCount } = this.props;\n        if (itemCount > 0) {\n          const [\n            overscanStartIndex,\n            overscanStopIndex,\n            visibleStartIndex,\n            visibleStopIndex,\n          ] = this._getRangeToRender();\n          this._callOnItemsRendered(\n            overscanStartIndex,\n            overscanStopIndex,\n            visibleStartIndex,\n            visibleStopIndex\n          );\n        }\n      }\n\n      if (typeof this.props.onScroll === 'function') {\n        const {\n          scrollDirection,\n          scrollOffset,\n          scrollUpdateWasRequested,\n        } = this.state;\n        this._callOnScroll(\n          scrollDirection,\n          scrollOffset,\n          scrollUpdateWasRequested\n        );\n      }\n    }\n\n    // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n    _getItemStyle: (index: number) => Object;\n    _getItemStyle = (index: number): Object => {\n      const { direction, itemSize, layout } = this.props;\n\n      const itemStyleCache = this._getItemStyleCache(\n        shouldResetStyleCacheOnItemSizeChange && itemSize,\n        shouldResetStyleCacheOnItemSizeChange && layout,\n        shouldResetStyleCacheOnItemSizeChange && direction\n      );\n\n      let style;\n      if (itemStyleCache.hasOwnProperty(index)) {\n        style = itemStyleCache[index];\n      } else {\n        const offset = getItemOffset(this.props, index, this._instanceProps);\n        const size = getItemSize(this.props, index, this._instanceProps);\n\n        // TODO Deprecate direction \"horizontal\"\n        const isHorizontal =\n          direction === 'horizontal' || layout === 'horizontal';\n\n        const isRtl = direction === 'rtl';\n        const offsetHorizontal = isHorizontal ? offset : 0;\n        itemStyleCache[index] = style = {\n          position: 'absolute',\n          left: isRtl ? undefined : offsetHorizontal,\n          right: isRtl ? offsetHorizontal : undefined,\n          top: !isHorizontal ? offset : 0,\n          height: !isHorizontal ? size : '100%',\n          width: isHorizontal ? size : '100%',\n        };\n      }\n\n      return style;\n    };\n\n    _getItemStyleCache: (_: any, __: any, ___: any) => ItemStyleCache;\n    _getItemStyleCache = memoizeOne((_: any, __: any, ___: any) => ({}));\n\n    _getRangeToRender(): [number, number, number, number] {\n      const { itemCount, overscanCount } = this.props;\n      const { isScrolling, scrollDirection, scrollOffset } = this.state;\n\n      if (itemCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      const startIndex = getStartIndexForOffset(\n        this.props,\n        scrollOffset,\n        this._instanceProps\n      );\n      const stopIndex = getStopIndexForStartIndex(\n        this.props,\n        startIndex,\n        scrollOffset,\n        this._instanceProps\n      );\n\n      // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n      const overscanBackward =\n        !isScrolling || scrollDirection === 'backward'\n          ? Math.max(1, overscanCount)\n          : 1;\n      const overscanForward =\n        !isScrolling || scrollDirection === 'forward'\n          ? Math.max(1, overscanCount)\n          : 1;\n\n      return [\n        Math.max(0, startIndex - overscanBackward),\n        Math.max(0, Math.min(itemCount - 1, stopIndex + overscanForward)),\n        startIndex,\n        stopIndex,\n      ];\n    }\n\n    _onScrollHorizontal = (event: ScrollEvent): void => {\n      const { clientWidth, scrollLeft, scrollWidth } = event.currentTarget;\n      this.setState(prevState => {\n        if (prevState.scrollOffset === scrollLeft) {\n          // Scroll position may have been updated by cDM/cDU,\n          // In which case we don't need to trigger another render,\n          // And we don't want to update state.isScrolling.\n          return null;\n        }\n\n        const { direction } = this.props;\n\n        let scrollOffset = scrollLeft;\n        if (direction === 'rtl') {\n          // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n          // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n          // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n          // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n          switch (getRTLOffsetType()) {\n            case 'negative':\n              scrollOffset = -scrollLeft;\n              break;\n            case 'positive-descending':\n              scrollOffset = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        }\n\n        // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n        scrollOffset = Math.max(\n          0,\n          Math.min(scrollOffset, scrollWidth - clientWidth)\n        );\n\n        return {\n          isScrolling: true,\n          scrollDirection:\n            prevState.scrollOffset < scrollLeft ? 'forward' : 'backward',\n          scrollOffset,\n          scrollUpdateWasRequested: false,\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _onScrollVertical = (event: ScrollEvent): void => {\n      const { clientHeight, scrollHeight, scrollTop } = event.currentTarget;\n      this.setState(prevState => {\n        if (prevState.scrollOffset === scrollTop) {\n          // Scroll position may have been updated by cDM/cDU,\n          // In which case we don't need to trigger another render,\n          // And we don't want to update state.isScrolling.\n          return null;\n        }\n\n        // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n        const scrollOffset = Math.max(\n          0,\n          Math.min(scrollTop, scrollHeight - clientHeight)\n        );\n\n        return {\n          isScrolling: true,\n          scrollDirection:\n            prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n          scrollOffset,\n          scrollUpdateWasRequested: false,\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _outerRefSetter = (ref: any): void => {\n      const { outerRef } = this.props;\n\n      this._outerRef = ((ref: any): HTMLDivElement);\n\n      if (typeof outerRef === 'function') {\n        outerRef(ref);\n      } else if (\n        outerRef != null &&\n        typeof outerRef === 'object' &&\n        outerRef.hasOwnProperty('current')\n      ) {\n        outerRef.current = ref;\n      }\n    };\n\n    _resetIsScrollingDebounced = () => {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n\n      this._resetIsScrollingTimeoutId = requestTimeout(\n        this._resetIsScrolling,\n        IS_SCROLLING_DEBOUNCE_INTERVAL\n      );\n    };\n\n    _resetIsScrolling = () => {\n      this._resetIsScrollingTimeoutId = null;\n\n      this.setState({ isScrolling: false }, () => {\n        // Clear style cache after state update has been committed.\n        // This way we don't break pure sCU for items that don't use isScrolling param.\n        this._getItemStyleCache(-1, null);\n      });\n    };\n  };\n}\n\n// NOTE: I considered further wrapping individual items with a pure ListItem component.\n// This would avoid ever calling the render function for the same index more than once,\n// But it would also add the overhead of a lot of components/fibers.\n// I assume people already do this (render function returning a class component),\n// So my doing it would just unnecessarily double the wrappers.\n\nconst validateSharedProps = (\n  {\n    children,\n    direction,\n    height,\n    layout,\n    innerTagName,\n    outerTagName,\n    width,\n  }: Props<any>,\n  { instance }: State\n): void => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName && !devWarningsTagName.has(instance)) {\n        devWarningsTagName.add(instance);\n        console.warn(\n          'The innerTagName and outerTagName props have been deprecated. ' +\n            'Please use the innerElementType and outerElementType props instead.'\n        );\n      }\n    }\n\n    // TODO Deprecate direction \"horizontal\"\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n\n    switch (direction) {\n      case 'horizontal':\n      case 'vertical':\n        if (devWarningsDirection && !devWarningsDirection.has(instance)) {\n          devWarningsDirection.add(instance);\n          console.warn(\n            'The direction prop should be either \"ltr\" (default) or \"rtl\". ' +\n              'Please use the layout prop to specify \"vertical\" (default) or \"horizontal\" orientation.'\n          );\n        }\n        break;\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n      default:\n        throw Error(\n          'An invalid \"direction\" prop has been specified. ' +\n            'Value should be either \"ltr\" or \"rtl\". ' +\n            `\"${direction}\" was specified.`\n        );\n    }\n\n    switch (layout) {\n      case 'horizontal':\n      case 'vertical':\n        // Valid values\n        break;\n      default:\n        throw Error(\n          'An invalid \"layout\" prop has been specified. ' +\n            'Value should be either \"horizontal\" or \"vertical\". ' +\n            `\"${layout}\" was specified.`\n        );\n    }\n\n    if (children == null) {\n      throw Error(\n        'An invalid \"children\" prop has been specified. ' +\n          'Value should be a React component. ' +\n          `\"${children === null ? 'null' : typeof children}\" was specified.`\n      );\n    }\n\n    if (isHorizontal && typeof width !== 'number') {\n      throw Error(\n        'An invalid \"width\" prop has been specified. ' +\n          'Horizontal lists must specify a number for width. ' +\n          `\"${width === null ? 'null' : typeof width}\" was specified.`\n      );\n    } else if (!isHorizontal && typeof height !== 'number') {\n      throw Error(\n        'An invalid \"height\" prop has been specified. ' +\n          'Vertical lists must specify a number for height. ' +\n          `\"${height === null ? 'null' : typeof height}\" was specified.`\n      );\n    }\n  }\n};\n","// @flow\n\nimport createListComponent from './createListComponent';\n\nimport type { Props, ScrollToAlign } from './createListComponent';\n\nconst DEFAULT_ESTIMATED_ITEM_SIZE = 50;\n\ntype VariableSizeProps = {|\n  estimatedItemSize: number,\n  ...Props<any>,\n|};\n\ntype itemSizeGetter = (index: number) => number;\n\ntype ItemMetadata = {|\n  offset: number,\n  size: number,\n|};\ntype InstanceProps = {|\n  itemMetadataMap: { [index: number]: ItemMetadata },\n  estimatedItemSize: number,\n  lastMeasuredIndex: number,\n|};\n\nconst getItemMetadata = (\n  props: Props<any>,\n  index: number,\n  instanceProps: InstanceProps\n): ItemMetadata => {\n  const { itemSize } = ((props: any): VariableSizeProps);\n  const { itemMetadataMap, lastMeasuredIndex } = instanceProps;\n\n  if (index > lastMeasuredIndex) {\n    let offset = 0;\n    if (lastMeasuredIndex >= 0) {\n      const itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (let i = lastMeasuredIndex + 1; i <= index; i++) {\n      let size = ((itemSize: any): itemSizeGetter)(i);\n\n      itemMetadataMap[i] = {\n        offset,\n        size,\n      };\n\n      offset += size;\n    }\n\n    instanceProps.lastMeasuredIndex = index;\n  }\n\n  return itemMetadataMap[index];\n};\n\nconst findNearestItem = (\n  props: Props<any>,\n  instanceProps: InstanceProps,\n  offset: number\n) => {\n  const { itemMetadataMap, lastMeasuredIndex } = instanceProps;\n\n  const lastMeasuredItemOffset =\n    lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch(\n      props,\n      instanceProps,\n      lastMeasuredIndex,\n      0,\n      offset\n    );\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch(\n      props,\n      instanceProps,\n      Math.max(0, lastMeasuredIndex),\n      offset\n    );\n  }\n};\n\nconst findNearestItemBinarySearch = (\n  props: Props<any>,\n  instanceProps: InstanceProps,\n  high: number,\n  low: number,\n  offset: number\n): number => {\n  while (low <= high) {\n    const middle = low + Math.floor((high - low) / 2);\n    const currentOffset = getItemMetadata(props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nconst findNearestItemExponentialSearch = (\n  props: Props<any>,\n  instanceProps: InstanceProps,\n  index: number,\n  offset: number\n): number => {\n  const { itemCount } = props;\n  let interval = 1;\n\n  while (\n    index < itemCount &&\n    getItemMetadata(props, index, instanceProps).offset < offset\n  ) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch(\n    props,\n    instanceProps,\n    Math.min(index, itemCount - 1),\n    Math.floor(index / 2),\n    offset\n  );\n};\n\nconst getEstimatedTotalSize = (\n  { itemCount }: Props<any>,\n  { itemMetadataMap, estimatedItemSize, lastMeasuredIndex }: InstanceProps\n) => {\n  let totalSizeOfMeasuredItems = 0;\n\n  // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n  if (lastMeasuredIndex >= itemCount) {\n    lastMeasuredIndex = itemCount - 1;\n  }\n\n  if (lastMeasuredIndex >= 0) {\n    const itemMetadata = itemMetadataMap[lastMeasuredIndex];\n    totalSizeOfMeasuredItems = itemMetadata.offset + itemMetadata.size;\n  }\n\n  const numUnmeasuredItems = itemCount - lastMeasuredIndex - 1;\n  const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;\n\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;\n};\n\nconst VariableSizeList = createListComponent({\n  getItemOffset: (\n    props: Props<any>,\n    index: number,\n    instanceProps: InstanceProps\n  ): number => getItemMetadata(props, index, instanceProps).offset,\n\n  getItemSize: (\n    props: Props<any>,\n    index: number,\n    instanceProps: InstanceProps\n  ): number => instanceProps.itemMetadataMap[index].size,\n\n  getEstimatedTotalSize,\n\n  getOffsetForIndexAndAlignment: (\n    props: Props<any>,\n    index: number,\n    align: ScrollToAlign,\n    scrollOffset: number,\n    instanceProps: InstanceProps\n  ): number => {\n    const { direction, height, layout, width } = props;\n\n    // TODO Deprecate direction \"horizontal\"\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    const size = (((isHorizontal ? width : height): any): number);\n    const itemMetadata = getItemMetadata(props, index, instanceProps);\n\n    // Get estimated total size after ItemMetadata is computed,\n    // To ensure it reflects actual measurements instead of just estimates.\n    const estimatedTotalSize = getEstimatedTotalSize(props, instanceProps);\n\n    const maxOffset = Math.max(\n      0,\n      Math.min(estimatedTotalSize - size, itemMetadata.offset)\n    );\n    const minOffset = Math.max(\n      0,\n      itemMetadata.offset - size + itemMetadata.size\n    );\n\n    if (align === 'smart') {\n      if (\n        scrollOffset >= minOffset - size &&\n        scrollOffset <= maxOffset + size\n      ) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n      case 'end':\n        return minOffset;\n      case 'center':\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n    }\n  },\n\n  getStartIndexForOffset: (\n    props: Props<any>,\n    offset: number,\n    instanceProps: InstanceProps\n  ): number => findNearestItem(props, instanceProps, offset),\n\n  getStopIndexForStartIndex: (\n    props: Props<any>,\n    startIndex: number,\n    scrollOffset: number,\n    instanceProps: InstanceProps\n  ): number => {\n    const { direction, height, itemCount, layout, width } = props;\n\n    // TODO Deprecate direction \"horizontal\"\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    const size = (((isHorizontal ? width : height): any): number);\n    const itemMetadata = getItemMetadata(props, startIndex, instanceProps);\n    const maxOffset = scrollOffset + size;\n\n    let offset = itemMetadata.offset + itemMetadata.size;\n    let stopIndex = startIndex;\n\n    while (stopIndex < itemCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata(props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n\n  initInstanceProps(props: Props<any>, instance: any): InstanceProps {\n    const { estimatedItemSize } = ((props: any): VariableSizeProps);\n\n    const instanceProps = {\n      itemMetadataMap: {},\n      estimatedItemSize: estimatedItemSize || DEFAULT_ESTIMATED_ITEM_SIZE,\n      lastMeasuredIndex: -1,\n    };\n\n    instance.resetAfterIndex = (\n      index: number,\n      shouldForceUpdate?: boolean = true\n    ) => {\n      instanceProps.lastMeasuredIndex = Math.min(\n        instanceProps.lastMeasuredIndex,\n        index - 1\n      );\n\n      // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n\n  shouldResetStyleCacheOnItemSizeChange: false,\n\n  validateProps: ({ itemSize }: Props<any>): void => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'function') {\n        throw Error(\n          'An invalid \"itemSize\" prop has been specified. ' +\n            'Value should be a function. ' +\n            `\"${itemSize === null ? 'null' : typeof itemSize}\" was specified.`\n        );\n      }\n    }\n  },\n});\n\nexport default VariableSizeList;\n","// @flow\n\nimport createGridComponent from './createGridComponent';\n\nimport type { Props, ScrollToAlign } from './createGridComponent';\n\nconst FixedSizeGrid = createGridComponent({\n  getColumnOffset: ({ columnWidth }: Props<any>, index: number): number =>\n    index * ((columnWidth: any): number),\n\n  getColumnWidth: ({ columnWidth }: Props<any>, index: number): number =>\n    ((columnWidth: any): number),\n\n  getRowOffset: ({ rowHeight }: Props<any>, index: number): number =>\n    index * ((rowHeight: any): number),\n\n  getRowHeight: ({ rowHeight }: Props<any>, index: number): number =>\n    ((rowHeight: any): number),\n\n  getEstimatedTotalHeight: ({ rowCount, rowHeight }: Props<any>) =>\n    ((rowHeight: any): number) * rowCount,\n\n  getEstimatedTotalWidth: ({ columnCount, columnWidth }: Props<any>) =>\n    ((columnWidth: any): number) * columnCount,\n\n  getOffsetForColumnAndAlignment: (\n    { columnCount, columnWidth, width }: Props<any>,\n    columnIndex: number,\n    align: ScrollToAlign,\n    scrollLeft: number,\n    instanceProps: typeof undefined,\n    scrollbarSize: number\n  ): number => {\n    const lastColumnOffset = Math.max(\n      0,\n      columnCount * ((columnWidth: any): number) - width\n    );\n    const maxOffset = Math.min(\n      lastColumnOffset,\n      columnIndex * ((columnWidth: any): number)\n    );\n    const minOffset = Math.max(\n      0,\n      columnIndex * ((columnWidth: any): number) -\n        width +\n        scrollbarSize +\n        ((columnWidth: any): number)\n    );\n\n    if (align === 'smart') {\n      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n      case 'end':\n        return minOffset;\n      case 'center':\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        const middleOffset = Math.round(\n          minOffset + (maxOffset - minOffset) / 2\n        );\n        if (middleOffset < Math.ceil(width / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {\n          return lastColumnOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n      case 'auto':\n      default:\n        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {\n          return scrollLeft;\n        } else if (minOffset > maxOffset) {\n          // Because we only take into account the scrollbar size when calculating minOffset\n          // this value can be larger than maxOffset when at the end of the list\n          return minOffset;\n        } else if (scrollLeft < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n    }\n  },\n\n  getOffsetForRowAndAlignment: (\n    { rowHeight, height, rowCount }: Props<any>,\n    rowIndex: number,\n    align: ScrollToAlign,\n    scrollTop: number,\n    instanceProps: typeof undefined,\n    scrollbarSize: number\n  ): number => {\n    const lastRowOffset = Math.max(\n      0,\n      rowCount * ((rowHeight: any): number) - height\n    );\n    const maxOffset = Math.min(\n      lastRowOffset,\n      rowIndex * ((rowHeight: any): number)\n    );\n    const minOffset = Math.max(\n      0,\n      rowIndex * ((rowHeight: any): number) -\n        height +\n        scrollbarSize +\n        ((rowHeight: any): number)\n    );\n\n    if (align === 'smart') {\n      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n      case 'end':\n        return minOffset;\n      case 'center':\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        const middleOffset = Math.round(\n          minOffset + (maxOffset - minOffset) / 2\n        );\n        if (middleOffset < Math.ceil(height / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {\n          return lastRowOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n      case 'auto':\n      default:\n        if (scrollTop >= minOffset && scrollTop <= maxOffset) {\n          return scrollTop;\n        } else if (minOffset > maxOffset) {\n          // Because we only take into account the scrollbar size when calculating minOffset\n          // this value can be larger than maxOffset when at the end of the list\n          return minOffset;\n        } else if (scrollTop < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n    }\n  },\n\n  getColumnStartIndexForOffset: (\n    { columnWidth, columnCount }: Props<any>,\n    scrollLeft: number\n  ): number =>\n    Math.max(\n      0,\n      Math.min(\n        columnCount - 1,\n        Math.floor(scrollLeft / ((columnWidth: any): number))\n      )\n    ),\n\n  getColumnStopIndexForStartIndex: (\n    { columnWidth, columnCount, width }: Props<any>,\n    startIndex: number,\n    scrollLeft: number\n  ): number => {\n    const left = startIndex * ((columnWidth: any): number);\n    const numVisibleColumns = Math.ceil(\n      (width + scrollLeft - left) / ((columnWidth: any): number)\n    );\n    return Math.max(\n      0,\n      Math.min(\n        columnCount - 1,\n        startIndex + numVisibleColumns - 1 // -1 is because stop index is inclusive\n      )\n    );\n  },\n\n  getRowStartIndexForOffset: (\n    { rowHeight, rowCount }: Props<any>,\n    scrollTop: number\n  ): number =>\n    Math.max(\n      0,\n      Math.min(rowCount - 1, Math.floor(scrollTop / ((rowHeight: any): number)))\n    ),\n\n  getRowStopIndexForStartIndex: (\n    { rowHeight, rowCount, height }: Props<any>,\n    startIndex: number,\n    scrollTop: number\n  ): number => {\n    const top = startIndex * ((rowHeight: any): number);\n    const numVisibleRows = Math.ceil(\n      (height + scrollTop - top) / ((rowHeight: any): number)\n    );\n    return Math.max(\n      0,\n      Math.min(\n        rowCount - 1,\n        startIndex + numVisibleRows - 1 // -1 is because stop index is inclusive\n      )\n    );\n  },\n\n  initInstanceProps(props: Props<any>): any {\n    // Noop\n  },\n\n  shouldResetStyleCacheOnItemSizeChange: true,\n\n  validateProps: ({ columnWidth, rowHeight }: Props<any>): void => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'number') {\n        throw Error(\n          'An invalid \"columnWidth\" prop has been specified. ' +\n            'Value should be a number. ' +\n            `\"${\n              columnWidth === null ? 'null' : typeof columnWidth\n            }\" was specified.`\n        );\n      }\n\n      if (typeof rowHeight !== 'number') {\n        throw Error(\n          'An invalid \"rowHeight\" prop has been specified. ' +\n            'Value should be a number. ' +\n            `\"${rowHeight === null ? 'null' : typeof rowHeight}\" was specified.`\n        );\n      }\n    }\n  },\n});\n\nexport default FixedSizeGrid;\n","// @flow\n\nimport createListComponent from './createListComponent';\n\nimport type { Props, ScrollToAlign } from './createListComponent';\n\nconst FixedSizeList = createListComponent({\n  getItemOffset: ({ itemSize }: Props<any>, index: number): number =>\n    index * ((itemSize: any): number),\n\n  getItemSize: ({ itemSize }: Props<any>, index: number): number =>\n    ((itemSize: any): number),\n\n  getEstimatedTotalSize: ({ itemCount, itemSize }: Props<any>) =>\n    ((itemSize: any): number) * itemCount,\n\n  getOffsetForIndexAndAlignment: (\n    { direction, height, itemCount, itemSize, layout, width }: Props<any>,\n    index: number,\n    align: ScrollToAlign,\n    scrollOffset: number\n  ): number => {\n    // TODO Deprecate direction \"horizontal\"\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    const size = (((isHorizontal ? width : height): any): number);\n    const lastItemOffset = Math.max(\n      0,\n      itemCount * ((itemSize: any): number) - size\n    );\n    const maxOffset = Math.min(\n      lastItemOffset,\n      index * ((itemSize: any): number)\n    );\n    const minOffset = Math.max(\n      0,\n      index * ((itemSize: any): number) - size + ((itemSize: any): number)\n    );\n\n    if (align === 'smart') {\n      if (\n        scrollOffset >= minOffset - size &&\n        scrollOffset <= maxOffset + size\n      ) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n      case 'end':\n        return minOffset;\n      case 'center': {\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        const middleOffset = Math.round(\n          minOffset + (maxOffset - minOffset) / 2\n        );\n        if (middleOffset < Math.ceil(size / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {\n          return lastItemOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n      }\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n    }\n  },\n\n  getStartIndexForOffset: (\n    { itemCount, itemSize }: Props<any>,\n    offset: number\n  ): number =>\n    Math.max(\n      0,\n      Math.min(itemCount - 1, Math.floor(offset / ((itemSize: any): number)))\n    ),\n\n  getStopIndexForStartIndex: (\n    { direction, height, itemCount, itemSize, layout, width }: Props<any>,\n    startIndex: number,\n    scrollOffset: number\n  ): number => {\n    // TODO Deprecate direction \"horizontal\"\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    const offset = startIndex * ((itemSize: any): number);\n    const size = (((isHorizontal ? width : height): any): number);\n    const numVisibleItems = Math.ceil(\n      (size + scrollOffset - offset) / ((itemSize: any): number)\n    );\n    return Math.max(\n      0,\n      Math.min(\n        itemCount - 1,\n        startIndex + numVisibleItems - 1 // -1 is because stop index is inclusive\n      )\n    );\n  },\n\n  initInstanceProps(props: Props<any>): any {\n    // Noop\n  },\n\n  shouldResetStyleCacheOnItemSizeChange: true,\n\n  validateProps: ({ itemSize }: Props<any>): void => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'number') {\n        throw Error(\n          'An invalid \"itemSize\" prop has been specified. ' +\n            'Value should be a number. ' +\n            `\"${itemSize === null ? 'null' : typeof itemSize}\" was specified.`\n        );\n      }\n    }\n  },\n});\n\nexport default FixedSizeList;\n","// @flow\n\n// Pulled from react-compat\n// https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349\nexport default function shallowDiffers(prev: Object, next: Object): boolean {\n  for (let attribute in prev) {\n    if (!(attribute in next)) {\n      return true;\n    }\n  }\n  for (let attribute in next) {\n    if (prev[attribute] !== next[attribute]) {\n      return true;\n    }\n  }\n  return false;\n}\n","// @flow\n\nimport shallowDiffers from './shallowDiffers';\n\n// Custom comparison function for React.memo().\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-api.html#reactmemo\nexport default function areEqual(\n  prevProps: Object,\n  nextProps: Object\n): boolean {\n  const { style: prevStyle, ...prevRest } = prevProps;\n  const { style: nextStyle, ...nextRest } = nextProps;\n\n  return (\n    !shallowDiffers(prevStyle, nextStyle) && !shallowDiffers(prevRest, nextRest)\n  );\n}\n","// @flow\n\nimport areEqual from './areEqual';\nimport shallowDiffers from './shallowDiffers';\n\n// Custom shouldComponentUpdate for class components.\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-component.html#shouldcomponentupdate\nexport default function shouldComponentUpdate(\n  nextProps: Object,\n  nextState: Object\n): boolean {\n  return (\n    !areEqual(this.props, nextProps) || shallowDiffers(this.state, nextState)\n  );\n}\n"],"names":["hasNativePerformanceNow","performance","now","Date","cancelTimeout","timeoutID","cancelAnimationFrame","id","requestTimeout","callback","delay","start","tick","call","requestAnimationFrame","size","getScrollbarSize","recalculate","div","document","createElement","style","width","height","overflow","body","appendChild","offsetWidth","clientWidth","removeChild","cachedRTLResult","getRTLOffsetType","outerDiv","outerStyle","direction","innerDiv","innerStyle","scrollLeft","IS_SCROLLING_DEBOUNCE_INTERVAL","defaultItemKey","columnIndex","data","rowIndex","devWarningsOverscanCount","devWarningsOverscanRowsColumnsCount","devWarningsTagName","process","env","NODE_ENV","window","WeakSet","createGridComponent","getColumnOffset","getColumnStartIndexForOffset","getColumnStopIndexForStartIndex","getColumnWidth","getEstimatedTotalHeight","getEstimatedTotalWidth","getOffsetForColumnAndAlignment","getOffsetForRowAndAlignment","getRowHeight","getRowOffset","getRowStartIndexForOffset","getRowStopIndexForStartIndex","initInstanceProps","shouldResetStyleCacheOnItemSizeChange","validateProps","props","_instanceProps","_resetIsScrollingTimeoutId","_outerRef","state","instance","isScrolling","horizontalScrollDirection","initialScrollLeft","scrollTop","initialScrollTop","scrollUpdateWasRequested","verticalScrollDirection","_callOnItemsRendered","memoizeOne","overscanColumnStartIndex","overscanColumnStopIndex","overscanRowStartIndex","overscanRowStopIndex","visibleColumnStartIndex","visibleColumnStopIndex","visibleRowStartIndex","visibleRowStopIndex","onItemsRendered","_callOnScroll","onScroll","_getItemStyle","columnWidth","rowHeight","itemStyleCache","_getItemStyleCache","key","hasOwnProperty","offset","isRtl","position","left","undefined","right","top","_","__","___","_onScroll","event","currentTarget","clientHeight","scrollHeight","scrollWidth","setState","prevState","calculatedScrollLeft","Math","max","min","calculatedScrollTop","_resetIsScrollingDebounced","_outerRefSetter","ref","outerRef","current","_resetIsScrolling","getDerivedStateFromProps","nextProps","validateSharedProps","scrollTo","scrollToItem","align","columnCount","rowCount","scrollbarSize","estimatedTotalHeight","estimatedTotalWidth","horizontalScrollbarSize","verticalScrollbarSize","componentDidMount","_callPropsCallbacks","componentDidUpdate","componentWillUnmount","render","children","className","innerRef","innerElementType","innerTagName","itemData","itemKey","outerElementType","outerTagName","useIsScrolling","_getHorizontalRangeToRender","columnStartIndex","columnStopIndex","_getVerticalRangeToRender","rowStartIndex","rowStopIndex","items","push","WebkitOverflowScrolling","willChange","pointerEvents","overscanColumnCount","overscanColumnsCount","overscanCount","overscanCountResolved","startIndex","stopIndex","overscanBackward","overscanForward","overscanRowCount","overscanRowsCount","PureComponent","defaultProps","has","add","console","warn","Error","DEFAULT_ESTIMATED_ITEM_SIZE","rowMetadataMap","estimatedRowHeight","lastMeasuredRowIndex","totalSizeOfMeasuredRows","itemMetadata","numUnmeasuredItems","totalSizeOfUnmeasuredItems","columnMetadataMap","estimatedColumnWidth","lastMeasuredColumnIndex","getItemMetadata","itemType","index","instanceProps","itemMetadataMap","itemSize","lastMeasuredIndex","i","findNearestItem","lastMeasuredItemOffset","findNearestItemBinarySearch","findNearestItemExponentialSearch","high","low","middle","floor","currentOffset","itemCount","interval","getOffsetForIndexAndAlignment","scrollOffset","estimatedTotalSize","maxOffset","minOffset","round","VariableSizeGrid","resetAfterColumnIndex","shouldForceUpdate","resetAfterIndices","resetAfterRowIndex","forceUpdate","devWarningsDirection","createListComponent","getItemOffset","getEstimatedTotalSize","getItemSize","getStartIndexForOffset","getStopIndexForStartIndex","scrollDirection","initialScrollOffset","overscanStartIndex","overscanStopIndex","visibleStartIndex","visibleStopIndex","layout","isHorizontal","offsetHorizontal","_onScrollHorizontal","_onScrollVertical","_getRangeToRender","estimatedItemSize","totalSizeOfMeasuredItems","VariableSizeList","resetAfterIndex","FixedSizeGrid","lastColumnOffset","middleOffset","ceil","lastRowOffset","numVisibleColumns","numVisibleRows","FixedSizeList","lastItemOffset","numVisibleItems","shallowDiffers","prev","next","attribute","areEqual","prevProps","prevStyle","prevRest","nextStyle","nextRest","shouldComponentUpdate","nextState"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"index.esm.js","sources":["../src/timer.js","../src/domHelpers.js","../src/createGridComponent.js","../src/VariableSizeGrid.js","../src/createListComponent.js","../src/VariableSizeList.js","../src/FixedSizeGrid.js","../src/FixedSizeList.js","../src/shallowDiffers.js","../src/areEqual.js","../src/shouldComponentUpdate.js"],"sourcesContent":["// @flow\r\n\r\n// Animation frame based implementation of setTimeout.\r\n// Inspired by Joe Lambert, https://gist.github.com/joelambert/1002116#file-requesttimeout-js\r\n\r\nconst hasNativePerformanceNow =\r\n  typeof performance === 'object' && typeof performance.now === 'function';\r\n\r\nconst now = hasNativePerformanceNow\r\n  ? () => performance.now()\r\n  : () => Date.now();\r\n\r\nexport type TimeoutID = {|\r\n  id: AnimationFrameID,\r\n|};\r\n\r\nexport function cancelTimeout(timeoutID: TimeoutID) {\r\n  cancelAnimationFrame(timeoutID.id);\r\n}\r\n\r\nexport function requestTimeout(callback: Function, delay: number): TimeoutID {\r\n  const start = now();\r\n\r\n  function tick() {\r\n    if (now() - start >= delay) {\r\n      callback.call(null);\r\n    } else {\r\n      timeoutID.id = requestAnimationFrame(tick);\r\n    }\r\n  }\r\n\r\n  const timeoutID: TimeoutID = {\r\n    id: requestAnimationFrame(tick),\r\n  };\r\n\r\n  return timeoutID;\r\n}\r\n","// @flow\r\n\r\nlet size: number = -1;\r\n\r\n// This utility copied from \"dom-helpers\" package.\r\nexport function getScrollbarSize(recalculate?: boolean = false): number {\r\n  if (size === -1 || recalculate) {\r\n    const div = document.createElement('div');\r\n    const style = div.style;\r\n    style.width = '50px';\r\n    style.height = '50px';\r\n    style.overflow = 'scroll';\r\n\r\n    ((document.body: any): HTMLBodyElement).appendChild(div);\r\n\r\n    size = div.offsetWidth - div.clientWidth;\r\n\r\n    ((document.body: any): HTMLBodyElement).removeChild(div);\r\n  }\r\n\r\n  return size;\r\n}\r\n\r\nexport type RTLOffsetType =\r\n  | 'negative'\r\n  | 'positive-descending'\r\n  | 'positive-ascending';\r\n\r\nlet cachedRTLResult: RTLOffsetType | null = null;\r\n\r\n// TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\r\n// Chrome does not seem to adhere; its scrollLeft values are positive (measured relative to the left).\r\n// Safari's elastic bounce makes detecting this even more complicated wrt potential false positives.\r\n// The safest way to check this is to intentionally set a negative offset,\r\n// and then verify that the subsequent \"scroll\" event matches the negative offset.\r\n// If it does not match, then we can assume a non-standard RTL scroll implementation.\r\nexport function getRTLOffsetType(recalculate?: boolean = false): RTLOffsetType {\r\n  if (cachedRTLResult === null || recalculate) {\r\n    const outerDiv = document.createElement('div');\r\n    const outerStyle = outerDiv.style;\r\n    outerStyle.width = '50px';\r\n    outerStyle.height = '50px';\r\n    outerStyle.overflow = 'scroll';\r\n    outerStyle.direction = 'rtl';\r\n\r\n    const innerDiv = document.createElement('div');\r\n    const innerStyle = innerDiv.style;\r\n    innerStyle.width = '100px';\r\n    innerStyle.height = '100px';\r\n\r\n    outerDiv.appendChild(innerDiv);\r\n\r\n    ((document.body: any): HTMLBodyElement).appendChild(outerDiv);\r\n\r\n    if (outerDiv.scrollLeft > 0) {\r\n      cachedRTLResult = 'positive-descending';\r\n    } else {\r\n      outerDiv.scrollLeft = 1;\r\n      if (outerDiv.scrollLeft === 0) {\r\n        cachedRTLResult = 'negative';\r\n      } else {\r\n        cachedRTLResult = 'positive-ascending';\r\n      }\r\n    }\r\n\r\n    ((document.body: any): HTMLBodyElement).removeChild(outerDiv);\r\n\r\n    return cachedRTLResult;\r\n  }\r\n\r\n  return cachedRTLResult;\r\n}\r\n","// @flow\r\n\r\nimport memoizeOne from 'memoize-one';\r\nimport { createElement, PureComponent } from 'react';\r\nimport { cancelTimeout, requestTimeout } from './timer';\r\nimport { getScrollbarSize, getRTLOffsetType } from './domHelpers';\r\n\r\nimport type { TimeoutID } from './timer';\r\n\r\ntype Direction = 'ltr' | 'rtl';\r\nexport type ScrollToAlign = 'auto' | 'smart' | 'center' | 'start' | 'end';\r\n\r\ntype itemSize = number | ((index: number) => number);\r\n\r\ntype RenderComponentProps<T> = {|\r\n  columnIndex: number,\r\n  data: T,\r\n  isScrolling?: boolean,\r\n  rowIndex: number,\r\n  style: Object,\r\n|};\r\nexport type RenderComponent<T> = React$ComponentType<\r\n  $Shape<RenderComponentProps<T>>\r\n>;\r\n\r\ntype ScrollDirection = 'forward' | 'backward';\r\n\r\ntype OnItemsRenderedCallback = ({\r\n  overscanColumnStartIndex: number,\r\n  overscanColumnStopIndex: number,\r\n  overscanRowStartIndex: number,\r\n  overscanRowStopIndex: number,\r\n  visibleColumnStartIndex: number,\r\n  visibleColumnStopIndex: number,\r\n  visibleRowStartIndex: number,\r\n  visibleRowStopIndex: number,\r\n}) => void;\r\ntype OnScrollCallback = ({\r\n  horizontalScrollDirection: ScrollDirection,\r\n  scrollLeft: number,\r\n  scrollTop: number,\r\n  scrollUpdateWasRequested: boolean,\r\n  verticalScrollDirection: ScrollDirection,\r\n}) => void;\r\n\r\ntype ScrollEvent = SyntheticEvent<HTMLDivElement>;\r\ntype ItemStyleCache = { [key: string]: Object };\r\n\r\ntype OuterProps = {|\r\n  children: React$Node,\r\n  className: string | void,\r\n  onScroll: ScrollEvent => void,\r\n  style: {\r\n    [string]: mixed,\r\n  },\r\n|};\r\n\r\ntype InnerProps = {|\r\n  children: React$Node,\r\n  style: {\r\n    [string]: mixed,\r\n  },\r\n|};\r\n\r\nexport type Props<T> = {|\r\n  children: RenderComponent<T>,\r\n  className?: string,\r\n  columnCount: number,\r\n  columnWidth: itemSize,\r\n  direction: Direction,\r\n  height: number,\r\n  initialScrollLeft?: number,\r\n  initialScrollTop?: number,\r\n  innerRef?: any,\r\n  innerElementType?: string | React$AbstractComponent<InnerProps, any>,\r\n  innerTagName?: string, // deprecated\r\n  itemData: T,\r\n  itemKey?: (params: {|\r\n    columnIndex: number,\r\n    data: T,\r\n    rowIndex: number,\r\n  |}) => any,\r\n  onItemsRendered?: OnItemsRenderedCallback,\r\n  onScroll?: OnScrollCallback,\r\n  outerRef?: any,\r\n  outerElementType?: string | React$AbstractComponent<OuterProps, any>,\r\n  outerTagName?: string, // deprecated\r\n  overscanColumnCount?: number,\r\n  overscanColumnsCount?: number, // deprecated\r\n  overscanCount?: number, // deprecated\r\n  overscanRowCount?: number,\r\n  overscanRowsCount?: number, // deprecated\r\n  rowCount: number,\r\n  rowHeight: itemSize,\r\n  style?: Object,\r\n  useIsScrolling: boolean,\r\n  width: number,\r\n|};\r\n\r\ntype State = {|\r\n  instance: any,\r\n  isScrolling: boolean,\r\n  horizontalScrollDirection: ScrollDirection,\r\n  scrollLeft: number,\r\n  scrollTop: number,\r\n  scrollUpdateWasRequested: boolean,\r\n  verticalScrollDirection: ScrollDirection,\r\n|};\r\n\r\ntype getItemOffset = (\r\n  props: Props<any>,\r\n  index: number,\r\n  instanceProps: any\r\n) => number;\r\ntype getItemSize = (\r\n  props: Props<any>,\r\n  index: number,\r\n  instanceProps: any\r\n) => number;\r\ntype getEstimatedTotalSize = (props: Props<any>, instanceProps: any) => number;\r\ntype GetOffsetForItemAndAlignment = (\r\n  props: Props<any>,\r\n  index: number,\r\n  align: ScrollToAlign,\r\n  scrollOffset: number,\r\n  instanceProps: any,\r\n  scrollbarSize: number\r\n) => number;\r\ntype GetStartIndexForOffset = (\r\n  props: Props<any>,\r\n  offset: number,\r\n  instanceProps: any\r\n) => number;\r\ntype GetStopIndexForStartIndex = (\r\n  props: Props<any>,\r\n  startIndex: number,\r\n  scrollOffset: number,\r\n  instanceProps: any\r\n) => number;\r\ntype InitInstanceProps = (props: Props<any>, instance: any) => any;\r\ntype ValidateProps = (props: Props<any>) => void;\r\n\r\nconst IS_SCROLLING_DEBOUNCE_INTERVAL = 150;\r\n\r\nconst defaultItemKey = ({ columnIndex, data, rowIndex }) =>\r\n  `${rowIndex}:${columnIndex}`;\r\n\r\n// In DEV mode, this Set helps us only log a warning once per component instance.\r\n// This avoids spamming the console every time a render happens.\r\nlet devWarningsOverscanCount = null;\r\nlet devWarningsOverscanRowsColumnsCount = null;\r\nlet devWarningsTagName = null;\r\nif (process.env.NODE_ENV !== 'production') {\r\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\r\n    devWarningsOverscanCount = new WeakSet();\r\n    devWarningsOverscanRowsColumnsCount = new WeakSet();\r\n    devWarningsTagName = new WeakSet();\r\n  }\r\n}\r\n\r\nexport default function createGridComponent({\r\n  getColumnOffset,\r\n  getColumnStartIndexForOffset,\r\n  getColumnStopIndexForStartIndex,\r\n  getColumnWidth,\r\n  getEstimatedTotalHeight,\r\n  getEstimatedTotalWidth,\r\n  getOffsetForColumnAndAlignment,\r\n  getOffsetForRowAndAlignment,\r\n  getRowHeight,\r\n  getRowOffset,\r\n  getRowStartIndexForOffset,\r\n  getRowStopIndexForStartIndex,\r\n  initInstanceProps,\r\n  shouldResetStyleCacheOnItemSizeChange,\r\n  validateProps,\r\n}: {|\r\n  getColumnOffset: getItemOffset,\r\n  getColumnStartIndexForOffset: GetStartIndexForOffset,\r\n  getColumnStopIndexForStartIndex: GetStopIndexForStartIndex,\r\n  getColumnWidth: getItemSize,\r\n  getEstimatedTotalHeight: getEstimatedTotalSize,\r\n  getEstimatedTotalWidth: getEstimatedTotalSize,\r\n  getOffsetForColumnAndAlignment: GetOffsetForItemAndAlignment,\r\n  getOffsetForRowAndAlignment: GetOffsetForItemAndAlignment,\r\n  getRowOffset: getItemOffset,\r\n  getRowHeight: getItemSize,\r\n  getRowStartIndexForOffset: GetStartIndexForOffset,\r\n  getRowStopIndexForStartIndex: GetStopIndexForStartIndex,\r\n  initInstanceProps: InitInstanceProps,\r\n  shouldResetStyleCacheOnItemSizeChange: boolean,\r\n  validateProps: ValidateProps,\r\n|}) {\r\n  return class Grid<T> extends PureComponent<Props<T>, State> {\r\n    _instanceProps: any = initInstanceProps(this.props, this);\r\n    _resetIsScrollingTimeoutId: TimeoutID | null = null;\r\n    _outerRef: ?HTMLDivElement;\r\n\r\n    static defaultProps = {\r\n      direction: 'ltr',\r\n      itemData: undefined,\r\n      useIsScrolling: false,\r\n    };\r\n\r\n    state: State = {\r\n      instance: this,\r\n      isScrolling: false,\r\n      horizontalScrollDirection: 'forward',\r\n      scrollLeft:\r\n        typeof this.props.initialScrollLeft === 'number'\r\n          ? this.props.initialScrollLeft\r\n          : 0,\r\n      scrollTop:\r\n        typeof this.props.initialScrollTop === 'number'\r\n          ? this.props.initialScrollTop\r\n          : 0,\r\n      scrollUpdateWasRequested: false,\r\n      verticalScrollDirection: 'forward',\r\n    };\r\n\r\n    // Always use explicit constructor for React components.\r\n    // It produces less code after transpilation. (#26)\r\n    // eslint-disable-next-line no-useless-constructor\r\n    constructor(props: Props<T>) {\r\n      super(props);\r\n    }\r\n\r\n    static getDerivedStateFromProps(\r\n      nextProps: Props<T>,\r\n      prevState: State\r\n    ): $Shape<State> | null {\r\n      validateSharedProps(nextProps, prevState);\r\n      validateProps(nextProps);\r\n      return null;\r\n    }\r\n\r\n    scrollTo({\r\n      scrollLeft,\r\n      scrollTop,\r\n    }: {\r\n      scrollLeft: number,\r\n      scrollTop: number,\r\n    }): void {\r\n      if (scrollLeft !== undefined) {\r\n        scrollLeft = Math.max(0, scrollLeft);\r\n      }\r\n      if (scrollTop !== undefined) {\r\n        scrollTop = Math.max(0, scrollTop);\r\n      }\r\n\r\n      this.setState(prevState => {\r\n        if (scrollLeft === undefined) {\r\n          scrollLeft = prevState.scrollLeft;\r\n        }\r\n        if (scrollTop === undefined) {\r\n          scrollTop = prevState.scrollTop;\r\n        }\r\n\r\n        if (\r\n          prevState.scrollLeft === scrollLeft &&\r\n          prevState.scrollTop === scrollTop\r\n        ) {\r\n          return null;\r\n        }\r\n\r\n        return {\r\n          horizontalScrollDirection:\r\n            prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\r\n          scrollLeft: scrollLeft,\r\n          scrollTop: scrollTop,\r\n          scrollUpdateWasRequested: true,\r\n          verticalScrollDirection:\r\n            prevState.scrollTop < scrollTop ? 'forward' : 'backward',\r\n        };\r\n      }, this._resetIsScrollingDebounced);\r\n    }\r\n\r\n    scrollToItem({\r\n      align = 'auto',\r\n      columnIndex,\r\n      rowIndex,\r\n    }: {\r\n      align: ScrollToAlign,\r\n      columnIndex?: number,\r\n      rowIndex?: number,\r\n    }): void {\r\n      const { columnCount, height, rowCount, width } = this.props;\r\n      const { scrollLeft, scrollTop } = this.state;\r\n      const scrollbarSize = getScrollbarSize();\r\n\r\n      if (columnIndex !== undefined) {\r\n        columnIndex = Math.max(0, Math.min(columnIndex, columnCount - 1));\r\n      }\r\n      if (rowIndex !== undefined) {\r\n        rowIndex = Math.max(0, Math.min(rowIndex, rowCount - 1));\r\n      }\r\n\r\n      const estimatedTotalHeight = getEstimatedTotalHeight(\r\n        this.props,\r\n        this._instanceProps\r\n      );\r\n      const estimatedTotalWidth = getEstimatedTotalWidth(\r\n        this.props,\r\n        this._instanceProps\r\n      );\r\n\r\n      // The scrollbar size should be considered when scrolling an item into view,\r\n      // to ensure it's fully visible.\r\n      // But we only need to account for its size when it's actually visible.\r\n      const horizontalScrollbarSize =\r\n        estimatedTotalWidth > width ? scrollbarSize : 0;\r\n      const verticalScrollbarSize =\r\n        estimatedTotalHeight > height ? scrollbarSize : 0;\r\n\r\n      this.scrollTo({\r\n        scrollLeft:\r\n          columnIndex !== undefined\r\n            ? getOffsetForColumnAndAlignment(\r\n                this.props,\r\n                columnIndex,\r\n                align,\r\n                scrollLeft,\r\n                this._instanceProps,\r\n                verticalScrollbarSize\r\n              )\r\n            : scrollLeft,\r\n        scrollTop:\r\n          rowIndex !== undefined\r\n            ? getOffsetForRowAndAlignment(\r\n                this.props,\r\n                rowIndex,\r\n                align,\r\n                scrollTop,\r\n                this._instanceProps,\r\n                horizontalScrollbarSize\r\n              )\r\n            : scrollTop,\r\n      });\r\n    }\r\n\r\n    componentDidMount() {\r\n      const { initialScrollLeft, initialScrollTop } = this.props;\r\n\r\n      if (this._outerRef != null) {\r\n        const outerRef = ((this._outerRef: any): HTMLElement);\r\n        if (typeof initialScrollLeft === 'number') {\r\n          outerRef.scrollLeft = initialScrollLeft;\r\n        }\r\n        if (typeof initialScrollTop === 'number') {\r\n          outerRef.scrollTop = initialScrollTop;\r\n        }\r\n      }\r\n\r\n      this._callPropsCallbacks();\r\n    }\r\n\r\n    componentDidUpdate() {\r\n      const { direction } = this.props;\r\n      const { scrollLeft, scrollTop, scrollUpdateWasRequested } = this.state;\r\n\r\n      if (scrollUpdateWasRequested && this._outerRef != null) {\r\n        // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\r\n        // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\r\n        // So we need to determine which browser behavior we're dealing with, and mimic it.\r\n        const outerRef = ((this._outerRef: any): HTMLElement);\r\n        if (direction === 'rtl') {\r\n          switch (getRTLOffsetType()) {\r\n            case 'negative':\r\n              outerRef.scrollLeft = -scrollLeft;\r\n              break;\r\n            case 'positive-ascending':\r\n              outerRef.scrollLeft = scrollLeft;\r\n              break;\r\n            default:\r\n              const { clientWidth, scrollWidth } = outerRef;\r\n              outerRef.scrollLeft = scrollWidth - clientWidth - scrollLeft;\r\n              break;\r\n          }\r\n        } else {\r\n          outerRef.scrollLeft = Math.max(0, scrollLeft);\r\n        }\r\n\r\n        outerRef.scrollTop = Math.max(0, scrollTop);\r\n      }\r\n\r\n      this._callPropsCallbacks();\r\n    }\r\n\r\n    componentWillUnmount() {\r\n      if (this._resetIsScrollingTimeoutId !== null) {\r\n        cancelTimeout(this._resetIsScrollingTimeoutId);\r\n      }\r\n    }\r\n\r\n    render() {\r\n      const {\r\n        children,\r\n        className,\r\n        columnCount,\r\n        direction,\r\n        height,\r\n        innerRef,\r\n        innerElementType,\r\n        innerTagName,\r\n        itemData,\r\n        itemKey = defaultItemKey,\r\n        outerElementType,\r\n        outerTagName,\r\n        rowCount,\r\n        style,\r\n        useIsScrolling,\r\n        width,\r\n        disableColVirtualized,\r\n        disableRowVirtualized\r\n      } = this.props;\r\n      const { isScrolling } = this.state;\r\n\r\n      let [\r\n        columnStartIndex,\r\n        columnStopIndex,\r\n      ] = this._getHorizontalRangeToRender();\r\n      let [rowStartIndex, rowStopIndex] = this._getVerticalRangeToRender();\r\n\r\n      if(disableColVirtualized) columnStartIndex = 0;\r\n      if(disableRowVirtualized) rowStartIndex = 0;\r\n      \r\n      const items = [];\r\n      if (columnCount > 0 && rowCount) {\r\n        for (\r\n          let rowIndex = rowStartIndex;\r\n          rowIndex <= rowStopIndex;\r\n          rowIndex++\r\n        ) {\r\n          for (\r\n            let columnIndex = columnStartIndex;\r\n            columnIndex <= columnStopIndex;\r\n            columnIndex++\r\n          ) {\r\n            items.push(\r\n              createElement(children, {\r\n                columnIndex,\r\n                data: itemData,\r\n                isScrolling: useIsScrolling ? isScrolling : undefined,\r\n                key: itemKey({ columnIndex, data: itemData, rowIndex }),\r\n                rowIndex,\r\n                style: this._getItemStyle(rowIndex, columnIndex),\r\n              })\r\n            );\r\n          }\r\n        }\r\n      }\r\n\r\n      // Read this value AFTER items have been created,\r\n      // So their actual sizes (if variable) are taken into consideration.\r\n      const estimatedTotalHeight = getEstimatedTotalHeight(\r\n        this.props,\r\n        this._instanceProps\r\n      );\r\n      const estimatedTotalWidth = getEstimatedTotalWidth(\r\n        this.props,\r\n        this._instanceProps\r\n      );\r\n\r\n      return createElement(\r\n        outerElementType || outerTagName || 'div',\r\n        {\r\n          className,\r\n          onScroll: this._onScroll,\r\n          ref: this._outerRefSetter,\r\n          style: {\r\n            position: 'relative',\r\n            height,\r\n            width,\r\n            overflow: 'auto',\r\n            WebkitOverflowScrolling: 'touch',\r\n            willChange: 'transform',\r\n            direction,\r\n            ...style,\r\n          },\r\n        },\r\n        createElement(innerElementType || innerTagName || 'div', {\r\n          children: items,\r\n          ref: innerRef,\r\n          style: {\r\n            height: estimatedTotalHeight,\r\n            pointerEvents: isScrolling ? 'none' : undefined,\r\n            width: estimatedTotalWidth,\r\n          },\r\n        })\r\n      );\r\n    }\r\n\r\n    _callOnItemsRendered: (\r\n      overscanColumnStartIndex: number,\r\n      overscanColumnStopIndex: number,\r\n      overscanRowStartIndex: number,\r\n      overscanRowStopIndex: number,\r\n      visibleColumnStartIndex: number,\r\n      visibleColumnStopIndex: number,\r\n      visibleRowStartIndex: number,\r\n      visibleRowStopIndex: number\r\n    ) => void;\r\n    _callOnItemsRendered = memoizeOne(\r\n      (\r\n        overscanColumnStartIndex: number,\r\n        overscanColumnStopIndex: number,\r\n        overscanRowStartIndex: number,\r\n        overscanRowStopIndex: number,\r\n        visibleColumnStartIndex: number,\r\n        visibleColumnStopIndex: number,\r\n        visibleRowStartIndex: number,\r\n        visibleRowStopIndex: number\r\n      ) =>\r\n        ((this.props.onItemsRendered: any): OnItemsRenderedCallback)({\r\n          overscanColumnStartIndex,\r\n          overscanColumnStopIndex,\r\n          overscanRowStartIndex,\r\n          overscanRowStopIndex,\r\n          visibleColumnStartIndex,\r\n          visibleColumnStopIndex,\r\n          visibleRowStartIndex,\r\n          visibleRowStopIndex,\r\n        })\r\n    );\r\n\r\n    _callOnScroll: (\r\n      scrollLeft: number,\r\n      scrollTop: number,\r\n      horizontalScrollDirection: ScrollDirection,\r\n      verticalScrollDirection: ScrollDirection,\r\n      scrollUpdateWasRequested: boolean\r\n    ) => void;\r\n    _callOnScroll = memoizeOne(\r\n      (\r\n        scrollLeft: number,\r\n        scrollTop: number,\r\n        horizontalScrollDirection: ScrollDirection,\r\n        verticalScrollDirection: ScrollDirection,\r\n        scrollUpdateWasRequested: boolean\r\n      ) =>\r\n        ((this.props.onScroll: any): OnScrollCallback)({\r\n          horizontalScrollDirection,\r\n          scrollLeft,\r\n          scrollTop,\r\n          verticalScrollDirection,\r\n          scrollUpdateWasRequested,\r\n        })\r\n    );\r\n\r\n    _callPropsCallbacks() {\r\n      const { columnCount, onItemsRendered, onScroll, rowCount } = this.props;\r\n\r\n      if (typeof onItemsRendered === 'function') {\r\n        if (columnCount > 0 && rowCount > 0) {\r\n          const [\r\n            overscanColumnStartIndex,\r\n            overscanColumnStopIndex,\r\n            visibleColumnStartIndex,\r\n            visibleColumnStopIndex,\r\n          ] = this._getHorizontalRangeToRender();\r\n          const [\r\n            overscanRowStartIndex,\r\n            overscanRowStopIndex,\r\n            visibleRowStartIndex,\r\n            visibleRowStopIndex,\r\n          ] = this._getVerticalRangeToRender();\r\n          this._callOnItemsRendered(\r\n            overscanColumnStartIndex,\r\n            overscanColumnStopIndex,\r\n            overscanRowStartIndex,\r\n            overscanRowStopIndex,\r\n            visibleColumnStartIndex,\r\n            visibleColumnStopIndex,\r\n            visibleRowStartIndex,\r\n            visibleRowStopIndex\r\n          );\r\n        }\r\n      }\r\n\r\n      if (typeof onScroll === 'function') {\r\n        const {\r\n          horizontalScrollDirection,\r\n          scrollLeft,\r\n          scrollTop,\r\n          scrollUpdateWasRequested,\r\n          verticalScrollDirection,\r\n        } = this.state;\r\n        this._callOnScroll(\r\n          scrollLeft,\r\n          scrollTop,\r\n          horizontalScrollDirection,\r\n          verticalScrollDirection,\r\n          scrollUpdateWasRequested\r\n        );\r\n      }\r\n    }\r\n\r\n    // Lazily create and cache item styles while scrolling,\r\n    // So that pure component sCU will prevent re-renders.\r\n    // We maintain this cache, and pass a style prop rather than index,\r\n    // So that List can clear cached styles and force item re-render if necessary.\r\n    _getItemStyle: (rowIndex: number, columnIndex: number) => Object;\r\n    _getItemStyle = (rowIndex: number, columnIndex: number): Object => {\r\n      const { columnWidth, direction, rowHeight } = this.props;\r\n\r\n      const itemStyleCache = this._getItemStyleCache(\r\n        shouldResetStyleCacheOnItemSizeChange && columnWidth,\r\n        shouldResetStyleCacheOnItemSizeChange && direction,\r\n        shouldResetStyleCacheOnItemSizeChange && rowHeight\r\n      );\r\n\r\n      const key = `${rowIndex}:${columnIndex}`;\r\n\r\n      let style;\r\n      if (itemStyleCache.hasOwnProperty(key)) {\r\n        style = itemStyleCache[key];\r\n      } else {\r\n        const offset = getColumnOffset(\r\n          this.props,\r\n          columnIndex,\r\n          this._instanceProps\r\n        );\r\n        const isRtl = direction === 'rtl';\r\n        itemStyleCache[key] = style = {\r\n          position: 'absolute',\r\n          left: isRtl ? undefined : offset,\r\n          right: isRtl ? offset : undefined,\r\n          top: getRowOffset(this.props, rowIndex, this._instanceProps),\r\n          height: getRowHeight(this.props, rowIndex, this._instanceProps),\r\n          width: getColumnWidth(this.props, columnIndex, this._instanceProps),\r\n        };\r\n      }\r\n\r\n      return style;\r\n    };\r\n\r\n    _getItemStyleCache: (_: any, __: any, ___: any) => ItemStyleCache;\r\n    _getItemStyleCache = memoizeOne((_: any, __: any, ___: any) => ({}));\r\n\r\n    _getHorizontalRangeToRender(): [number, number, number, number] {\r\n      const {\r\n        columnCount,\r\n        overscanColumnCount,\r\n        overscanColumnsCount,\r\n        overscanCount,\r\n        rowCount,\r\n      } = this.props;\r\n      const { horizontalScrollDirection, isScrolling, scrollLeft } = this.state;\r\n\r\n      const overscanCountResolved: number =\r\n        overscanColumnCount || overscanColumnsCount || overscanCount || 1;\r\n\r\n      if (columnCount === 0 || rowCount === 0) {\r\n        return [0, 0, 0, 0];\r\n      }\r\n\r\n      const startIndex = getColumnStartIndexForOffset(\r\n        this.props,\r\n        scrollLeft,\r\n        this._instanceProps\r\n      );\r\n      const stopIndex = getColumnStopIndexForStartIndex(\r\n        this.props,\r\n        startIndex,\r\n        scrollLeft,\r\n        this._instanceProps\r\n      );\r\n\r\n      // Overscan by one item in each direction so that tab/focus works.\r\n      // If there isn't at least one extra item, tab loops back around.\r\n      const overscanBackward =\r\n        !isScrolling || horizontalScrollDirection === 'backward'\r\n          ? Math.max(1, overscanCountResolved)\r\n          : 1;\r\n      const overscanForward =\r\n        !isScrolling || horizontalScrollDirection === 'forward'\r\n          ? Math.max(1, overscanCountResolved)\r\n          : 1;\r\n\r\n      return [\r\n        Math.max(0, startIndex - overscanBackward),\r\n        Math.max(0, Math.min(columnCount - 1, stopIndex + overscanForward)),\r\n        startIndex,\r\n        stopIndex,\r\n      ];\r\n    }\r\n\r\n    _getVerticalRangeToRender(): [number, number, number, number] {\r\n      const {\r\n        columnCount,\r\n        overscanCount,\r\n        overscanRowCount,\r\n        overscanRowsCount,\r\n        rowCount,\r\n      } = this.props;\r\n      const { isScrolling, verticalScrollDirection, scrollTop } = this.state;\r\n\r\n      const overscanCountResolved: number =\r\n        overscanRowCount || overscanRowsCount || overscanCount || 1;\r\n\r\n      if (columnCount === 0 || rowCount === 0) {\r\n        return [0, 0, 0, 0];\r\n      }\r\n\r\n      const startIndex = getRowStartIndexForOffset(\r\n        this.props,\r\n        scrollTop,\r\n        this._instanceProps\r\n      );\r\n      const stopIndex = getRowStopIndexForStartIndex(\r\n        this.props,\r\n        startIndex,\r\n        scrollTop,\r\n        this._instanceProps\r\n      );\r\n\r\n      // Overscan by one item in each direction so that tab/focus works.\r\n      // If there isn't at least one extra item, tab loops back around.\r\n      const overscanBackward =\r\n        !isScrolling || verticalScrollDirection === 'backward'\r\n          ? Math.max(1, overscanCountResolved)\r\n          : 1;\r\n      const overscanForward =\r\n        !isScrolling || verticalScrollDirection === 'forward'\r\n          ? Math.max(1, overscanCountResolved)\r\n          : 1;\r\n\r\n      return [\r\n        Math.max(0, startIndex - overscanBackward),\r\n        Math.max(0, Math.min(rowCount - 1, stopIndex + overscanForward)),\r\n        startIndex,\r\n        stopIndex,\r\n      ];\r\n    }\r\n\r\n    _onScroll = (event: ScrollEvent): void => {\r\n      const {\r\n        clientHeight,\r\n        clientWidth,\r\n        scrollLeft,\r\n        scrollTop,\r\n        scrollHeight,\r\n        scrollWidth,\r\n      } = event.currentTarget;\r\n      this.setState(prevState => {\r\n        if (\r\n          prevState.scrollLeft === scrollLeft &&\r\n          prevState.scrollTop === scrollTop\r\n        ) {\r\n          // Scroll position may have been updated by cDM/cDU,\r\n          // In which case we don't need to trigger another render,\r\n          // And we don't want to update state.isScrolling.\r\n          return null;\r\n        }\r\n\r\n        const { direction } = this.props;\r\n\r\n        // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\r\n        // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\r\n        // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\r\n        // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\r\n        let calculatedScrollLeft = scrollLeft;\r\n        if (direction === 'rtl') {\r\n          switch (getRTLOffsetType()) {\r\n            case 'negative':\r\n              calculatedScrollLeft = -scrollLeft;\r\n              break;\r\n            case 'positive-descending':\r\n              calculatedScrollLeft = scrollWidth - clientWidth - scrollLeft;\r\n              break;\r\n          }\r\n        }\r\n\r\n        // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\r\n        calculatedScrollLeft = Math.max(\r\n          0,\r\n          Math.min(calculatedScrollLeft, scrollWidth - clientWidth)\r\n        );\r\n        const calculatedScrollTop = Math.max(\r\n          0,\r\n          Math.min(scrollTop, scrollHeight - clientHeight)\r\n        );\r\n\r\n        return {\r\n          isScrolling: true,\r\n          horizontalScrollDirection:\r\n            prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\r\n          scrollLeft: calculatedScrollLeft,\r\n          scrollTop: calculatedScrollTop,\r\n          verticalScrollDirection:\r\n            prevState.scrollTop < scrollTop ? 'forward' : 'backward',\r\n          scrollUpdateWasRequested: false,\r\n        };\r\n      }, this._resetIsScrollingDebounced);\r\n    };\r\n\r\n    _outerRefSetter = (ref: any): void => {\r\n      const { outerRef } = this.props;\r\n\r\n      this._outerRef = ((ref: any): HTMLDivElement);\r\n\r\n      if (typeof outerRef === 'function') {\r\n        outerRef(ref);\r\n      } else if (\r\n        outerRef != null &&\r\n        typeof outerRef === 'object' &&\r\n        outerRef.hasOwnProperty('current')\r\n      ) {\r\n        outerRef.current = ref;\r\n      }\r\n    };\r\n\r\n    _resetIsScrollingDebounced = () => {\r\n      if (this._resetIsScrollingTimeoutId !== null) {\r\n        cancelTimeout(this._resetIsScrollingTimeoutId);\r\n      }\r\n\r\n      this._resetIsScrollingTimeoutId = requestTimeout(\r\n        this._resetIsScrolling,\r\n        IS_SCROLLING_DEBOUNCE_INTERVAL\r\n      );\r\n    };\r\n\r\n    _resetIsScrolling = () => {\r\n      this._resetIsScrollingTimeoutId = null;\r\n\r\n      this.setState({ isScrolling: false }, () => {\r\n        // Clear style cache after state update has been committed.\r\n        // This way we don't break pure sCU for items that don't use isScrolling param.\r\n        this._getItemStyleCache(-1);\r\n      });\r\n    };\r\n  };\r\n}\r\n\r\nconst validateSharedProps = (\r\n  {\r\n    children,\r\n    direction,\r\n    height,\r\n    innerTagName,\r\n    outerTagName,\r\n    overscanColumnsCount,\r\n    overscanCount,\r\n    overscanRowsCount,\r\n    width,\r\n  }: Props<any>,\r\n  { instance }: State\r\n): void => {\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    if (typeof overscanCount === 'number') {\r\n      if (devWarningsOverscanCount && !devWarningsOverscanCount.has(instance)) {\r\n        devWarningsOverscanCount.add(instance);\r\n        console.warn(\r\n          'The overscanCount prop has been deprecated. ' +\r\n            'Please use the overscanColumnCount and overscanRowCount props instead.'\r\n        );\r\n      }\r\n    }\r\n\r\n    if (\r\n      typeof overscanColumnsCount === 'number' ||\r\n      typeof overscanRowsCount === 'number'\r\n    ) {\r\n      if (\r\n        devWarningsOverscanRowsColumnsCount &&\r\n        !devWarningsOverscanRowsColumnsCount.has(instance)\r\n      ) {\r\n        devWarningsOverscanRowsColumnsCount.add(instance);\r\n        console.warn(\r\n          'The overscanColumnsCount and overscanRowsCount props have been deprecated. ' +\r\n            'Please use the overscanColumnCount and overscanRowCount props instead.'\r\n        );\r\n      }\r\n    }\r\n\r\n    if (innerTagName != null || outerTagName != null) {\r\n      if (devWarningsTagName && !devWarningsTagName.has(instance)) {\r\n        devWarningsTagName.add(instance);\r\n        console.warn(\r\n          'The innerTagName and outerTagName props have been deprecated. ' +\r\n            'Please use the innerElementType and outerElementType props instead.'\r\n        );\r\n      }\r\n    }\r\n\r\n    if (children == null) {\r\n      throw Error(\r\n        'An invalid \"children\" prop has been specified. ' +\r\n          'Value should be a React component. ' +\r\n          `\"${children === null ? 'null' : typeof children}\" was specified.`\r\n      );\r\n    }\r\n\r\n    switch (direction) {\r\n      case 'ltr':\r\n      case 'rtl':\r\n        // Valid values\r\n        break;\r\n      default:\r\n        throw Error(\r\n          'An invalid \"direction\" prop has been specified. ' +\r\n            'Value should be either \"ltr\" or \"rtl\". ' +\r\n            `\"${direction}\" was specified.`\r\n        );\r\n    }\r\n\r\n    if (typeof width !== 'number') {\r\n      throw Error(\r\n        'An invalid \"width\" prop has been specified. ' +\r\n          'Grids must specify a number for width. ' +\r\n          `\"${width === null ? 'null' : typeof width}\" was specified.`\r\n      );\r\n    }\r\n\r\n    if (typeof height !== 'number') {\r\n      throw Error(\r\n        'An invalid \"height\" prop has been specified. ' +\r\n          'Grids must specify a number for height. ' +\r\n          `\"${height === null ? 'null' : typeof height}\" was specified.`\r\n      );\r\n    }\r\n  }\r\n};\r\n","// @flow\r\n\r\nimport createGridComponent from './createGridComponent';\r\n\r\nimport type { Props, ScrollToAlign } from './createGridComponent';\r\n\r\nconst DEFAULT_ESTIMATED_ITEM_SIZE = 50;\r\n\r\ntype VariableSizeProps = {|\r\n  estimatedColumnWidth: number,\r\n  estimatedRowHeight: number,\r\n  disableColVirtualized?: boolean,\r\n  disableRowVirtualized?: boolean,\r\n  ...Props<any>,\r\n|};\r\n\r\ntype itemSizeGetter = (index: number) => number;\r\ntype ItemType = 'column' | 'row';\r\n\r\ntype ItemMetadata = {|\r\n  offset: number,\r\n  size: number,\r\n|};\r\ntype ItemMetadataMap = { [index: number]: ItemMetadata };\r\ntype InstanceProps = {|\r\n  columnMetadataMap: ItemMetadataMap,\r\n  estimatedColumnWidth: number,\r\n  estimatedRowHeight: number,\r\n  lastMeasuredColumnIndex: number,\r\n  lastMeasuredRowIndex: number,\r\n  rowMetadataMap: ItemMetadataMap,\r\n|};\r\n\r\nconst getEstimatedTotalHeight = (\r\n  { rowCount }: Props<any>,\r\n  { rowMetadataMap, estimatedRowHeight, lastMeasuredRowIndex }: InstanceProps\r\n) => {\r\n  let totalSizeOfMeasuredRows = 0;\r\n\r\n  // Edge case check for when the number of items decreases while a scroll is in progress.\r\n  // https://github.com/bvaughn/react-window/pull/138\r\n  if (lastMeasuredRowIndex >= rowCount) {\r\n    lastMeasuredRowIndex = rowCount - 1;\r\n  }\r\n\r\n  if (lastMeasuredRowIndex >= 0) {\r\n    const itemMetadata = rowMetadataMap[lastMeasuredRowIndex];\r\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\r\n  }\r\n\r\n  const numUnmeasuredItems = rowCount - lastMeasuredRowIndex - 1;\r\n  const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedRowHeight;\r\n\r\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\r\n};\r\n\r\nconst getEstimatedTotalWidth = (\r\n  { columnCount }: Props<any>,\r\n  {\r\n    columnMetadataMap,\r\n    estimatedColumnWidth,\r\n    lastMeasuredColumnIndex,\r\n  }: InstanceProps\r\n) => {\r\n  let totalSizeOfMeasuredRows = 0;\r\n\r\n  // Edge case check for when the number of items decreases while a scroll is in progress.\r\n  // https://github.com/bvaughn/react-window/pull/138\r\n  if (lastMeasuredColumnIndex >= columnCount) {\r\n    lastMeasuredColumnIndex = columnCount - 1;\r\n  }\r\n\r\n  if (lastMeasuredColumnIndex >= 0) {\r\n    const itemMetadata = columnMetadataMap[lastMeasuredColumnIndex];\r\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\r\n  }\r\n\r\n  const numUnmeasuredItems = columnCount - lastMeasuredColumnIndex - 1;\r\n  const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedColumnWidth;\r\n\r\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\r\n};\r\n\r\nconst getItemMetadata = (\r\n  itemType: ItemType,\r\n  props: Props<any>,\r\n  index: number,\r\n  instanceProps: InstanceProps\r\n): ItemMetadata => {\r\n  let itemMetadataMap, itemSize, lastMeasuredIndex;\r\n  if (itemType === 'column') {\r\n    itemMetadataMap = instanceProps.columnMetadataMap;\r\n    itemSize = ((props.columnWidth: any): itemSizeGetter);\r\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\r\n  } else {\r\n    itemMetadataMap = instanceProps.rowMetadataMap;\r\n    itemSize = ((props.rowHeight: any): itemSizeGetter);\r\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\r\n  }\r\n\r\n  if (index > lastMeasuredIndex) {\r\n    let offset = 0;\r\n    if (lastMeasuredIndex >= 0) {\r\n      const itemMetadata = itemMetadataMap[lastMeasuredIndex];\r\n      offset = itemMetadata.offset + itemMetadata.size;\r\n    }\r\n\r\n    for (let i = lastMeasuredIndex + 1; i <= index; i++) {\r\n      let size = itemSize(i);\r\n\r\n      itemMetadataMap[i] = {\r\n        offset,\r\n        size,\r\n      };\r\n\r\n      offset += size;\r\n    }\r\n\r\n    if (itemType === 'column') {\r\n      instanceProps.lastMeasuredColumnIndex = index;\r\n    } else {\r\n      instanceProps.lastMeasuredRowIndex = index;\r\n    }\r\n  }\r\n\r\n  return itemMetadataMap[index];\r\n};\r\n\r\nconst findNearestItem = (\r\n  itemType: ItemType,\r\n  props: Props<any>,\r\n  instanceProps: InstanceProps,\r\n  offset: number\r\n) => {\r\n  let itemMetadataMap, lastMeasuredIndex;\r\n  if (itemType === 'column') {\r\n    itemMetadataMap = instanceProps.columnMetadataMap;\r\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\r\n  } else {\r\n    itemMetadataMap = instanceProps.rowMetadataMap;\r\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\r\n  }\r\n\r\n  const lastMeasuredItemOffset =\r\n    lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\r\n\r\n  if (lastMeasuredItemOffset >= offset) {\r\n    // If we've already measured items within this range just use a binary search as it's faster.\r\n    return findNearestItemBinarySearch(\r\n      itemType,\r\n      props,\r\n      instanceProps,\r\n      lastMeasuredIndex,\r\n      0,\r\n      offset\r\n    );\r\n  } else {\r\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\r\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\r\n    // The overall complexity for this approach is O(log n).\r\n    return findNearestItemExponentialSearch(\r\n      itemType,\r\n      props,\r\n      instanceProps,\r\n      Math.max(0, lastMeasuredIndex),\r\n      offset\r\n    );\r\n  }\r\n};\r\n\r\nconst findNearestItemBinarySearch = (\r\n  itemType: ItemType,\r\n  props: Props<any>,\r\n  instanceProps: InstanceProps,\r\n  high: number,\r\n  low: number,\r\n  offset: number\r\n): number => {\r\n  while (low <= high) {\r\n    const middle = low + Math.floor((high - low) / 2);\r\n    const currentOffset = getItemMetadata(\r\n      itemType,\r\n      props,\r\n      middle,\r\n      instanceProps\r\n    ).offset;\r\n\r\n    if (currentOffset === offset) {\r\n      return middle;\r\n    } else if (currentOffset < offset) {\r\n      low = middle + 1;\r\n    } else if (currentOffset > offset) {\r\n      high = middle - 1;\r\n    }\r\n  }\r\n\r\n  if (low > 0) {\r\n    return low - 1;\r\n  } else {\r\n    return 0;\r\n  }\r\n};\r\n\r\nconst findNearestItemExponentialSearch = (\r\n  itemType: ItemType,\r\n  props: Props<any>,\r\n  instanceProps: InstanceProps,\r\n  index: number,\r\n  offset: number\r\n): number => {\r\n  const itemCount = itemType === 'column' ? props.columnCount : props.rowCount;\r\n  let interval = 1;\r\n\r\n  while (\r\n    index < itemCount &&\r\n    getItemMetadata(itemType, props, index, instanceProps).offset < offset\r\n  ) {\r\n    index += interval;\r\n    interval *= 2;\r\n  }\r\n\r\n  return findNearestItemBinarySearch(\r\n    itemType,\r\n    props,\r\n    instanceProps,\r\n    Math.min(index, itemCount - 1),\r\n    Math.floor(index / 2),\r\n    offset\r\n  );\r\n};\r\n\r\nconst getOffsetForIndexAndAlignment = (\r\n  itemType: ItemType,\r\n  props: Props<any>,\r\n  index: number,\r\n  align: ScrollToAlign,\r\n  scrollOffset: number,\r\n  instanceProps: InstanceProps,\r\n  scrollbarSize: number\r\n): number => {\r\n  const size = itemType === 'column' ? props.width : props.height;\r\n  const itemMetadata = getItemMetadata(itemType, props, index, instanceProps);\r\n\r\n  // Get estimated total size after ItemMetadata is computed,\r\n  // To ensure it reflects actual measurements instead of just estimates.\r\n  const estimatedTotalSize =\r\n    itemType === 'column'\r\n      ? getEstimatedTotalWidth(props, instanceProps)\r\n      : getEstimatedTotalHeight(props, instanceProps);\r\n\r\n  const maxOffset = Math.max(\r\n    0,\r\n    Math.min(estimatedTotalSize - size, itemMetadata.offset)\r\n  );\r\n  const minOffset = Math.max(\r\n    0,\r\n    itemMetadata.offset - size + scrollbarSize + itemMetadata.size\r\n  );\r\n\r\n  if (align === 'smart') {\r\n    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\r\n      align = 'auto';\r\n    } else {\r\n      align = 'center';\r\n    }\r\n  }\r\n\r\n  switch (align) {\r\n    case 'start':\r\n      return maxOffset;\r\n    case 'end':\r\n      return minOffset;\r\n    case 'center':\r\n      return Math.round(minOffset + (maxOffset - minOffset) / 2);\r\n    case 'auto':\r\n    default:\r\n      if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\r\n        return scrollOffset;\r\n      } else if (minOffset > maxOffset) {\r\n        // Because we only take into account the scrollbar size when calculating minOffset\r\n        // this value can be larger than maxOffset when at the end of the list\r\n        return minOffset;\r\n      } else if (scrollOffset < minOffset) {\r\n        return minOffset;\r\n      } else {\r\n        return maxOffset;\r\n      }\r\n  }\r\n};\r\n\r\nconst VariableSizeGrid = createGridComponent({\r\n  getColumnOffset: (\r\n    props: Props<any>,\r\n    index: number,\r\n    instanceProps: InstanceProps\r\n  ): number => getItemMetadata('column', props, index, instanceProps).offset,\r\n\r\n  getColumnStartIndexForOffset: (\r\n    props: Props<any>,\r\n    scrollLeft: number,\r\n    instanceProps: InstanceProps\r\n  ): number => findNearestItem('column', props, instanceProps, scrollLeft),\r\n\r\n  getColumnStopIndexForStartIndex: (\r\n    props: Props<any>,\r\n    startIndex: number,\r\n    scrollLeft: number,\r\n    instanceProps: InstanceProps\r\n  ): number => {\r\n    const { columnCount, width } = props;\r\n\r\n    const itemMetadata = getItemMetadata(\r\n      'column',\r\n      props,\r\n      startIndex,\r\n      instanceProps\r\n    );\r\n    const maxOffset = scrollLeft + width;\r\n\r\n    let offset = itemMetadata.offset + itemMetadata.size;\r\n    let stopIndex = startIndex;\r\n\r\n    while (stopIndex < columnCount - 1 && offset < maxOffset) {\r\n      stopIndex++;\r\n      offset += getItemMetadata('column', props, stopIndex, instanceProps).size;\r\n    }\r\n\r\n    return stopIndex;\r\n  },\r\n\r\n  getColumnWidth: (\r\n    props: Props<any>,\r\n    index: number,\r\n    instanceProps: InstanceProps\r\n  ): number => instanceProps.columnMetadataMap[index].size,\r\n\r\n  getEstimatedTotalHeight,\r\n  getEstimatedTotalWidth,\r\n\r\n  getOffsetForColumnAndAlignment: (\r\n    props: Props<any>,\r\n    index: number,\r\n    align: ScrollToAlign,\r\n    scrollOffset: number,\r\n    instanceProps: InstanceProps,\r\n    scrollbarSize: number\r\n  ): number =>\r\n    getOffsetForIndexAndAlignment(\r\n      'column',\r\n      props,\r\n      index,\r\n      align,\r\n      scrollOffset,\r\n      instanceProps,\r\n      scrollbarSize\r\n    ),\r\n\r\n  getOffsetForRowAndAlignment: (\r\n    props: Props<any>,\r\n    index: number,\r\n    align: ScrollToAlign,\r\n    scrollOffset: number,\r\n    instanceProps: InstanceProps,\r\n    scrollbarSize: number\r\n  ): number =>\r\n    getOffsetForIndexAndAlignment(\r\n      'row',\r\n      props,\r\n      index,\r\n      align,\r\n      scrollOffset,\r\n      instanceProps,\r\n      scrollbarSize\r\n    ),\r\n\r\n  getRowOffset: (\r\n    props: Props<any>,\r\n    index: number,\r\n    instanceProps: InstanceProps\r\n  ): number => getItemMetadata('row', props, index, instanceProps).offset,\r\n\r\n  getRowHeight: (\r\n    props: Props<any>,\r\n    index: number,\r\n    instanceProps: InstanceProps\r\n  ): number => instanceProps.rowMetadataMap[index].size,\r\n\r\n  getRowStartIndexForOffset: (\r\n    props: Props<any>,\r\n    scrollTop: number,\r\n    instanceProps: InstanceProps\r\n  ): number => findNearestItem('row', props, instanceProps, scrollTop),\r\n\r\n  getRowStopIndexForStartIndex: (\r\n    props: Props<any>,\r\n    startIndex: number,\r\n    scrollTop: number,\r\n    instanceProps: InstanceProps\r\n  ): number => {\r\n    const { rowCount, height } = props;\r\n\r\n    const itemMetadata = getItemMetadata(\r\n      'row',\r\n      props,\r\n      startIndex,\r\n      instanceProps\r\n    );\r\n    const maxOffset = scrollTop + height;\r\n\r\n    let offset = itemMetadata.offset + itemMetadata.size;\r\n    let stopIndex = startIndex;\r\n\r\n    while (stopIndex < rowCount - 1 && offset < maxOffset) {\r\n      stopIndex++;\r\n      offset += getItemMetadata('row', props, stopIndex, instanceProps).size;\r\n    }\r\n\r\n    return stopIndex;\r\n  },\r\n\r\n  initInstanceProps(props: Props<any>, instance: any): InstanceProps {\r\n    const {\r\n      estimatedColumnWidth,\r\n      estimatedRowHeight,\r\n    } = ((props: any): VariableSizeProps);\r\n\r\n    const instanceProps = {\r\n      columnMetadataMap: {},\r\n      estimatedColumnWidth: estimatedColumnWidth || DEFAULT_ESTIMATED_ITEM_SIZE,\r\n      estimatedRowHeight: estimatedRowHeight || DEFAULT_ESTIMATED_ITEM_SIZE,\r\n      lastMeasuredColumnIndex: -1,\r\n      lastMeasuredRowIndex: -1,\r\n      rowMetadataMap: {},\r\n    };\r\n\r\n    instance.resetAfterColumnIndex = (\r\n      columnIndex: number,\r\n      shouldForceUpdate?: boolean = true\r\n    ) => {\r\n      instance.resetAfterIndices({ columnIndex, shouldForceUpdate });\r\n    };\r\n\r\n    instance.resetAfterRowIndex = (\r\n      rowIndex: number,\r\n      shouldForceUpdate?: boolean = true\r\n    ) => {\r\n      instance.resetAfterIndices({ rowIndex, shouldForceUpdate });\r\n    };\r\n\r\n    instance.resetAfterIndices = ({\r\n      columnIndex,\r\n      rowIndex,\r\n      shouldForceUpdate = true,\r\n    }: {\r\n      columnIndex?: number,\r\n      rowIndex?: number,\r\n      shouldForceUpdate: boolean,\r\n    }) => {\r\n      if (typeof columnIndex === 'number') {\r\n        instanceProps.lastMeasuredColumnIndex = Math.min(\r\n          instanceProps.lastMeasuredColumnIndex,\r\n          columnIndex - 1\r\n        );\r\n      }\r\n      if (typeof rowIndex === 'number') {\r\n        instanceProps.lastMeasuredRowIndex = Math.min(\r\n          instanceProps.lastMeasuredRowIndex,\r\n          rowIndex - 1\r\n        );\r\n      }\r\n\r\n      // We could potentially optimize further by only evicting styles after this index,\r\n      // But since styles are only cached while scrolling is in progress-\r\n      // It seems an unnecessary optimization.\r\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\r\n      instance._getItemStyleCache(-1);\r\n\r\n      if (shouldForceUpdate) {\r\n        instance.forceUpdate();\r\n      }\r\n    };\r\n\r\n    return instanceProps;\r\n  },\r\n\r\n  shouldResetStyleCacheOnItemSizeChange: false,\r\n\r\n  validateProps: ({ columnWidth, rowHeight }: Props<any>): void => {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      if (typeof columnWidth !== 'function') {\r\n        throw Error(\r\n          'An invalid \"columnWidth\" prop has been specified. ' +\r\n            'Value should be a function. ' +\r\n            `\"${\r\n              columnWidth === null ? 'null' : typeof columnWidth\r\n            }\" was specified.`\r\n        );\r\n      } else if (typeof rowHeight !== 'function') {\r\n        throw Error(\r\n          'An invalid \"rowHeight\" prop has been specified. ' +\r\n            'Value should be a function. ' +\r\n            `\"${rowHeight === null ? 'null' : typeof rowHeight}\" was specified.`\r\n        );\r\n      }\r\n    }\r\n  },\r\n});\r\n\r\nexport default VariableSizeGrid;\r\n","// @flow\r\n\r\nimport memoizeOne from 'memoize-one';\r\nimport { createElement, PureComponent } from 'react';\r\nimport { cancelTimeout, requestTimeout } from './timer';\r\nimport { getScrollbarSize, getRTLOffsetType } from './domHelpers';\r\n\r\nimport type { TimeoutID } from './timer';\r\n\r\nexport type ScrollToAlign = 'auto' | 'smart' | 'center' | 'start' | 'end';\r\n\r\ntype itemSize = number | ((index: number) => number);\r\n// TODO Deprecate directions \"horizontal\" and \"vertical\"\r\ntype Direction = 'ltr' | 'rtl' | 'horizontal' | 'vertical';\r\ntype Layout = 'horizontal' | 'vertical';\r\n\r\ntype RenderComponentProps<T> = {|\r\n  data: T,\r\n  index: number,\r\n  isScrolling?: boolean,\r\n  style: Object,\r\n|};\r\ntype RenderComponent<T> = React$ComponentType<$Shape<RenderComponentProps<T>>>;\r\n\r\ntype ScrollDirection = 'forward' | 'backward';\r\n\r\ntype onItemsRenderedCallback = ({\r\n  overscanStartIndex: number,\r\n  overscanStopIndex: number,\r\n  visibleStartIndex: number,\r\n  visibleStopIndex: number,\r\n}) => void;\r\ntype onScrollCallback = ({\r\n  scrollDirection: ScrollDirection,\r\n  scrollOffset: number,\r\n  scrollUpdateWasRequested: boolean,\r\n}) => void;\r\n\r\ntype ScrollEvent = SyntheticEvent<HTMLDivElement>;\r\ntype ItemStyleCache = { [index: number]: Object };\r\n\r\ntype OuterProps = {|\r\n  children: React$Node,\r\n  className: string | void,\r\n  onScroll: ScrollEvent => void,\r\n  style: {\r\n    [string]: mixed,\r\n  },\r\n|};\r\n\r\ntype InnerProps = {|\r\n  children: React$Node,\r\n  style: {\r\n    [string]: mixed,\r\n  },\r\n|};\r\n\r\nexport type Props<T> = {|\r\n  children: RenderComponent<T>,\r\n  className?: string,\r\n  direction: Direction,\r\n  height: number | string,\r\n  initialScrollOffset?: number,\r\n  innerRef?: any,\r\n  innerElementType?: string | React$AbstractComponent<InnerProps, any>,\r\n  innerTagName?: string, // deprecated\r\n  itemCount: number,\r\n  itemData: T,\r\n  itemKey?: (index: number, data: T) => any,\r\n  itemSize: itemSize,\r\n  layout: Layout,\r\n  onItemsRendered?: onItemsRenderedCallback,\r\n  onScroll?: onScrollCallback,\r\n  outerRef?: any,\r\n  outerElementType?: string | React$AbstractComponent<OuterProps, any>,\r\n  outerTagName?: string, // deprecated\r\n  overscanCount: number,\r\n  style?: Object,\r\n  useIsScrolling: boolean,\r\n  width: number | string,\r\n|};\r\n\r\ntype State = {|\r\n  instance: any,\r\n  isScrolling: boolean,\r\n  scrollDirection: ScrollDirection,\r\n  scrollOffset: number,\r\n  scrollUpdateWasRequested: boolean,\r\n|};\r\n\r\ntype GetItemOffset = (\r\n  props: Props<any>,\r\n  index: number,\r\n  instanceProps: any\r\n) => number;\r\ntype GetItemSize = (\r\n  props: Props<any>,\r\n  index: number,\r\n  instanceProps: any\r\n) => number;\r\ntype GetEstimatedTotalSize = (props: Props<any>, instanceProps: any) => number;\r\ntype GetOffsetForIndexAndAlignment = (\r\n  props: Props<any>,\r\n  index: number,\r\n  align: ScrollToAlign,\r\n  scrollOffset: number,\r\n  instanceProps: any\r\n) => number;\r\ntype GetStartIndexForOffset = (\r\n  props: Props<any>,\r\n  offset: number,\r\n  instanceProps: any\r\n) => number;\r\ntype GetStopIndexForStartIndex = (\r\n  props: Props<any>,\r\n  startIndex: number,\r\n  scrollOffset: number,\r\n  instanceProps: any\r\n) => number;\r\ntype InitInstanceProps = (props: Props<any>, instance: any) => any;\r\ntype ValidateProps = (props: Props<any>) => void;\r\n\r\nconst IS_SCROLLING_DEBOUNCE_INTERVAL = 150;\r\n\r\nconst defaultItemKey = (index: number, data: any) => index;\r\n\r\n// In DEV mode, this Set helps us only log a warning once per component instance.\r\n// This avoids spamming the console every time a render happens.\r\nlet devWarningsDirection = null;\r\nlet devWarningsTagName = null;\r\nif (process.env.NODE_ENV !== 'production') {\r\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\r\n    devWarningsDirection = new WeakSet();\r\n    devWarningsTagName = new WeakSet();\r\n  }\r\n}\r\n\r\nexport default function createListComponent({\r\n  getItemOffset,\r\n  getEstimatedTotalSize,\r\n  getItemSize,\r\n  getOffsetForIndexAndAlignment,\r\n  getStartIndexForOffset,\r\n  getStopIndexForStartIndex,\r\n  initInstanceProps,\r\n  shouldResetStyleCacheOnItemSizeChange,\r\n  validateProps,\r\n}: {|\r\n  getItemOffset: GetItemOffset,\r\n  getEstimatedTotalSize: GetEstimatedTotalSize,\r\n  getItemSize: GetItemSize,\r\n  getOffsetForIndexAndAlignment: GetOffsetForIndexAndAlignment,\r\n  getStartIndexForOffset: GetStartIndexForOffset,\r\n  getStopIndexForStartIndex: GetStopIndexForStartIndex,\r\n  initInstanceProps: InitInstanceProps,\r\n  shouldResetStyleCacheOnItemSizeChange: boolean,\r\n  validateProps: ValidateProps,\r\n|}) {\r\n  return class List<T> extends PureComponent<Props<T>, State> {\r\n    _instanceProps: any = initInstanceProps(this.props, this);\r\n    _outerRef: ?HTMLDivElement;\r\n    _resetIsScrollingTimeoutId: TimeoutID | null = null;\r\n\r\n    static defaultProps = {\r\n      direction: 'ltr',\r\n      itemData: undefined,\r\n      layout: 'vertical',\r\n      overscanCount: 2,\r\n      useIsScrolling: false,\r\n    };\r\n\r\n    state: State = {\r\n      instance: this,\r\n      isScrolling: false,\r\n      scrollDirection: 'forward',\r\n      scrollOffset:\r\n        typeof this.props.initialScrollOffset === 'number'\r\n          ? this.props.initialScrollOffset\r\n          : 0,\r\n      scrollUpdateWasRequested: false,\r\n    };\r\n\r\n    // Always use explicit constructor for React components.\r\n    // It produces less code after transpilation. (#26)\r\n    // eslint-disable-next-line no-useless-constructor\r\n    constructor(props: Props<T>) {\r\n      super(props);\r\n    }\r\n\r\n    static getDerivedStateFromProps(\r\n      nextProps: Props<T>,\r\n      prevState: State\r\n    ): $Shape<State> | null {\r\n      validateSharedProps(nextProps, prevState);\r\n      validateProps(nextProps);\r\n      return null;\r\n    }\r\n\r\n    scrollTo(scrollOffset: number): void {\r\n      scrollOffset = Math.max(0, scrollOffset);\r\n\r\n      this.setState(prevState => {\r\n        if (prevState.scrollOffset === scrollOffset) {\r\n          return null;\r\n        }\r\n        return {\r\n          scrollDirection:\r\n            prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\r\n          scrollOffset: scrollOffset,\r\n          scrollUpdateWasRequested: true,\r\n        };\r\n      }, this._resetIsScrollingDebounced);\r\n    }\r\n\r\n    scrollToItem(index: number, align: ScrollToAlign = 'auto'): void {\r\n      const { itemCount, layout } = this.props;\r\n      const { scrollOffset } = this.state;\r\n\r\n      index = Math.max(0, Math.min(index, itemCount - 1));\r\n\r\n      // The scrollbar size should be considered when scrolling an item into view, to ensure it's fully visible.\r\n      // But we only need to account for its size when it's actually visible.\r\n      // This is an edge case for lists; normally they only scroll in the dominant direction.\r\n      let scrollbarSize = 0;\r\n      if (this._outerRef) {\r\n        const outerRef = ((this._outerRef: any): HTMLElement);\r\n        if (layout === 'vertical') {\r\n          scrollbarSize =\r\n            outerRef.scrollWidth > outerRef.clientWidth\r\n              ? getScrollbarSize()\r\n              : 0;\r\n        } else {\r\n          scrollbarSize =\r\n            outerRef.scrollHeight > outerRef.clientHeight\r\n              ? getScrollbarSize()\r\n              : 0;\r\n        }\r\n      }\r\n\r\n      this.scrollTo(\r\n        getOffsetForIndexAndAlignment(\r\n          this.props,\r\n          index,\r\n          align,\r\n          scrollOffset,\r\n          this._instanceProps,\r\n          scrollbarSize\r\n        )\r\n      );\r\n    }\r\n\r\n    componentDidMount() {\r\n      const { direction, initialScrollOffset, layout } = this.props;\r\n\r\n      if (typeof initialScrollOffset === 'number' && this._outerRef != null) {\r\n        const outerRef = ((this._outerRef: any): HTMLElement);\r\n        // TODO Deprecate direction \"horizontal\"\r\n        if (direction === 'horizontal' || layout === 'horizontal') {\r\n          outerRef.scrollLeft = initialScrollOffset;\r\n        } else {\r\n          outerRef.scrollTop = initialScrollOffset;\r\n        }\r\n      }\r\n\r\n      this._callPropsCallbacks();\r\n    }\r\n\r\n    componentDidUpdate() {\r\n      const { direction, layout } = this.props;\r\n      const { scrollOffset, scrollUpdateWasRequested } = this.state;\r\n\r\n      if (scrollUpdateWasRequested && this._outerRef != null) {\r\n        const outerRef = ((this._outerRef: any): HTMLElement);\r\n\r\n        // TODO Deprecate direction \"horizontal\"\r\n        if (direction === 'horizontal' || layout === 'horizontal') {\r\n          if (direction === 'rtl') {\r\n            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\r\n            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\r\n            // So we need to determine which browser behavior we're dealing with, and mimic it.\r\n            switch (getRTLOffsetType()) {\r\n              case 'negative':\r\n                outerRef.scrollLeft = -scrollOffset;\r\n                break;\r\n              case 'positive-ascending':\r\n                outerRef.scrollLeft = scrollOffset;\r\n                break;\r\n              default:\r\n                const { clientWidth, scrollWidth } = outerRef;\r\n                outerRef.scrollLeft = scrollWidth - clientWidth - scrollOffset;\r\n                break;\r\n            }\r\n          } else {\r\n            outerRef.scrollLeft = scrollOffset;\r\n          }\r\n        } else {\r\n          outerRef.scrollTop = scrollOffset;\r\n        }\r\n      }\r\n\r\n      this._callPropsCallbacks();\r\n    }\r\n\r\n    componentWillUnmount() {\r\n      if (this._resetIsScrollingTimeoutId !== null) {\r\n        cancelTimeout(this._resetIsScrollingTimeoutId);\r\n      }\r\n    }\r\n\r\n    render() {\r\n      const {\r\n        children,\r\n        className,\r\n        direction,\r\n        height,\r\n        innerRef,\r\n        innerElementType,\r\n        innerTagName,\r\n        itemCount,\r\n        itemData,\r\n        itemKey = defaultItemKey,\r\n        layout,\r\n        outerElementType,\r\n        outerTagName,\r\n        style,\r\n        useIsScrolling,\r\n        width,\r\n      } = this.props;\r\n      const { isScrolling } = this.state;\r\n\r\n      // TODO Deprecate direction \"horizontal\"\r\n      const isHorizontal =\r\n        direction === 'horizontal' || layout === 'horizontal';\r\n\r\n      const onScroll = isHorizontal\r\n        ? this._onScrollHorizontal\r\n        : this._onScrollVertical;\r\n\r\n      const [startIndex, stopIndex] = this._getRangeToRender();\r\n\r\n      const items = [];\r\n      if (itemCount > 0) {\r\n        for (let index = startIndex; index <= stopIndex; index++) {\r\n          items.push(\r\n            createElement(children, {\r\n              data: itemData,\r\n              key: itemKey(index, itemData),\r\n              index,\r\n              isScrolling: useIsScrolling ? isScrolling : undefined,\r\n              style: this._getItemStyle(index),\r\n            })\r\n          );\r\n        }\r\n      }\r\n\r\n      // Read this value AFTER items have been created,\r\n      // So their actual sizes (if variable) are taken into consideration.\r\n      const estimatedTotalSize = getEstimatedTotalSize(\r\n        this.props,\r\n        this._instanceProps\r\n      );\r\n\r\n      return createElement(\r\n        outerElementType || outerTagName || 'div',\r\n        {\r\n          className,\r\n          onScroll,\r\n          ref: this._outerRefSetter,\r\n          style: {\r\n            position: 'relative',\r\n            height,\r\n            width,\r\n            overflow: 'auto',\r\n            WebkitOverflowScrolling: 'touch',\r\n            willChange: 'transform',\r\n            direction,\r\n            ...style,\r\n          },\r\n        },\r\n        createElement(innerElementType || innerTagName || 'div', {\r\n          children: items,\r\n          ref: innerRef,\r\n          style: {\r\n            height: isHorizontal ? '100%' : estimatedTotalSize,\r\n            pointerEvents: isScrolling ? 'none' : undefined,\r\n            width: isHorizontal ? estimatedTotalSize : '100%',\r\n          },\r\n        })\r\n      );\r\n    }\r\n\r\n    _callOnItemsRendered: (\r\n      overscanStartIndex: number,\r\n      overscanStopIndex: number,\r\n      visibleStartIndex: number,\r\n      visibleStopIndex: number\r\n    ) => void;\r\n    _callOnItemsRendered = memoizeOne(\r\n      (\r\n        overscanStartIndex: number,\r\n        overscanStopIndex: number,\r\n        visibleStartIndex: number,\r\n        visibleStopIndex: number\r\n      ) =>\r\n        ((this.props.onItemsRendered: any): onItemsRenderedCallback)({\r\n          overscanStartIndex,\r\n          overscanStopIndex,\r\n          visibleStartIndex,\r\n          visibleStopIndex,\r\n        })\r\n    );\r\n\r\n    _callOnScroll: (\r\n      scrollDirection: ScrollDirection,\r\n      scrollOffset: number,\r\n      scrollUpdateWasRequested: boolean\r\n    ) => void;\r\n    _callOnScroll = memoizeOne(\r\n      (\r\n        scrollDirection: ScrollDirection,\r\n        scrollOffset: number,\r\n        scrollUpdateWasRequested: boolean\r\n      ) =>\r\n        ((this.props.onScroll: any): onScrollCallback)({\r\n          scrollDirection,\r\n          scrollOffset,\r\n          scrollUpdateWasRequested,\r\n        })\r\n    );\r\n\r\n    _callPropsCallbacks() {\r\n      if (typeof this.props.onItemsRendered === 'function') {\r\n        const { itemCount } = this.props;\r\n        if (itemCount > 0) {\r\n          const [\r\n            overscanStartIndex,\r\n            overscanStopIndex,\r\n            visibleStartIndex,\r\n            visibleStopIndex,\r\n          ] = this._getRangeToRender();\r\n          this._callOnItemsRendered(\r\n            overscanStartIndex,\r\n            overscanStopIndex,\r\n            visibleStartIndex,\r\n            visibleStopIndex\r\n          );\r\n        }\r\n      }\r\n\r\n      if (typeof this.props.onScroll === 'function') {\r\n        const {\r\n          scrollDirection,\r\n          scrollOffset,\r\n          scrollUpdateWasRequested,\r\n        } = this.state;\r\n        this._callOnScroll(\r\n          scrollDirection,\r\n          scrollOffset,\r\n          scrollUpdateWasRequested\r\n        );\r\n      }\r\n    }\r\n\r\n    // Lazily create and cache item styles while scrolling,\r\n    // So that pure component sCU will prevent re-renders.\r\n    // We maintain this cache, and pass a style prop rather than index,\r\n    // So that List can clear cached styles and force item re-render if necessary.\r\n    _getItemStyle: (index: number) => Object;\r\n    _getItemStyle = (index: number): Object => {\r\n      const { direction, itemSize, layout } = this.props;\r\n\r\n      const itemStyleCache = this._getItemStyleCache(\r\n        shouldResetStyleCacheOnItemSizeChange && itemSize,\r\n        shouldResetStyleCacheOnItemSizeChange && layout,\r\n        shouldResetStyleCacheOnItemSizeChange && direction\r\n      );\r\n\r\n      let style;\r\n      if (itemStyleCache.hasOwnProperty(index)) {\r\n        style = itemStyleCache[index];\r\n      } else {\r\n        const offset = getItemOffset(this.props, index, this._instanceProps);\r\n        const size = getItemSize(this.props, index, this._instanceProps);\r\n\r\n        // TODO Deprecate direction \"horizontal\"\r\n        const isHorizontal =\r\n          direction === 'horizontal' || layout === 'horizontal';\r\n\r\n        const isRtl = direction === 'rtl';\r\n        const offsetHorizontal = isHorizontal ? offset : 0;\r\n        itemStyleCache[index] = style = {\r\n          position: 'absolute',\r\n          left: isRtl ? undefined : offsetHorizontal,\r\n          right: isRtl ? offsetHorizontal : undefined,\r\n          top: !isHorizontal ? offset : 0,\r\n          height: !isHorizontal ? size : '100%',\r\n          width: isHorizontal ? size : '100%',\r\n        };\r\n      }\r\n\r\n      return style;\r\n    };\r\n\r\n    _getItemStyleCache: (_: any, __: any, ___: any) => ItemStyleCache;\r\n    _getItemStyleCache = memoizeOne((_: any, __: any, ___: any) => ({}));\r\n\r\n    _getRangeToRender(): [number, number, number, number] {\r\n      const { itemCount, overscanCount } = this.props;\r\n      const { isScrolling, scrollDirection, scrollOffset } = this.state;\r\n\r\n      if (itemCount === 0) {\r\n        return [0, 0, 0, 0];\r\n      }\r\n\r\n      const startIndex = getStartIndexForOffset(\r\n        this.props,\r\n        scrollOffset,\r\n        this._instanceProps\r\n      );\r\n      const stopIndex = getStopIndexForStartIndex(\r\n        this.props,\r\n        startIndex,\r\n        scrollOffset,\r\n        this._instanceProps\r\n      );\r\n\r\n      // Overscan by one item in each direction so that tab/focus works.\r\n      // If there isn't at least one extra item, tab loops back around.\r\n      const overscanBackward =\r\n        !isScrolling || scrollDirection === 'backward'\r\n          ? Math.max(1, overscanCount)\r\n          : 1;\r\n      const overscanForward =\r\n        !isScrolling || scrollDirection === 'forward'\r\n          ? Math.max(1, overscanCount)\r\n          : 1;\r\n\r\n      return [\r\n        Math.max(0, startIndex - overscanBackward),\r\n        Math.max(0, Math.min(itemCount - 1, stopIndex + overscanForward)),\r\n        startIndex,\r\n        stopIndex,\r\n      ];\r\n    }\r\n\r\n    _onScrollHorizontal = (event: ScrollEvent): void => {\r\n      const { clientWidth, scrollLeft, scrollWidth } = event.currentTarget;\r\n      this.setState(prevState => {\r\n        if (prevState.scrollOffset === scrollLeft) {\r\n          // Scroll position may have been updated by cDM/cDU,\r\n          // In which case we don't need to trigger another render,\r\n          // And we don't want to update state.isScrolling.\r\n          return null;\r\n        }\r\n\r\n        const { direction } = this.props;\r\n\r\n        let scrollOffset = scrollLeft;\r\n        if (direction === 'rtl') {\r\n          // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\r\n          // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\r\n          // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\r\n          // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\r\n          switch (getRTLOffsetType()) {\r\n            case 'negative':\r\n              scrollOffset = -scrollLeft;\r\n              break;\r\n            case 'positive-descending':\r\n              scrollOffset = scrollWidth - clientWidth - scrollLeft;\r\n              break;\r\n          }\r\n        }\r\n\r\n        // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\r\n        scrollOffset = Math.max(\r\n          0,\r\n          Math.min(scrollOffset, scrollWidth - clientWidth)\r\n        );\r\n\r\n        return {\r\n          isScrolling: true,\r\n          scrollDirection:\r\n            prevState.scrollOffset < scrollLeft ? 'forward' : 'backward',\r\n          scrollOffset,\r\n          scrollUpdateWasRequested: false,\r\n        };\r\n      }, this._resetIsScrollingDebounced);\r\n    };\r\n\r\n    _onScrollVertical = (event: ScrollEvent): void => {\r\n      const { clientHeight, scrollHeight, scrollTop } = event.currentTarget;\r\n      this.setState(prevState => {\r\n        if (prevState.scrollOffset === scrollTop) {\r\n          // Scroll position may have been updated by cDM/cDU,\r\n          // In which case we don't need to trigger another render,\r\n          // And we don't want to update state.isScrolling.\r\n          return null;\r\n        }\r\n\r\n        // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\r\n        const scrollOffset = Math.max(\r\n          0,\r\n          Math.min(scrollTop, scrollHeight - clientHeight)\r\n        );\r\n\r\n        return {\r\n          isScrolling: true,\r\n          scrollDirection:\r\n            prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\r\n          scrollOffset,\r\n          scrollUpdateWasRequested: false,\r\n        };\r\n      }, this._resetIsScrollingDebounced);\r\n    };\r\n\r\n    _outerRefSetter = (ref: any): void => {\r\n      const { outerRef } = this.props;\r\n\r\n      this._outerRef = ((ref: any): HTMLDivElement);\r\n\r\n      if (typeof outerRef === 'function') {\r\n        outerRef(ref);\r\n      } else if (\r\n        outerRef != null &&\r\n        typeof outerRef === 'object' &&\r\n        outerRef.hasOwnProperty('current')\r\n      ) {\r\n        outerRef.current = ref;\r\n      }\r\n    };\r\n\r\n    _resetIsScrollingDebounced = () => {\r\n      if (this._resetIsScrollingTimeoutId !== null) {\r\n        cancelTimeout(this._resetIsScrollingTimeoutId);\r\n      }\r\n\r\n      this._resetIsScrollingTimeoutId = requestTimeout(\r\n        this._resetIsScrolling,\r\n        IS_SCROLLING_DEBOUNCE_INTERVAL\r\n      );\r\n    };\r\n\r\n    _resetIsScrolling = () => {\r\n      this._resetIsScrollingTimeoutId = null;\r\n\r\n      this.setState({ isScrolling: false }, () => {\r\n        // Clear style cache after state update has been committed.\r\n        // This way we don't break pure sCU for items that don't use isScrolling param.\r\n        this._getItemStyleCache(-1, null);\r\n      });\r\n    };\r\n  };\r\n}\r\n\r\n// NOTE: I considered further wrapping individual items with a pure ListItem component.\r\n// This would avoid ever calling the render function for the same index more than once,\r\n// But it would also add the overhead of a lot of components/fibers.\r\n// I assume people already do this (render function returning a class component),\r\n// So my doing it would just unnecessarily double the wrappers.\r\n\r\nconst validateSharedProps = (\r\n  {\r\n    children,\r\n    direction,\r\n    height,\r\n    layout,\r\n    innerTagName,\r\n    outerTagName,\r\n    width,\r\n  }: Props<any>,\r\n  { instance }: State\r\n): void => {\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    if (innerTagName != null || outerTagName != null) {\r\n      if (devWarningsTagName && !devWarningsTagName.has(instance)) {\r\n        devWarningsTagName.add(instance);\r\n        console.warn(\r\n          'The innerTagName and outerTagName props have been deprecated. ' +\r\n            'Please use the innerElementType and outerElementType props instead.'\r\n        );\r\n      }\r\n    }\r\n\r\n    // TODO Deprecate direction \"horizontal\"\r\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\r\n\r\n    switch (direction) {\r\n      case 'horizontal':\r\n      case 'vertical':\r\n        if (devWarningsDirection && !devWarningsDirection.has(instance)) {\r\n          devWarningsDirection.add(instance);\r\n          console.warn(\r\n            'The direction prop should be either \"ltr\" (default) or \"rtl\". ' +\r\n              'Please use the layout prop to specify \"vertical\" (default) or \"horizontal\" orientation.'\r\n          );\r\n        }\r\n        break;\r\n      case 'ltr':\r\n      case 'rtl':\r\n        // Valid values\r\n        break;\r\n      default:\r\n        throw Error(\r\n          'An invalid \"direction\" prop has been specified. ' +\r\n            'Value should be either \"ltr\" or \"rtl\". ' +\r\n            `\"${direction}\" was specified.`\r\n        );\r\n    }\r\n\r\n    switch (layout) {\r\n      case 'horizontal':\r\n      case 'vertical':\r\n        // Valid values\r\n        break;\r\n      default:\r\n        throw Error(\r\n          'An invalid \"layout\" prop has been specified. ' +\r\n            'Value should be either \"horizontal\" or \"vertical\". ' +\r\n            `\"${layout}\" was specified.`\r\n        );\r\n    }\r\n\r\n    if (children == null) {\r\n      throw Error(\r\n        'An invalid \"children\" prop has been specified. ' +\r\n          'Value should be a React component. ' +\r\n          `\"${children === null ? 'null' : typeof children}\" was specified.`\r\n      );\r\n    }\r\n\r\n    if (isHorizontal && typeof width !== 'number') {\r\n      throw Error(\r\n        'An invalid \"width\" prop has been specified. ' +\r\n          'Horizontal lists must specify a number for width. ' +\r\n          `\"${width === null ? 'null' : typeof width}\" was specified.`\r\n      );\r\n    } else if (!isHorizontal && typeof height !== 'number') {\r\n      throw Error(\r\n        'An invalid \"height\" prop has been specified. ' +\r\n          'Vertical lists must specify a number for height. ' +\r\n          `\"${height === null ? 'null' : typeof height}\" was specified.`\r\n      );\r\n    }\r\n  }\r\n};\r\n","// @flow\r\n\r\nimport createListComponent from './createListComponent';\r\n\r\nimport type { Props, ScrollToAlign } from './createListComponent';\r\n\r\nconst DEFAULT_ESTIMATED_ITEM_SIZE = 50;\r\n\r\ntype VariableSizeProps = {|\r\n  estimatedItemSize: number,\r\n  ...Props<any>,\r\n|};\r\n\r\ntype itemSizeGetter = (index: number) => number;\r\n\r\ntype ItemMetadata = {|\r\n  offset: number,\r\n  size: number,\r\n|};\r\ntype InstanceProps = {|\r\n  itemMetadataMap: { [index: number]: ItemMetadata },\r\n  estimatedItemSize: number,\r\n  lastMeasuredIndex: number,\r\n|};\r\n\r\nconst getItemMetadata = (\r\n  props: Props<any>,\r\n  index: number,\r\n  instanceProps: InstanceProps\r\n): ItemMetadata => {\r\n  const { itemSize } = ((props: any): VariableSizeProps);\r\n  const { itemMetadataMap, lastMeasuredIndex } = instanceProps;\r\n\r\n  if (index > lastMeasuredIndex) {\r\n    let offset = 0;\r\n    if (lastMeasuredIndex >= 0) {\r\n      const itemMetadata = itemMetadataMap[lastMeasuredIndex];\r\n      offset = itemMetadata.offset + itemMetadata.size;\r\n    }\r\n\r\n    for (let i = lastMeasuredIndex + 1; i <= index; i++) {\r\n      let size = ((itemSize: any): itemSizeGetter)(i);\r\n\r\n      itemMetadataMap[i] = {\r\n        offset,\r\n        size,\r\n      };\r\n\r\n      offset += size;\r\n    }\r\n\r\n    instanceProps.lastMeasuredIndex = index;\r\n  }\r\n\r\n  return itemMetadataMap[index];\r\n};\r\n\r\nconst findNearestItem = (\r\n  props: Props<any>,\r\n  instanceProps: InstanceProps,\r\n  offset: number\r\n) => {\r\n  const { itemMetadataMap, lastMeasuredIndex } = instanceProps;\r\n\r\n  const lastMeasuredItemOffset =\r\n    lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\r\n\r\n  if (lastMeasuredItemOffset >= offset) {\r\n    // If we've already measured items within this range just use a binary search as it's faster.\r\n    return findNearestItemBinarySearch(\r\n      props,\r\n      instanceProps,\r\n      lastMeasuredIndex,\r\n      0,\r\n      offset\r\n    );\r\n  } else {\r\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\r\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\r\n    // The overall complexity for this approach is O(log n).\r\n    return findNearestItemExponentialSearch(\r\n      props,\r\n      instanceProps,\r\n      Math.max(0, lastMeasuredIndex),\r\n      offset\r\n    );\r\n  }\r\n};\r\n\r\nconst findNearestItemBinarySearch = (\r\n  props: Props<any>,\r\n  instanceProps: InstanceProps,\r\n  high: number,\r\n  low: number,\r\n  offset: number\r\n): number => {\r\n  while (low <= high) {\r\n    const middle = low + Math.floor((high - low) / 2);\r\n    const currentOffset = getItemMetadata(props, middle, instanceProps).offset;\r\n\r\n    if (currentOffset === offset) {\r\n      return middle;\r\n    } else if (currentOffset < offset) {\r\n      low = middle + 1;\r\n    } else if (currentOffset > offset) {\r\n      high = middle - 1;\r\n    }\r\n  }\r\n\r\n  if (low > 0) {\r\n    return low - 1;\r\n  } else {\r\n    return 0;\r\n  }\r\n};\r\n\r\nconst findNearestItemExponentialSearch = (\r\n  props: Props<any>,\r\n  instanceProps: InstanceProps,\r\n  index: number,\r\n  offset: number\r\n): number => {\r\n  const { itemCount } = props;\r\n  let interval = 1;\r\n\r\n  while (\r\n    index < itemCount &&\r\n    getItemMetadata(props, index, instanceProps).offset < offset\r\n  ) {\r\n    index += interval;\r\n    interval *= 2;\r\n  }\r\n\r\n  return findNearestItemBinarySearch(\r\n    props,\r\n    instanceProps,\r\n    Math.min(index, itemCount - 1),\r\n    Math.floor(index / 2),\r\n    offset\r\n  );\r\n};\r\n\r\nconst getEstimatedTotalSize = (\r\n  { itemCount }: Props<any>,\r\n  { itemMetadataMap, estimatedItemSize, lastMeasuredIndex }: InstanceProps\r\n) => {\r\n  let totalSizeOfMeasuredItems = 0;\r\n\r\n  // Edge case check for when the number of items decreases while a scroll is in progress.\r\n  // https://github.com/bvaughn/react-window/pull/138\r\n  if (lastMeasuredIndex >= itemCount) {\r\n    lastMeasuredIndex = itemCount - 1;\r\n  }\r\n\r\n  if (lastMeasuredIndex >= 0) {\r\n    const itemMetadata = itemMetadataMap[lastMeasuredIndex];\r\n    totalSizeOfMeasuredItems = itemMetadata.offset + itemMetadata.size;\r\n  }\r\n\r\n  const numUnmeasuredItems = itemCount - lastMeasuredIndex - 1;\r\n  const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;\r\n\r\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;\r\n};\r\n\r\nconst VariableSizeList = createListComponent({\r\n  getItemOffset: (\r\n    props: Props<any>,\r\n    index: number,\r\n    instanceProps: InstanceProps\r\n  ): number => getItemMetadata(props, index, instanceProps).offset,\r\n\r\n  getItemSize: (\r\n    props: Props<any>,\r\n    index: number,\r\n    instanceProps: InstanceProps\r\n  ): number => instanceProps.itemMetadataMap[index].size,\r\n\r\n  getEstimatedTotalSize,\r\n\r\n  getOffsetForIndexAndAlignment: (\r\n    props: Props<any>,\r\n    index: number,\r\n    align: ScrollToAlign,\r\n    scrollOffset: number,\r\n    instanceProps: InstanceProps,\r\n    scrollbarSize: number\r\n  ): number => {\r\n    const { direction, height, layout, width } = props;\r\n\r\n    // TODO Deprecate direction \"horizontal\"\r\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\r\n    const size = (((isHorizontal ? width : height): any): number);\r\n    const itemMetadata = getItemMetadata(props, index, instanceProps);\r\n\r\n    // Get estimated total size after ItemMetadata is computed,\r\n    // To ensure it reflects actual measurements instead of just estimates.\r\n    const estimatedTotalSize = getEstimatedTotalSize(props, instanceProps);\r\n\r\n    const maxOffset = Math.max(\r\n      0,\r\n      Math.min(estimatedTotalSize - size, itemMetadata.offset)\r\n    );\r\n    const minOffset = Math.max(\r\n      0,\r\n      itemMetadata.offset - size + itemMetadata.size + scrollbarSize\r\n    );\r\n\r\n    if (align === 'smart') {\r\n      if (\r\n        scrollOffset >= minOffset - size &&\r\n        scrollOffset <= maxOffset + size\r\n      ) {\r\n        align = 'auto';\r\n      } else {\r\n        align = 'center';\r\n      }\r\n    }\r\n\r\n    switch (align) {\r\n      case 'start':\r\n        return maxOffset;\r\n      case 'end':\r\n        return minOffset;\r\n      case 'center':\r\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\r\n      case 'auto':\r\n      default:\r\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\r\n          return scrollOffset;\r\n        } else if (scrollOffset < minOffset) {\r\n          return minOffset;\r\n        } else {\r\n          return maxOffset;\r\n        }\r\n    }\r\n  },\r\n\r\n  getStartIndexForOffset: (\r\n    props: Props<any>,\r\n    offset: number,\r\n    instanceProps: InstanceProps\r\n  ): number => findNearestItem(props, instanceProps, offset),\r\n\r\n  getStopIndexForStartIndex: (\r\n    props: Props<any>,\r\n    startIndex: number,\r\n    scrollOffset: number,\r\n    instanceProps: InstanceProps\r\n  ): number => {\r\n    const { direction, height, itemCount, layout, width } = props;\r\n\r\n    // TODO Deprecate direction \"horizontal\"\r\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\r\n    const size = (((isHorizontal ? width : height): any): number);\r\n    const itemMetadata = getItemMetadata(props, startIndex, instanceProps);\r\n    const maxOffset = scrollOffset + size;\r\n\r\n    let offset = itemMetadata.offset + itemMetadata.size;\r\n    let stopIndex = startIndex;\r\n\r\n    while (stopIndex < itemCount - 1 && offset < maxOffset) {\r\n      stopIndex++;\r\n      offset += getItemMetadata(props, stopIndex, instanceProps).size;\r\n    }\r\n\r\n    return stopIndex;\r\n  },\r\n\r\n  initInstanceProps(props: Props<any>, instance: any): InstanceProps {\r\n    const { estimatedItemSize } = ((props: any): VariableSizeProps);\r\n\r\n    const instanceProps = {\r\n      itemMetadataMap: {},\r\n      estimatedItemSize: estimatedItemSize || DEFAULT_ESTIMATED_ITEM_SIZE,\r\n      lastMeasuredIndex: -1,\r\n    };\r\n\r\n    instance.resetAfterIndex = (\r\n      index: number,\r\n      shouldForceUpdate?: boolean = true\r\n    ) => {\r\n      instanceProps.lastMeasuredIndex = Math.min(\r\n        instanceProps.lastMeasuredIndex,\r\n        index - 1\r\n      );\r\n\r\n      // We could potentially optimize further by only evicting styles after this index,\r\n      // But since styles are only cached while scrolling is in progress-\r\n      // It seems an unnecessary optimization.\r\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\r\n      instance._getItemStyleCache(-1);\r\n\r\n      if (shouldForceUpdate) {\r\n        instance.forceUpdate();\r\n      }\r\n    };\r\n\r\n    return instanceProps;\r\n  },\r\n\r\n  shouldResetStyleCacheOnItemSizeChange: false,\r\n\r\n  validateProps: ({ itemSize }: Props<any>): void => {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      if (typeof itemSize !== 'function') {\r\n        throw Error(\r\n          'An invalid \"itemSize\" prop has been specified. ' +\r\n            'Value should be a function. ' +\r\n            `\"${itemSize === null ? 'null' : typeof itemSize}\" was specified.`\r\n        );\r\n      }\r\n    }\r\n  },\r\n});\r\n\r\nexport default VariableSizeList;\r\n","// @flow\r\n\r\nimport createGridComponent from './createGridComponent';\r\n\r\nimport type { Props, ScrollToAlign } from './createGridComponent';\r\n\r\nconst FixedSizeGrid = createGridComponent({\r\n  getColumnOffset: ({ columnWidth }: Props<any>, index: number): number =>\r\n    index * ((columnWidth: any): number),\r\n\r\n  getColumnWidth: ({ columnWidth }: Props<any>, index: number): number =>\r\n    ((columnWidth: any): number),\r\n\r\n  getRowOffset: ({ rowHeight }: Props<any>, index: number): number =>\r\n    index * ((rowHeight: any): number),\r\n\r\n  getRowHeight: ({ rowHeight }: Props<any>, index: number): number =>\r\n    ((rowHeight: any): number),\r\n\r\n  getEstimatedTotalHeight: ({ rowCount, rowHeight }: Props<any>) =>\r\n    ((rowHeight: any): number) * rowCount,\r\n\r\n  getEstimatedTotalWidth: ({ columnCount, columnWidth }: Props<any>) =>\r\n    ((columnWidth: any): number) * columnCount,\r\n\r\n  getOffsetForColumnAndAlignment: (\r\n    { columnCount, columnWidth, width }: Props<any>,\r\n    columnIndex: number,\r\n    align: ScrollToAlign,\r\n    scrollLeft: number,\r\n    instanceProps: typeof undefined,\r\n    scrollbarSize: number\r\n  ): number => {\r\n    const lastColumnOffset = Math.max(\r\n      0,\r\n      columnCount * ((columnWidth: any): number) - width\r\n    );\r\n    const maxOffset = Math.min(\r\n      lastColumnOffset,\r\n      columnIndex * ((columnWidth: any): number)\r\n    );\r\n    const minOffset = Math.max(\r\n      0,\r\n      columnIndex * ((columnWidth: any): number) -\r\n        width +\r\n        scrollbarSize +\r\n        ((columnWidth: any): number)\r\n    );\r\n\r\n    if (align === 'smart') {\r\n      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {\r\n        align = 'auto';\r\n      } else {\r\n        align = 'center';\r\n      }\r\n    }\r\n\r\n    switch (align) {\r\n      case 'start':\r\n        return maxOffset;\r\n      case 'end':\r\n        return minOffset;\r\n      case 'center':\r\n        // \"Centered\" offset is usually the average of the min and max.\r\n        // But near the edges of the list, this doesn't hold true.\r\n        const middleOffset = Math.round(\r\n          minOffset + (maxOffset - minOffset) / 2\r\n        );\r\n        if (middleOffset < Math.ceil(width / 2)) {\r\n          return 0; // near the beginning\r\n        } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {\r\n          return lastColumnOffset; // near the end\r\n        } else {\r\n          return middleOffset;\r\n        }\r\n      case 'auto':\r\n      default:\r\n        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {\r\n          return scrollLeft;\r\n        } else if (minOffset > maxOffset) {\r\n          // Because we only take into account the scrollbar size when calculating minOffset\r\n          // this value can be larger than maxOffset when at the end of the list\r\n          return minOffset;\r\n        } else if (scrollLeft < minOffset) {\r\n          return minOffset;\r\n        } else {\r\n          return maxOffset;\r\n        }\r\n    }\r\n  },\r\n\r\n  getOffsetForRowAndAlignment: (\r\n    { rowHeight, height, rowCount }: Props<any>,\r\n    rowIndex: number,\r\n    align: ScrollToAlign,\r\n    scrollTop: number,\r\n    instanceProps: typeof undefined,\r\n    scrollbarSize: number\r\n  ): number => {\r\n    const lastRowOffset = Math.max(\r\n      0,\r\n      rowCount * ((rowHeight: any): number) - height\r\n    );\r\n    const maxOffset = Math.min(\r\n      lastRowOffset,\r\n      rowIndex * ((rowHeight: any): number)\r\n    );\r\n    const minOffset = Math.max(\r\n      0,\r\n      rowIndex * ((rowHeight: any): number) -\r\n        height +\r\n        scrollbarSize +\r\n        ((rowHeight: any): number)\r\n    );\r\n\r\n    if (align === 'smart') {\r\n      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {\r\n        align = 'auto';\r\n      } else {\r\n        align = 'center';\r\n      }\r\n    }\r\n\r\n    switch (align) {\r\n      case 'start':\r\n        return maxOffset;\r\n      case 'end':\r\n        return minOffset;\r\n      case 'center':\r\n        // \"Centered\" offset is usually the average of the min and max.\r\n        // But near the edges of the list, this doesn't hold true.\r\n        const middleOffset = Math.round(\r\n          minOffset + (maxOffset - minOffset) / 2\r\n        );\r\n        if (middleOffset < Math.ceil(height / 2)) {\r\n          return 0; // near the beginning\r\n        } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {\r\n          return lastRowOffset; // near the end\r\n        } else {\r\n          return middleOffset;\r\n        }\r\n      case 'auto':\r\n      default:\r\n        if (scrollTop >= minOffset && scrollTop <= maxOffset) {\r\n          return scrollTop;\r\n        } else if (minOffset > maxOffset) {\r\n          // Because we only take into account the scrollbar size when calculating minOffset\r\n          // this value can be larger than maxOffset when at the end of the list\r\n          return minOffset;\r\n        } else if (scrollTop < minOffset) {\r\n          return minOffset;\r\n        } else {\r\n          return maxOffset;\r\n        }\r\n    }\r\n  },\r\n\r\n  getColumnStartIndexForOffset: (\r\n    { columnWidth, columnCount }: Props<any>,\r\n    scrollLeft: number\r\n  ): number =>\r\n    Math.max(\r\n      0,\r\n      Math.min(\r\n        columnCount - 1,\r\n        Math.floor(scrollLeft / ((columnWidth: any): number))\r\n      )\r\n    ),\r\n\r\n  getColumnStopIndexForStartIndex: (\r\n    { columnWidth, columnCount, width }: Props<any>,\r\n    startIndex: number,\r\n    scrollLeft: number\r\n  ): number => {\r\n    const left = startIndex * ((columnWidth: any): number);\r\n    const numVisibleColumns = Math.ceil(\r\n      (width + scrollLeft - left) / ((columnWidth: any): number)\r\n    );\r\n    return Math.max(\r\n      0,\r\n      Math.min(\r\n        columnCount - 1,\r\n        startIndex + numVisibleColumns - 1 // -1 is because stop index is inclusive\r\n      )\r\n    );\r\n  },\r\n\r\n  getRowStartIndexForOffset: (\r\n    { rowHeight, rowCount }: Props<any>,\r\n    scrollTop: number\r\n  ): number =>\r\n    Math.max(\r\n      0,\r\n      Math.min(rowCount - 1, Math.floor(scrollTop / ((rowHeight: any): number)))\r\n    ),\r\n\r\n  getRowStopIndexForStartIndex: (\r\n    { rowHeight, rowCount, height }: Props<any>,\r\n    startIndex: number,\r\n    scrollTop: number\r\n  ): number => {\r\n    const top = startIndex * ((rowHeight: any): number);\r\n    const numVisibleRows = Math.ceil(\r\n      (height + scrollTop - top) / ((rowHeight: any): number)\r\n    );\r\n    return Math.max(\r\n      0,\r\n      Math.min(\r\n        rowCount - 1,\r\n        startIndex + numVisibleRows - 1 // -1 is because stop index is inclusive\r\n      )\r\n    );\r\n  },\r\n\r\n  initInstanceProps(props: Props<any>): any {\r\n    // Noop\r\n  },\r\n\r\n  shouldResetStyleCacheOnItemSizeChange: true,\r\n\r\n  validateProps: ({ columnWidth, rowHeight }: Props<any>): void => {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      if (typeof columnWidth !== 'number') {\r\n        throw Error(\r\n          'An invalid \"columnWidth\" prop has been specified. ' +\r\n            'Value should be a number. ' +\r\n            `\"${\r\n              columnWidth === null ? 'null' : typeof columnWidth\r\n            }\" was specified.`\r\n        );\r\n      }\r\n\r\n      if (typeof rowHeight !== 'number') {\r\n        throw Error(\r\n          'An invalid \"rowHeight\" prop has been specified. ' +\r\n            'Value should be a number. ' +\r\n            `\"${rowHeight === null ? 'null' : typeof rowHeight}\" was specified.`\r\n        );\r\n      }\r\n    }\r\n  },\r\n});\r\n\r\nexport default FixedSizeGrid;\r\n","// @flow\r\n\r\nimport createListComponent from './createListComponent';\r\n\r\nimport type { Props, ScrollToAlign } from './createListComponent';\r\n\r\ntype InstanceProps = any;\r\n\r\nconst FixedSizeList = createListComponent({\r\n  getItemOffset: ({ itemSize }: Props<any>, index: number): number =>\r\n    index * ((itemSize: any): number),\r\n\r\n  getItemSize: ({ itemSize }: Props<any>, index: number): number =>\r\n    ((itemSize: any): number),\r\n\r\n  getEstimatedTotalSize: ({ itemCount, itemSize }: Props<any>) =>\r\n    ((itemSize: any): number) * itemCount,\r\n\r\n  getOffsetForIndexAndAlignment: (\r\n    { direction, height, itemCount, itemSize, layout, width }: Props<any>,\r\n    index: number,\r\n    align: ScrollToAlign,\r\n    scrollOffset: number,\r\n    instanceProps: InstanceProps,\r\n    scrollbarSize: number\r\n  ): number => {\r\n    // TODO Deprecate direction \"horizontal\"\r\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\r\n    const size = (((isHorizontal ? width : height): any): number);\r\n    const lastItemOffset = Math.max(\r\n      0,\r\n      itemCount * ((itemSize: any): number) - size\r\n    );\r\n    const maxOffset = Math.min(\r\n      lastItemOffset,\r\n      index * ((itemSize: any): number)\r\n    );\r\n    const minOffset = Math.max(\r\n      0,\r\n      index * ((itemSize: any): number) -\r\n        size +\r\n        ((itemSize: any): number) +\r\n        scrollbarSize\r\n    );\r\n\r\n    if (align === 'smart') {\r\n      if (\r\n        scrollOffset >= minOffset - size &&\r\n        scrollOffset <= maxOffset + size\r\n      ) {\r\n        align = 'auto';\r\n      } else {\r\n        align = 'center';\r\n      }\r\n    }\r\n\r\n    switch (align) {\r\n      case 'start':\r\n        return maxOffset;\r\n      case 'end':\r\n        return minOffset;\r\n      case 'center': {\r\n        // \"Centered\" offset is usually the average of the min and max.\r\n        // But near the edges of the list, this doesn't hold true.\r\n        const middleOffset = Math.round(\r\n          minOffset + (maxOffset - minOffset) / 2\r\n        );\r\n        if (middleOffset < Math.ceil(size / 2)) {\r\n          return 0; // near the beginning\r\n        } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {\r\n          return lastItemOffset; // near the end\r\n        } else {\r\n          return middleOffset;\r\n        }\r\n      }\r\n      case 'auto':\r\n      default:\r\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\r\n          return scrollOffset;\r\n        } else if (scrollOffset < minOffset) {\r\n          return minOffset;\r\n        } else {\r\n          return maxOffset;\r\n        }\r\n    }\r\n  },\r\n\r\n  getStartIndexForOffset: (\r\n    { itemCount, itemSize }: Props<any>,\r\n    offset: number\r\n  ): number =>\r\n    Math.max(\r\n      0,\r\n      Math.min(itemCount - 1, Math.floor(offset / ((itemSize: any): number)))\r\n    ),\r\n\r\n  getStopIndexForStartIndex: (\r\n    { direction, height, itemCount, itemSize, layout, width }: Props<any>,\r\n    startIndex: number,\r\n    scrollOffset: number\r\n  ): number => {\r\n    // TODO Deprecate direction \"horizontal\"\r\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\r\n    const offset = startIndex * ((itemSize: any): number);\r\n    const size = (((isHorizontal ? width : height): any): number);\r\n    const numVisibleItems = Math.ceil(\r\n      (size + scrollOffset - offset) / ((itemSize: any): number)\r\n    );\r\n    return Math.max(\r\n      0,\r\n      Math.min(\r\n        itemCount - 1,\r\n        startIndex + numVisibleItems - 1 // -1 is because stop index is inclusive\r\n      )\r\n    );\r\n  },\r\n\r\n  initInstanceProps(props: Props<any>): any {\r\n    // Noop\r\n  },\r\n\r\n  shouldResetStyleCacheOnItemSizeChange: true,\r\n\r\n  validateProps: ({ itemSize }: Props<any>): void => {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      if (typeof itemSize !== 'number') {\r\n        throw Error(\r\n          'An invalid \"itemSize\" prop has been specified. ' +\r\n            'Value should be a number. ' +\r\n            `\"${itemSize === null ? 'null' : typeof itemSize}\" was specified.`\r\n        );\r\n      }\r\n    }\r\n  },\r\n});\r\n\r\nexport default FixedSizeList;\r\n","// @flow\r\n\r\n// Pulled from react-compat\r\n// https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349\r\nexport default function shallowDiffers(prev: Object, next: Object): boolean {\r\n  for (let attribute in prev) {\r\n    if (!(attribute in next)) {\r\n      return true;\r\n    }\r\n  }\r\n  for (let attribute in next) {\r\n    if (prev[attribute] !== next[attribute]) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n","// @flow\r\n\r\nimport shallowDiffers from './shallowDiffers';\r\n\r\n// Custom comparison function for React.memo().\r\n// It knows to compare individual style props and ignore the wrapper object.\r\n// See https://reactjs.org/docs/react-api.html#reactmemo\r\nexport default function areEqual(\r\n  prevProps: Object,\r\n  nextProps: Object\r\n): boolean {\r\n  const { style: prevStyle, ...prevRest } = prevProps;\r\n  const { style: nextStyle, ...nextRest } = nextProps;\r\n\r\n  return (\r\n    !shallowDiffers(prevStyle, nextStyle) && !shallowDiffers(prevRest, nextRest)\r\n  );\r\n}\r\n","// @flow\r\n\r\nimport areEqual from './areEqual';\r\nimport shallowDiffers from './shallowDiffers';\r\n\r\n// Custom shouldComponentUpdate for class components.\r\n// It knows to compare individual style props and ignore the wrapper object.\r\n// See https://reactjs.org/docs/react-component.html#shouldcomponentupdate\r\nexport default function shouldComponentUpdate(\r\n  nextProps: Object,\r\n  nextState: Object\r\n): boolean {\r\n  return (\r\n    !areEqual(this.props, nextProps) || shallowDiffers(this.state, nextState)\r\n  );\r\n}\r\n"],"names":["hasNativePerformanceNow","performance","now","Date","cancelTimeout","timeoutID","cancelAnimationFrame","id","requestTimeout","callback","delay","start","tick","call","requestAnimationFrame","size","getScrollbarSize","recalculate","div","document","createElement","style","width","height","overflow","body","appendChild","offsetWidth","clientWidth","removeChild","cachedRTLResult","getRTLOffsetType","outerDiv","outerStyle","direction","innerDiv","innerStyle","scrollLeft","IS_SCROLLING_DEBOUNCE_INTERVAL","defaultItemKey","columnIndex","data","rowIndex","devWarningsOverscanCount","devWarningsOverscanRowsColumnsCount","devWarningsTagName","process","env","NODE_ENV","window","WeakSet","createGridComponent","getColumnOffset","getColumnStartIndexForOffset","getColumnStopIndexForStartIndex","getColumnWidth","getEstimatedTotalHeight","getEstimatedTotalWidth","getOffsetForColumnAndAlignment","getOffsetForRowAndAlignment","getRowHeight","getRowOffset","getRowStartIndexForOffset","getRowStopIndexForStartIndex","initInstanceProps","shouldResetStyleCacheOnItemSizeChange","validateProps","props","_instanceProps","_resetIsScrollingTimeoutId","_outerRef","state","instance","isScrolling","horizontalScrollDirection","initialScrollLeft","scrollTop","initialScrollTop","scrollUpdateWasRequested","verticalScrollDirection","_callOnItemsRendered","memoizeOne","overscanColumnStartIndex","overscanColumnStopIndex","overscanRowStartIndex","overscanRowStopIndex","visibleColumnStartIndex","visibleColumnStopIndex","visibleRowStartIndex","visibleRowStopIndex","onItemsRendered","_callOnScroll","onScroll","_getItemStyle","columnWidth","rowHeight","itemStyleCache","_getItemStyleCache","key","hasOwnProperty","offset","isRtl","position","left","undefined","right","top","_","__","___","_onScroll","event","currentTarget","clientHeight","scrollHeight","scrollWidth","setState","prevState","calculatedScrollLeft","Math","max","min","calculatedScrollTop","_resetIsScrollingDebounced","_outerRefSetter","ref","outerRef","current","_resetIsScrolling","getDerivedStateFromProps","nextProps","validateSharedProps","scrollTo","scrollToItem","align","columnCount","rowCount","scrollbarSize","estimatedTotalHeight","estimatedTotalWidth","horizontalScrollbarSize","verticalScrollbarSize","componentDidMount","_callPropsCallbacks","componentDidUpdate","componentWillUnmount","render","children","className","innerRef","innerElementType","innerTagName","itemData","itemKey","outerElementType","outerTagName","useIsScrolling","disableColVirtualized","disableRowVirtualized","_getHorizontalRangeToRender","columnStartIndex","columnStopIndex","_getVerticalRangeToRender","rowStartIndex","rowStopIndex","items","push","WebkitOverflowScrolling","willChange","pointerEvents","overscanColumnCount","overscanColumnsCount","overscanCount","overscanCountResolved","startIndex","stopIndex","overscanBackward","overscanForward","overscanRowCount","overscanRowsCount","PureComponent","defaultProps","has","add","console","warn","Error","DEFAULT_ESTIMATED_ITEM_SIZE","rowMetadataMap","estimatedRowHeight","lastMeasuredRowIndex","totalSizeOfMeasuredRows","itemMetadata","numUnmeasuredItems","totalSizeOfUnmeasuredItems","columnMetadataMap","estimatedColumnWidth","lastMeasuredColumnIndex","getItemMetadata","itemType","index","instanceProps","itemMetadataMap","itemSize","lastMeasuredIndex","i","findNearestItem","lastMeasuredItemOffset","findNearestItemBinarySearch","findNearestItemExponentialSearch","high","low","middle","floor","currentOffset","itemCount","interval","getOffsetForIndexAndAlignment","scrollOffset","estimatedTotalSize","maxOffset","minOffset","round","VariableSizeGrid","resetAfterColumnIndex","shouldForceUpdate","resetAfterIndices","resetAfterRowIndex","forceUpdate","devWarningsDirection","createListComponent","getItemOffset","getEstimatedTotalSize","getItemSize","getStartIndexForOffset","getStopIndexForStartIndex","scrollDirection","initialScrollOffset","overscanStartIndex","overscanStopIndex","visibleStartIndex","visibleStopIndex","layout","isHorizontal","offsetHorizontal","_onScrollHorizontal","_onScrollVertical","_getRangeToRender","estimatedItemSize","totalSizeOfMeasuredItems","VariableSizeList","resetAfterIndex","FixedSizeGrid","lastColumnOffset","middleOffset","ceil","lastRowOffset","numVisibleColumns","numVisibleRows","FixedSizeList","lastItemOffset","numVisibleItems","shallowDiffers","prev","next","attribute","areEqual","prevProps","prevStyle","prevRest","nextStyle","nextRest","shouldComponentUpdate","nextState"],"mappings":"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"}
\ No newline at end of file
